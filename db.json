{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.js","path":"main.234bc0.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.234bc0.css","path":"main.234bc0.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.css.beifen","path":"main.css.beifen","modified":1,"renderable":1}],"Cache":[{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1491637999162},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1491637999162},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1491637999162},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1491637999162},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1491637999162},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1491637999162},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1491637999162},{"_id":"source/_draft/最近需要完成的任务.txt","hash":"89a1e39e79f9985a4a164d167fbfa2a7ea814b9d","modified":1492526511334},{"_id":"source/_posts/.project","hash":"96b0fcfbb5983eee8dc193c771627dae3c1e637d","modified":1497798029238},{"_id":"source/_posts/cookie小结.md","hash":"6d27fc8f8cb9b7ce23e82ca10ef61fa380ad017f","modified":1491752994001},{"_id":"source/_drafts/最近的规划.md","hash":"1ecdfc9e5cb956b2249044e6606be927ec145a83","modified":1499702144104},{"_id":"themes/yilia/webpack.config.js","hash":"14fe482547b12b15bc78cb981c42a4ca5b6ba770","modified":1491637999240},{"_id":"source/_posts/javascript高阶函数.md","hash":"0d207106ef5ea2cf96a788078904654ba4ecf9c5","modified":1499572319493},{"_id":"source/_posts/git常用命令总结.md","hash":"4f72f35dd8340346b6692153b89165414ac9f35f","modified":1494039069796},{"_id":"themes/yilia/package.json","hash":"4631f9013f0b1c5fc5d73af4c3624375bfe4d109","modified":1491637999193},{"_id":"source/_posts/nodejs之path模块.md","hash":"55ffe3ff8a1355e7167c962703f9cebbab51938d","modified":1494343504135},{"_id":"themes/yilia/_config.yml","hash":"7d84327740622394c20bb1611039347df18d1c15","modified":1498355816382},{"_id":"source/_posts/node核心模块--fs.md","hash":"0c2f2ad26c25442a82658b82fca3cd645a6371ee","modified":1492529249006},{"_id":"source/_posts/mongoose的一些操作命令.md","hash":"2c887f4c2316618ce72128f9bec109187464a3fa","modified":1494152057057},{"_id":"source/_posts/hexo+github搭建自己的博客.md","hash":"1e00d02995f4dff793118f8af1d0895deb41090f","modified":1491753177146},{"_id":"source/_posts/手写一个router.md","hash":"ce7eafb1ed0e4eaa9cee60e322f96209fa65ada7","modified":1498358782905},{"_id":"source/_posts/老生常谈-从输入url到页面展示到底发生了什么.md","hash":"f4fa0f401c03e83249c4faaf90ffa42e46619c11","modified":1491752994006},{"_id":"source/demo/router1.html","hash":"4670bd80a5544b2d247b709557efd33cee982fb6","modified":1498358095132},{"_id":"source/_posts/使用vue2+vue-router+vuex写一个cnode的脚手架.md","hash":"257aec3230ceeb610f1da3ff263df21e548e7b26","modified":1491752994004},{"_id":"source/suibi/随笔，杂谈.md","hash":"e3b17c8a2eda2d820a512649d4833e8243be51f1","modified":1491752994008},{"_id":"source/suibi/index.md","hash":"56406935a719cad87d4d8c86a6fd31e794edf6da","modified":1491752994007},{"_id":"themes/yilia/.git/config","hash":"24300cece9d72967ea63724bdb2a8e3c2ac2cc52","modified":1491637999146},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1491637999131},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1491637864746},{"_id":"themes/yilia/.git/index","hash":"4981767c176adcfec997438c1c9e36b6eb9bb0d2","modified":1491751283448},{"_id":"themes/yilia/.git/packed-refs","hash":"144a02fde3eaced071755091d413698cb7e8382d","modified":1491637999115},{"_id":"source/_posts/老生常谈css实现左侧固定，右侧自适应.md","hash":"b8dd0f759d8a6b17d95e9eb67d720298efdfce53","modified":1495726944747},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1491637999193},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1491637999193},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1491637999193},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491637999193},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1491637999193},{"_id":"source/_posts/以setTimeout来聊聊Event Loop.md","hash":"f540196e9d50f7dca4818cdc975c20da09f9de7e","modified":1492530001624},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1491637999193},{"_id":"source/_posts/正则表达式学习.md","hash":"cd3bb6c38f5ad43aca08261f95351c229f47e959","modified":1497276819439},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1491637999193},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1491637999162},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1491637999162},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1491637999162},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1491637999162},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1491637999178},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1491637999178},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1491637999178},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1491637999240},{"_id":"themes/yilia/source/main.234bc0.js","hash":"a0359e7962038f53f9ffbd02dcc52485f8e04da8","modified":1491637999225},{"_id":"themes/yilia/source/main.234bc0.css","hash":"2323cec9eac1895d58e877404ff34ed3092d3b69","modified":1497673048914},{"_id":"themes/yilia/source/slider.885efe.js","hash":"41a76cb10a2b344d54a15ffac68d17331fc6f3d6","modified":1491637999240},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1491637999193},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1491637864887},{"_id":"themes/yilia/.git/logs/HEAD","hash":"0ba3c3068bbe43239a45967b5c28d7f8793393b6","modified":1491637999131},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1491637999178},{"_id":"source/demo/router2.html","hash":"9a3266df230a5973876d1a00de19c7bffba5551d","modified":1498358465452},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"1b91850e8708ce4c83e3cc3f474921182d792308","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1491637999178},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1491637999225},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"d914665125366a292ce751d0663321b00cfdc6e7","modified":1497672849754},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"eb8daa0cd61c1caa7aa7876772f04c1399ed7ac9","modified":1497671341992},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"538b6d35b25cbdba7dc77feec638336625c8ef8b","modified":1491637999193},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1491637999225},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"c4a0f16d554e7e7007856d45b78443d7bf0b40b7","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1491637999193},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491637999225},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491637999225},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491637999225},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1491637999225},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1491637999225},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491637999225},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1491637999225},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491637999225},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"16f47525f0a8c508ac83cae4f1d632e6dae42218","modified":1491749950863},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1491637864778},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1491637864778},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1491637864793},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1491637864778},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1491637864856},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1491637864793},{"_id":"themes/yilia/source/main.css.beifen","hash":"a19f87ac9e95e86ae8f902193974973aa398a72d","modified":1497673011751},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1491637864793},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1491637864856},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1491637864793},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1491637999193},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1491637999193},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"8a0ae8ee6af8df3f215f1cd4ecc10145a5b92cf0","modified":1491637999193},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"9069371dcc65eee63081a21e8a56a9f3dbf64c08","modified":1491637999193},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4115c4518cca3f5cf461018aa7a7321138d017cc","modified":1491637999193},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1491637999193},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"948e44c47c3d70584da93e7ce025dede9b7573d7","modified":1491637999193},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1491637999209},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1491637999209},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1491637999193},{"_id":"themes/yilia/source-src/css/main.scss","hash":"b63c0f9b3bf68efc3bcd7c816bcac6f2fb827528","modified":1491637999209},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1491637999193},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1491637999209},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1491637999209},{"_id":"themes/yilia/source-src/css/left.scss","hash":"1ee3dd6fa50186af5bedb09d4a0e6b47ddb1b57b","modified":1491637999209},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1491637999209},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1491637999209},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1491637999209},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1491637999209},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1491637999209},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1491637999209},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"28a01c3d85ec3194095f96988642a16d461f1077","modified":1491637999209},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1491637999209},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1491637999209},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"f5bed08765a8f0a344af5d4781ff822a57028148","modified":1491637999209},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1491637999209},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1491637999225},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1491637999225},{"_id":"themes/yilia/source-src/js/fix.js","hash":"eccdcc7ee79adebf450bc655b2e80eb6801421a6","modified":1491637999225},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1491637999225},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1491637999225},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1491637999225},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1491637999225},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1491637999225},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1491637999225},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1491637999225},{"_id":"themes/yilia/.git/refs/heads/master","hash":"ec274ad8176ea701ec280f2352a47451b498c39a","modified":1491637999131},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1491637999209},{"_id":"themes/yilia/layout/_partial/comments/youyan.ejs","hash":"2705dc94157def3179d3951e2092a36d6358d3db","modified":1491663263875},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/comments/duoshuo.ejs","hash":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1451660915824},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1491637999178},{"_id":"themes/yilia/.git/objects/pack/pack-be13325d317e3a89141954f66fddd6a4bf755f1f.idx","hash":"ff4b1c23eea3b09405a4400f8c75b5f7d78ef80c","modified":1491637998752},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/comments/disqus.ejs","hash":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1451655251921},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1491637999193},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1491637999193},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1491637999178},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1491637999178},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1491637999193},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1491637999209},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1491637999193},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1491637999209},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1491637999193},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1491637999209},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1491637999209},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1491637999209},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"0ba3c3068bbe43239a45967b5c28d7f8793393b6","modified":1491637999131},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1491637999131},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1491637999209},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1491637999209},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"0ba3c3068bbe43239a45967b5c28d7f8793393b6","modified":1491637999131},{"_id":"themes/yilia/.git/objects/pack/pack-be13325d317e3a89141954f66fddd6a4bf755f1f.pack","hash":"1c5329c6d05d20cc68367c867c04597098a49341","modified":1491637998893}],"Category":[{"name":"vue","_id":"cj5b4gr87000n9gscg96vz4ws"}],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>router test</title>\n\t</head>\n\t<body>\n\t\t<ul> \n\t\t    <li><a href=\"#/\">index</a></li> \n\t\t    <li><a href=\"#/page1\">page1</a></li> \n\t\t    <li><a href=\"#/page2\">page2</a></li> \n\t\t</ul> \n\t\t<p class=\"text\"></p>\n\t</body>\n\t<script type=\"text/javascript\">\n\t\tfunction Router() {\n\t\t\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\t\t\tthis.currentUrl = ''; //当前路由\n\t\t}\n\t\t// 注册路由路径和存储回调函数\n\t\tRouter.prototype.route = function(path,callback) {\n\t\t\tthis.routers[path] = callback || function() {}\n\t\t}\n\t\t// 更新页面，其实就是执行注册的回调函数\n\t\tRouter.prototype.refresh = function() {\n\t\t\tthis.currentUrl = location.hash.slice(1) || '/';\n\t\t\tthis.routers[this.currentUrl]();\n\t\t}\n\t\tRouter.prototype.init = function() {\n\t\t\twindow.addEventListener('load',this.refresh.bind(this),false);\n\t\t\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n\t\t}\n\t\twindow.Router = new Router();\n\t\twindow.Router.init();\n\t\t\n\t\t\n\t\tvar text = document.querySelector('.text');\n\t\tRouter.route('/', function() {\n\t\t\ttext.innerHTML = '这里是首页';\n\t\t});\n\t\tRouter.route('/page1', function() {\n\t\t    text.innerHTML = '这里是page1';\n\t\t});\n\t\tRouter.route('/page2', function() {\n\t\t    text.innerHTML = '这里是page2';\n\t\t});\n\t</script>\n</html>\n","source":"demo/router1.html","raw":"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>router test</title>\n\t</head>\n\t<body>\n\t\t<ul> \n\t\t    <li><a href=\"#/\">index</a></li> \n\t\t    <li><a href=\"#/page1\">page1</a></li> \n\t\t    <li><a href=\"#/page2\">page2</a></li> \n\t\t</ul> \n\t\t<p class=\"text\"></p>\n\t</body>\n\t<script type=\"text/javascript\">\n\t\tfunction Router() {\n\t\t\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\t\t\tthis.currentUrl = ''; //当前路由\n\t\t}\n\t\t// 注册路由路径和存储回调函数\n\t\tRouter.prototype.route = function(path,callback) {\n\t\t\tthis.routers[path] = callback || function() {}\n\t\t}\n\t\t// 更新页面，其实就是执行注册的回调函数\n\t\tRouter.prototype.refresh = function() {\n\t\t\tthis.currentUrl = location.hash.slice(1) || '/';\n\t\t\tthis.routers[this.currentUrl]();\n\t\t}\n\t\tRouter.prototype.init = function() {\n\t\t\twindow.addEventListener('load',this.refresh.bind(this),false);\n\t\t\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n\t\t}\n\t\twindow.Router = new Router();\n\t\twindow.Router.init();\n\t\t\n\t\t\n\t\tvar text = document.querySelector('.text');\n\t\tRouter.route('/', function() {\n\t\t\ttext.innerHTML = '这里是首页';\n\t\t});\n\t\tRouter.route('/page1', function() {\n\t\t    text.innerHTML = '这里是page1';\n\t\t});\n\t\tRouter.route('/page2', function() {\n\t\t    text.innerHTML = '这里是page2';\n\t\t});\n\t</script>\n</html>\n","date":"2017-06-25T02:34:55.132Z","updated":"2017-06-25T02:34:55.132Z","path":"demo/router1.html","title":"","comments":1,"layout":"page","_id":"cj5b4gr4b00019gsc8iboh2dz","content":"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>router test</title>\n\t</head>\n\t<body>\n\t\t<ul> \n\t\t    <li><a href=\"#/\">index</a></li> \n\t\t    <li><a href=\"#/page1\">page1</a></li> \n\t\t    <li><a href=\"#/page2\">page2</a></li> \n\t\t</ul> \n\t\t<p class=\"text\"></p>\n\t</body>\n\t<script type=\"text/javascript\">\n\t\tfunction Router() {\n\t\t\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\t\t\tthis.currentUrl = ''; //当前路由\n\t\t}\n\t\t// 注册路由路径和存储回调函数\n\t\tRouter.prototype.route = function(path,callback) {\n\t\t\tthis.routers[path] = callback || function() {}\n\t\t}\n\t\t// 更新页面，其实就是执行注册的回调函数\n\t\tRouter.prototype.refresh = function() {\n\t\t\tthis.currentUrl = location.hash.slice(1) || '/';\n\t\t\tthis.routers[this.currentUrl]();\n\t\t}\n\t\tRouter.prototype.init = function() {\n\t\t\twindow.addEventListener('load',this.refresh.bind(this),false);\n\t\t\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n\t\t}\n\t\twindow.Router = new Router();\n\t\twindow.Router.init();\n\t\t\n\t\t\n\t\tvar text = document.querySelector('.text');\n\t\tRouter.route('/', function() {\n\t\t\ttext.innerHTML = '这里是首页';\n\t\t});\n\t\tRouter.route('/page1', function() {\n\t\t    text.innerHTML = '这里是page1';\n\t\t});\n\t\tRouter.route('/page2', function() {\n\t\t    text.innerHTML = '这里是page2';\n\t\t});\n\t</script>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>router test</title>\n\t</head>\n\t<body>\n\t\t<ul> \n\t\t    <li><a href=\"#/\">index</a></li> \n\t\t    <li><a href=\"#/page1\">page1</a></li> \n\t\t    <li><a href=\"#/page2\">page2</a></li> \n\t\t</ul> \n\t\t<p class=\"text\"></p>\n\t</body>\n\t<script type=\"text/javascript\">\n\t\tfunction Router() {\n\t\t\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\t\t\tthis.currentUrl = ''; //当前路由\n\t\t}\n\t\t// 注册路由路径和存储回调函数\n\t\tRouter.prototype.route = function(path,callback) {\n\t\t\tthis.routers[path] = callback || function() {}\n\t\t}\n\t\t// 更新页面，其实就是执行注册的回调函数\n\t\tRouter.prototype.refresh = function() {\n\t\t\tthis.currentUrl = location.hash.slice(1) || '/';\n\t\t\tthis.routers[this.currentUrl]();\n\t\t}\n\t\tRouter.prototype.init = function() {\n\t\t\twindow.addEventListener('load',this.refresh.bind(this),false);\n\t\t\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n\t\t}\n\t\twindow.Router = new Router();\n\t\twindow.Router.init();\n\t\t\n\t\t\n\t\tvar text = document.querySelector('.text');\n\t\tRouter.route('/', function() {\n\t\t\ttext.innerHTML = '这里是首页';\n\t\t});\n\t\tRouter.route('/page1', function() {\n\t\t    text.innerHTML = '这里是page1';\n\t\t});\n\t\tRouter.route('/page2', function() {\n\t\t    text.innerHTML = '这里是page2';\n\t\t});\n\t</script>\n</html>\n"},{"title":"随笔","date":"2017-04-08T17:12:21.000Z","categories":["随笔"],"_content":"\n随便测试，如果把tags写为随笔，那么就会导航页的随笔中显示，在主题那里的menu可以配置更多的目录。\n\n参考参考这篇文章 [http://www.jianshu.com/p/b7886271e21a](http://www.jianshu.com/p/b7886271e21a)\n\n\n\n\n\n\n","source":"suibi/随笔，杂谈.md","raw":"---\ntitle: 随笔\ndate: 2017-04-09 01:12:21\ncategories: [随笔]\n---\n\n随便测试，如果把tags写为随笔，那么就会导航页的随笔中显示，在主题那里的menu可以配置更多的目录。\n\n参考参考这篇文章 [http://www.jianshu.com/p/b7886271e21a](http://www.jianshu.com/p/b7886271e21a)\n\n\n\n\n\n\n","updated":"2017-04-09T15:49:54.008Z","path":"suibi/随笔，杂谈.html","comments":1,"layout":"page","_id":"cj5b4gr4r00039gscss7ti4qa","content":"<p>随便测试，如果把tags写为随笔，那么就会导航页的随笔中显示，在主题那里的menu可以配置更多的目录。</p>\n<p>参考参考这篇文章 <a href=\"http://www.jianshu.com/p/b7886271e21a\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/b7886271e21a</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>随便测试，如果把tags写为随笔，那么就会导航页的随笔中显示，在主题那里的menu可以配置更多的目录。</p>\n<p>参考参考这篇文章 <a href=\"http://www.jianshu.com/p/b7886271e21a\">http://www.jianshu.com/p/b7886271e21a</a></p>\n"},{"title":"杂谈简介","date":"2017-04-08T17:12:21.000Z","_content":"\n这里主要是用来写一些杂七杂八，跟技术无关的东西，因为博客嘛，不一定都是用来写技术文章的，什么都可以写。\n","source":"suibi/index.md","raw":"---\ntitle: 杂谈简介\ndate: 2017-04-09 01:12:21\n---\n\n这里主要是用来写一些杂七杂八，跟技术无关的东西，因为博客嘛，不一定都是用来写技术文章的，什么都可以写。\n","updated":"2017-04-09T15:49:54.007Z","path":"suibi/index.html","comments":1,"layout":"page","_id":"cj5b4gr5n00069gsc6psxfgzi","content":"<p>这里主要是用来写一些杂七杂八，跟技术无关的东西，因为博客嘛，不一定都是用来写技术文章的，什么都可以写。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里主要是用来写一些杂七杂八，跟技术无关的东西，因为博客嘛，不一定都是用来写技术文章的，什么都可以写。</p>\n"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>router2</title>\n</head>\n\n<body>\n\t<a href=\"#index\">首页</a>\n    <a href=\"#detail/1654499\">详情页</a>\n</body>\n\n<script type=\"text/javascript\">\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\n    var Router = {\n    \t\n        /**\n         * 注册的所有路由对象\n         */\n        hashList: {},\n \t\t\n \t\t/**\n \t\t * 当前路由\n \t\t */\n        index: null,\n   \n\n        /**\n         * Add router\n         * 注册路由对象\n \t\t**/\n        add: function (path,callback) {\n        \t\n            this.hashList[path] = callback;\n        },\n        \n        /**\n         * 跳转到指定路由\n         */\n        go: function(path) {\n        \t\n        \twindow.location.hash = '#' + path;\n        },\n        \n        /**\n         * 删除路由\n         */\n        remove: function(path) {\t \n        \t\n\t        delete this.hashList[path];\n\t    },\n        /**\n         * 重新加载页面\n         */\n        reload:function() {\n        \tvar self = this;\n\t        var hash = window.location.hash.replace('#', '');\n\t        var addr = hash.split('/')[0];\n\t        var cb =   self.getCb(addr, self.hashList);\n\t        if(cb != false) {\n\t            var arr = hash.split('/');\n\t            arr.shift();\n\t            cb.apply(self, arr);\n\t        } else {\n\t            self.index && self.go(self.index);\n\t        }\n        },\n\n     \t/**\n\t     * 设置主页地址\n\t     * @param index: 主页地址\n\t     */\n\t    setIndex: function(index) {\n\t        this.index = index;\n\t    },\n\t    \n\t     /**\n\t     * 获取callback\n\t     * @return false or callback\n\t     */\n\t    getCb: function(addr, hashList) {\n\t        for(var key in hashList) {\n\t            if(key == addr) {\n\t                return hashList[key]\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    \n\t    /**\n         * 初始化路由\n         */\n        init: function (options) {\n        \tvar self = this;\n        \twindow.onhashchange = function() {\n\t            self.reload();\n\t        };\n        },\n        start: function() {\n        \tthis.reload();\n        }\n    };\n\n\treturn Router;\n    \n}));\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n\n</script>\n</html>\n","source":"demo/router2.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>router2</title>\n</head>\n\n<body>\n\t<a href=\"#index\">首页</a>\n    <a href=\"#detail/1654499\">详情页</a>\n</body>\n\n<script type=\"text/javascript\">\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\n    var Router = {\n    \t\n        /**\n         * 注册的所有路由对象\n         */\n        hashList: {},\n \t\t\n \t\t/**\n \t\t * 当前路由\n \t\t */\n        index: null,\n   \n\n        /**\n         * Add router\n         * 注册路由对象\n \t\t**/\n        add: function (path,callback) {\n        \t\n            this.hashList[path] = callback;\n        },\n        \n        /**\n         * 跳转到指定路由\n         */\n        go: function(path) {\n        \t\n        \twindow.location.hash = '#' + path;\n        },\n        \n        /**\n         * 删除路由\n         */\n        remove: function(path) {\t \n        \t\n\t        delete this.hashList[path];\n\t    },\n        /**\n         * 重新加载页面\n         */\n        reload:function() {\n        \tvar self = this;\n\t        var hash = window.location.hash.replace('#', '');\n\t        var addr = hash.split('/')[0];\n\t        var cb =   self.getCb(addr, self.hashList);\n\t        if(cb != false) {\n\t            var arr = hash.split('/');\n\t            arr.shift();\n\t            cb.apply(self, arr);\n\t        } else {\n\t            self.index && self.go(self.index);\n\t        }\n        },\n\n     \t/**\n\t     * 设置主页地址\n\t     * @param index: 主页地址\n\t     */\n\t    setIndex: function(index) {\n\t        this.index = index;\n\t    },\n\t    \n\t     /**\n\t     * 获取callback\n\t     * @return false or callback\n\t     */\n\t    getCb: function(addr, hashList) {\n\t        for(var key in hashList) {\n\t            if(key == addr) {\n\t                return hashList[key]\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    \n\t    /**\n         * 初始化路由\n         */\n        init: function (options) {\n        \tvar self = this;\n        \twindow.onhashchange = function() {\n\t            self.reload();\n\t        };\n        },\n        start: function() {\n        \tthis.reload();\n        }\n    };\n\n\treturn Router;\n    \n}));\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n\n</script>\n</html>\n","date":"2017-06-25T02:41:05.452Z","updated":"2017-06-25T02:41:05.452Z","path":"demo/router2.html","title":"","comments":1,"layout":"page","_id":"cj5b4grfj001w9gscfws1uft2","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>router2</title>\n</head>\n\n<body>\n\t<a href=\"#index\">首页</a>\n    <a href=\"#detail/1654499\">详情页</a>\n</body>\n\n<script type=\"text/javascript\">\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\n    var Router = {\n    \t\n        /**\n         * 注册的所有路由对象\n         */\n        hashList: {},\n \t\t\n \t\t/**\n \t\t * 当前路由\n \t\t */\n        index: null,\n   \n\n        /**\n         * Add router\n         * 注册路由对象\n \t\t**/\n        add: function (path,callback) {\n        \t\n            this.hashList[path] = callback;\n        },\n        \n        /**\n         * 跳转到指定路由\n         */\n        go: function(path) {\n        \t\n        \twindow.location.hash = '#' + path;\n        },\n        \n        /**\n         * 删除路由\n         */\n        remove: function(path) {\t \n        \t\n\t        delete this.hashList[path];\n\t    },\n        /**\n         * 重新加载页面\n         */\n        reload:function() {\n        \tvar self = this;\n\t        var hash = window.location.hash.replace('#', '');\n\t        var addr = hash.split('/')[0];\n\t        var cb =   self.getCb(addr, self.hashList);\n\t        if(cb != false) {\n\t            var arr = hash.split('/');\n\t            arr.shift();\n\t            cb.apply(self, arr);\n\t        } else {\n\t            self.index && self.go(self.index);\n\t        }\n        },\n\n     \t/**\n\t     * 设置主页地址\n\t     * @param index: 主页地址\n\t     */\n\t    setIndex: function(index) {\n\t        this.index = index;\n\t    },\n\t    \n\t     /**\n\t     * 获取callback\n\t     * @return false or callback\n\t     */\n\t    getCb: function(addr, hashList) {\n\t        for(var key in hashList) {\n\t            if(key == addr) {\n\t                return hashList[key]\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    \n\t    /**\n         * 初始化路由\n         */\n        init: function (options) {\n        \tvar self = this;\n        \twindow.onhashchange = function() {\n\t            self.reload();\n\t        };\n        },\n        start: function() {\n        \tthis.reload();\n        }\n    };\n\n\treturn Router;\n    \n}));\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n\n</script>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>router2</title>\n</head>\n\n<body>\n\t<a href=\"#index\">首页</a>\n    <a href=\"#detail/1654499\">详情页</a>\n</body>\n\n<script type=\"text/javascript\">\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\n    var Router = {\n    \t\n        /**\n         * 注册的所有路由对象\n         */\n        hashList: {},\n \t\t\n \t\t/**\n \t\t * 当前路由\n \t\t */\n        index: null,\n   \n\n        /**\n         * Add router\n         * 注册路由对象\n \t\t**/\n        add: function (path,callback) {\n        \t\n            this.hashList[path] = callback;\n        },\n        \n        /**\n         * 跳转到指定路由\n         */\n        go: function(path) {\n        \t\n        \twindow.location.hash = '#' + path;\n        },\n        \n        /**\n         * 删除路由\n         */\n        remove: function(path) {\t \n        \t\n\t        delete this.hashList[path];\n\t    },\n        /**\n         * 重新加载页面\n         */\n        reload:function() {\n        \tvar self = this;\n\t        var hash = window.location.hash.replace('#', '');\n\t        var addr = hash.split('/')[0];\n\t        var cb =   self.getCb(addr, self.hashList);\n\t        if(cb != false) {\n\t            var arr = hash.split('/');\n\t            arr.shift();\n\t            cb.apply(self, arr);\n\t        } else {\n\t            self.index && self.go(self.index);\n\t        }\n        },\n\n     \t/**\n\t     * 设置主页地址\n\t     * @param index: 主页地址\n\t     */\n\t    setIndex: function(index) {\n\t        this.index = index;\n\t    },\n\t    \n\t     /**\n\t     * 获取callback\n\t     * @return false or callback\n\t     */\n\t    getCb: function(addr, hashList) {\n\t        for(var key in hashList) {\n\t            if(key == addr) {\n\t                return hashList[key]\n\t            }\n\t        }\n\t        return false;\n\t    },\n\t    \n\t    /**\n         * 初始化路由\n         */\n        init: function (options) {\n        \tvar self = this;\n        \twindow.onhashchange = function() {\n\t            self.reload();\n\t        };\n        },\n        start: function() {\n        \tthis.reload();\n        }\n    };\n\n\treturn Router;\n    \n}));\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n\n</script>\n</html>\n"}],"Post":[{"title":"cookie小结","date":"2017-03-12T04:18:00.000Z","_content":"\n> 　　前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚.\n　　2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。\n　　本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。\n\n<!--more-->\n\n## 什么是cookie　     \n　　官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。\n　　再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。\n![](http://images2015.cnblogs.com/blog/776370/201702/776370-20170227220454188-452465694.jpg)\n\n## cookie的作用　\n　　HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。　　 \n　　　　\n## cookie的属性 \n我们先来看一张图：\n![](http://images2015.cnblogs.com/blog/776370/201702/776370-20170227233400204-472517564.png)\n　　在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性\n　　如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解\n`Name：`\n该Cookie的名称，一旦创建，名称便不可更改\n`value: `\n该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码\n`domain：`\n可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”\n**这个domain稍作解释：**\n　　非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。\n　　顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。\n　　二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。\n顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。\n`Path:`\n　　path字段为可以访问此cookie的页面路径。 比如domain是abc.com,  path是/detail，那么只有/detail 路径下的页面可以读取此cookie。 \n`Expires/Max-Age: `\n　　该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。\n　　 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie.\n　　 如果为0，表示删除Cookie。默认是-1\n`Size:`\ncookie的大小\n`http： `\n　　 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。\n比如截图中的__jsluid\n`secure：`\n  设置是否只能通过https来传递此条cookie\n\n## cookie的特性\n1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie\n2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同\n3、Cookie的不可跨域名性。\n　　例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。\n\n## cookie的分类 \ncookie有两种类型：\n* 临时Cookie（会话Cookie）\n* 永久Cookie\n　　不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore\n　　设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。\n　　存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore\n\n## cookie的操作\n**1、 cookie的发送：**\n　　服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：\n```\n·Set-Cookie: \"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure\"\n```\n其中`name=value`是必选项，其它都是可选项。\n![](https://segmentfault.com/img/bVthn4?_=6476991)\n　　客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍\n\n**2、cookie的读取** \n　这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：\n```javascript\nfunction getCookie(name){\n    var cookieName=encodeURIComponent(name)+\"=\",\n    cookieStart=document.cookie.indexOf(cookieName),\n    cookieValue=null;\n    if(cookieStart>-1){\n        var cookieEnd=document.cookie.indexOf(\";\",cookieStart);\n        if(cookieEnd==-1){\n            cookieEnd=document.cookie.Length;\n        }\n        cookieValue=decodeURIComponent(document.cookie.substring(cookieStart+document.cookie.length,cookieEnd));\n    }\n    return cookieValue;\n}\n```\n** 3、cookie的修改与删除 **\n　　Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n　　如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。\n\n## Cookie的实现原理\n 　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示：\n![](http://hi.csdn.net/attachment/201111/9/0_13208318702UfF.gif)\n\n这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：\n（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。 \n（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。 \n（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。\n（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。\n（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。\n\n## Cookie的安全问题 \n　　通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。\n\n**如何来防范cookie的安全呢？有以下几种方法：**\n* HttpOnly属性\n　　 如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。\n* secure属性\n　　当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。\n　　我们再来看看一道经典的面试题：\n`登录时候用cookie的话，安全性问题怎么解决？`\n这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的）\n> \n第1种是：\n把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。\n密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥\n当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。\n这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担\n\n> 第2种是：\n将用户的认证信息保存在一个cookie中，具体如下： \n1. cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 \n2. cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)\n这样子设计有以下几个优点： \n1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。 \n2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。 \n3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。 \n4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。\n\n## cookie跨地址，跨域问题以及解决方案\n　　cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料，\n　　在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。\n　　总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。\n　　前2种具体的实现方法可以点击看这里:[点我](http://www.cnblogs.com/hujunzheng/p/5744755.html)\n**1、nginx方向代理：**\n　　反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。\n　　反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。\n**2、jsonp方法：**\n　　这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，[点我](http://developer.51cto.com/art/201104/255729.htm)　\n**3、nodejs的superagent**\n**4、iframe方法：**\n比如有个`www.a.com/index.html`的页面，往`www.b.com/index.html`的页面传递cookie\n`www.a.com/index.html`这样写：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>我是a页面</title>\n</head>\n<body>\n    \n</body>\n<script type=\"text/javascript\">\ndocument.cookie = \"name=\" + \"value;\" + \"expires=\" + \"datatime;\" + \"domain=\" + \"\" + \"path=\" + \"/path\" + \"; secure\";\n//name Cookie名字\n//value Cookie值\n//expires 有效期截至(单位毫秒)\n//path 子目录\n//domain 有效域\n//secure 是否安全\nwindow.location = \"http://www.b.com/index.html?\" + document.cookie;  //跳转到b页面\n</script>\n</html>\n```\nwww.b.com/index.html 这样写：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>我是b页面</title>\n</head>\n<body>\n   <iframe src='http://www.a.com/index.html' width='100' height='100' style=\"display:none\"></iframe>\n</body>\n<script type=\"text/javascript\">\nvar url = window.location.toString();//获取地址\nvar get = url.substring(url.indexOf(\"abc\"));//获取变量和变量值\nvar idx = get.indexOf(\"=\");//获取变量名长度\nif (idx != -1) {\n   var name = get.substring(0, idx);//获取变量名\n   var val = get.substring(idx + 1);//获取变量值\n   setCookie(name, val, 1);//创建Cookie\n}\n</script>\n</html>\n``` \n\n\n\n备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出\n\n \n\n\n\n","source":"_posts/cookie小结.md","raw":"---\ntitle: cookie小结\ndate: 2017-03-12 12:18\ncategories:\ntags: [博客园迁移,cookie]\n---\n\n> 　　前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚.\n　　2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。\n　　本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。\n\n<!--more-->\n\n## 什么是cookie　     \n　　官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。\n　　再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。\n![](http://images2015.cnblogs.com/blog/776370/201702/776370-20170227220454188-452465694.jpg)\n\n## cookie的作用　\n　　HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。　　 \n　　　　\n## cookie的属性 \n我们先来看一张图：\n![](http://images2015.cnblogs.com/blog/776370/201702/776370-20170227233400204-472517564.png)\n　　在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性\n　　如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解\n`Name：`\n该Cookie的名称，一旦创建，名称便不可更改\n`value: `\n该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码\n`domain：`\n可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”\n**这个domain稍作解释：**\n　　非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。\n　　顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。\n　　二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。\n顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。\n`Path:`\n　　path字段为可以访问此cookie的页面路径。 比如domain是abc.com,  path是/detail，那么只有/detail 路径下的页面可以读取此cookie。 \n`Expires/Max-Age: `\n　　该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。\n　　 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie.\n　　 如果为0，表示删除Cookie。默认是-1\n`Size:`\ncookie的大小\n`http： `\n　　 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。\n比如截图中的__jsluid\n`secure：`\n  设置是否只能通过https来传递此条cookie\n\n## cookie的特性\n1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie\n2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同\n3、Cookie的不可跨域名性。\n　　例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。\n\n## cookie的分类 \ncookie有两种类型：\n* 临时Cookie（会话Cookie）\n* 永久Cookie\n　　不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore\n　　设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。\n　　存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore\n\n## cookie的操作\n**1、 cookie的发送：**\n　　服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：\n```\n·Set-Cookie: \"name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure\"\n```\n其中`name=value`是必选项，其它都是可选项。\n![](https://segmentfault.com/img/bVthn4?_=6476991)\n　　客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍\n\n**2、cookie的读取** \n　这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：\n```javascript\nfunction getCookie(name){\n    var cookieName=encodeURIComponent(name)+\"=\",\n    cookieStart=document.cookie.indexOf(cookieName),\n    cookieValue=null;\n    if(cookieStart>-1){\n        var cookieEnd=document.cookie.indexOf(\";\",cookieStart);\n        if(cookieEnd==-1){\n            cookieEnd=document.cookie.Length;\n        }\n        cookieValue=decodeURIComponent(document.cookie.substring(cookieStart+document.cookie.length,cookieEnd));\n    }\n    return cookieValue;\n}\n```\n** 3、cookie的修改与删除 **\n　　Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。\n　　如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。\n\n## Cookie的实现原理\n 　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示：\n![](http://hi.csdn.net/attachment/201111/9/0_13208318702UfF.gif)\n\n这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：\n（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。 \n（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。 \n（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。\n（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。\n（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。\n\n## Cookie的安全问题 \n　　通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。\n\n**如何来防范cookie的安全呢？有以下几种方法：**\n* HttpOnly属性\n　　 如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。\n* secure属性\n　　当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。\n　　我们再来看看一道经典的面试题：\n`登录时候用cookie的话，安全性问题怎么解决？`\n这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的）\n> \n第1种是：\n把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。\n密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥\n当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。\n这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担\n\n> 第2种是：\n将用户的认证信息保存在一个cookie中，具体如下： \n1. cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 \n2. cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)\n这样子设计有以下几个优点： \n1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。 \n2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。 \n3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。 \n4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。\n\n## cookie跨地址，跨域问题以及解决方案\n　　cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料，\n　　在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。\n　　总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。\n　　前2种具体的实现方法可以点击看这里:[点我](http://www.cnblogs.com/hujunzheng/p/5744755.html)\n**1、nginx方向代理：**\n　　反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。\n　　反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。\n**2、jsonp方法：**\n　　这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，[点我](http://developer.51cto.com/art/201104/255729.htm)　\n**3、nodejs的superagent**\n**4、iframe方法：**\n比如有个`www.a.com/index.html`的页面，往`www.b.com/index.html`的页面传递cookie\n`www.a.com/index.html`这样写：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>我是a页面</title>\n</head>\n<body>\n    \n</body>\n<script type=\"text/javascript\">\ndocument.cookie = \"name=\" + \"value;\" + \"expires=\" + \"datatime;\" + \"domain=\" + \"\" + \"path=\" + \"/path\" + \"; secure\";\n//name Cookie名字\n//value Cookie值\n//expires 有效期截至(单位毫秒)\n//path 子目录\n//domain 有效域\n//secure 是否安全\nwindow.location = \"http://www.b.com/index.html?\" + document.cookie;  //跳转到b页面\n</script>\n</html>\n```\nwww.b.com/index.html 这样写：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>我是b页面</title>\n</head>\n<body>\n   <iframe src='http://www.a.com/index.html' width='100' height='100' style=\"display:none\"></iframe>\n</body>\n<script type=\"text/javascript\">\nvar url = window.location.toString();//获取地址\nvar get = url.substring(url.indexOf(\"abc\"));//获取变量和变量值\nvar idx = get.indexOf(\"=\");//获取变量名长度\nif (idx != -1) {\n   var name = get.substring(0, idx);//获取变量名\n   var val = get.substring(idx + 1);//获取变量值\n   setCookie(name, val, 1);//创建Cookie\n}\n</script>\n</html>\n``` \n\n\n\n备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出\n\n \n\n\n\n","slug":"cookie小结","published":1,"updated":"2017-04-09T15:49:54.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr3n00009gsc593vfjq9","content":"<blockquote>\n<p>　　前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚.<br>　　2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。<br>　　本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"什么是cookie\"><a href=\"#什么是cookie\" class=\"headerlink\" title=\"什么是cookie　\"></a>什么是cookie　</h2><p>　　官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。<br>　　再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。<br><img src=\"http://images2015.cnblogs.com/blog/776370/201702/776370-20170227220454188-452465694.jpg\" alt=\"\"></p>\n<h2 id=\"cookie的作用\"><a href=\"#cookie的作用\" class=\"headerlink\" title=\"cookie的作用　\"></a>cookie的作用　</h2><p>　　HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。　　 \n　　　　</p>\n<h2 id=\"cookie的属性\"><a href=\"#cookie的属性\" class=\"headerlink\" title=\"cookie的属性\"></a>cookie的属性</h2><p>我们先来看一张图：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201702/776370-20170227233400204-472517564.png\" alt=\"\"><br>　　在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性<br>　　如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解<br><code>Name：</code><br>该Cookie的名称，一旦创建，名称便不可更改<br><code>value:</code><br>该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码<br><code>domain：</code><br>可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”<br><strong>这个domain稍作解释：</strong><br>　　非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。<br>　　顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。<br>　　二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。<br>顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。<br><code>Path:</code><br>　　path字段为可以访问此cookie的页面路径。 比如domain是abc.com,  path是/detail，那么只有/detail 路径下的页面可以读取此cookie。<br><code>Expires/Max-Age:</code><br>　　该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。<br>　　 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie.<br>　　 如果为0，表示删除Cookie。默认是-1<br><code>Size:</code><br>cookie的大小<br><code>http：</code><br>　　 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。<br>比如截图中的__jsluid<br><code>secure：</code><br>  设置是否只能通过https来传递此条cookie</p>\n<h2 id=\"cookie的特性\"><a href=\"#cookie的特性\" class=\"headerlink\" title=\"cookie的特性\"></a>cookie的特性</h2><p>1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie<br>2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同<br>3、Cookie的不可跨域名性。<br>　　例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。</p>\n<h2 id=\"cookie的分类\"><a href=\"#cookie的分类\" class=\"headerlink\" title=\"cookie的分类\"></a>cookie的分类</h2><p>cookie有两种类型：</p>\n<ul>\n<li>临时Cookie（会话Cookie）</li>\n<li>永久Cookie<br>　　不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore<br>　　设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。<br>　　存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore</li>\n</ul>\n<h2 id=\"cookie的操作\"><a href=\"#cookie的操作\" class=\"headerlink\" title=\"cookie的操作\"></a>cookie的操作</h2><p><strong>1、 cookie的发送：</strong><br>　　服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">·Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;</div></pre></td></tr></table></figure></p>\n<p>其中<code>name=value</code>是必选项，其它都是可选项。<br><img src=\"https://segmentfault.com/img/bVthn4?_=6476991\" alt=\"\"><br>　　客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍</p>\n<p><strong>2、cookie的读取</strong><br>　这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCookie</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> cookieName=<span class=\"built_in\">encodeURIComponent</span>(name)+<span class=\"string\">\"=\"</span>,</div><div class=\"line\">    cookieStart=<span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</div><div class=\"line\">    cookieValue=<span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cookieStart&gt;<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> cookieEnd=<span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">\";\"</span>,cookieStart);</div><div class=\"line\">        <span class=\"keyword\">if</span>(cookieEnd==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">            cookieEnd=<span class=\"built_in\">document</span>.cookie.Length;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cookieValue=<span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">document</span>.cookie.substring(cookieStart+<span class=\"built_in\">document</span>.cookie.length,cookieEnd));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong> 3、cookie的修改与删除 </strong><br>　　Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。<br>　　如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。</p>\n<h2 id=\"Cookie的实现原理\"><a href=\"#Cookie的实现原理\" class=\"headerlink\" title=\"Cookie的实现原理\"></a>Cookie的实现原理</h2><p> 　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示：<br><img src=\"http://hi.csdn.net/attachment/201111/9/0_13208318702UfF.gif\" alt=\"\"></p>\n<p>这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：<br>（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。<br>（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。<br>（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。<br>（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。<br>（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。</p>\n<h2 id=\"Cookie的安全问题\"><a href=\"#Cookie的安全问题\" class=\"headerlink\" title=\"Cookie的安全问题\"></a>Cookie的安全问题</h2><p>　　通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。</p>\n<p><strong>如何来防范cookie的安全呢？有以下几种方法：</strong></p>\n<ul>\n<li>HttpOnly属性<br>　　 如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</li>\n<li>secure属性<br>　　当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。<br>　　我们再来看看一道经典的面试题：<br><code>登录时候用cookie的话，安全性问题怎么解决？</code><br>这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的）<blockquote>\n<p>第1种是：<br>把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。<br>密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥<br>当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。<br>这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>第2种是：<br>将用户的认证信息保存在一个cookie中，具体如下： </p>\n<ol>\n<li>cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 </li>\n<li>cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)<br>这样子设计有以下几个优点：<br>1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。<br>2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。<br>3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。<br>4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。</li>\n</ol>\n</blockquote>\n<h2 id=\"cookie跨地址，跨域问题以及解决方案\"><a href=\"#cookie跨地址，跨域问题以及解决方案\" class=\"headerlink\" title=\"cookie跨地址，跨域问题以及解决方案\"></a>cookie跨地址，跨域问题以及解决方案</h2><p>　　cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料，<br>　　在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。<br>　　总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。<br>　　前2种具体的实现方法可以点击看这里:<a href=\"http://www.cnblogs.com/hujunzheng/p/5744755.html\" target=\"_blank\" rel=\"external\">点我</a><br><strong>1、nginx方向代理：</strong><br>　　反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>　　反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。<br><strong>2、jsonp方法：</strong><br>　　这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，<a href=\"http://developer.51cto.com/art/201104/255729.htm\" target=\"_blank\" rel=\"external\">点我</a>　<br><strong>3、nodejs的superagent</strong><br><strong>4、iframe方法：</strong><br>比如有个<code>www.a.com/index.html</code>的页面，往<code>www.b.com/index.html</code>的页面传递cookie<br><code>www.a.com/index.html</code>这样写：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我是a页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"name=\"</span> + <span class=\"string\">\"value;\"</span> + <span class=\"string\">\"expires=\"</span> + <span class=\"string\">\"datatime;\"</span> + <span class=\"string\">\"domain=\"</span> + <span class=\"string\">\"\"</span> + <span class=\"string\">\"path=\"</span> + <span class=\"string\">\"/path\"</span> + <span class=\"string\">\"; secure\"</span>;</div><div class=\"line\"><span class=\"comment\">//name Cookie名字</span></div><div class=\"line\"><span class=\"comment\">//value Cookie值</span></div><div class=\"line\"><span class=\"comment\">//expires 有效期截至(单位毫秒)</span></div><div class=\"line\"><span class=\"comment\">//path 子目录</span></div><div class=\"line\"><span class=\"comment\">//domain 有效域</span></div><div class=\"line\"><span class=\"comment\">//secure 是否安全</span></div><div class=\"line\"><span class=\"built_in\">window</span>.location = <span class=\"string\">\"http://www.b.com/index.html?\"</span> + <span class=\"built_in\">document</span>.cookie;  <span class=\"comment\">//跳转到b页面</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>www.b.com/index.html 这样写：</p>\n<pre><code class=\"html\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我是b页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">'http://www.a.com/index.html'</span> <span class=\"attr\">width</span>=<span class=\"string\">'100'</span> <span class=\"attr\">height</span>=<span class=\"string\">'100'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\">\n<span class=\"keyword\">var</span> url = <span class=\"built_in\">window</span>.location.toString();<span class=\"comment\">//获取地址</span>\n<span class=\"keyword\">var</span> get = url.substring(url.indexOf(<span class=\"string\">\"abc\"</span>));<span class=\"comment\">//获取变量和变量值</span>\n<span class=\"keyword\">var</span> idx = get.indexOf(<span class=\"string\">\"=\"</span>);<span class=\"comment\">//获取变量名长度</span>\n<span class=\"keyword\">if</span> (idx != <span class=\"number\">-1</span>) {\n   <span class=\"keyword\">var</span> name = get.substring(<span class=\"number\">0</span>, idx);<span class=\"comment\">//获取变量名</span>\n   <span class=\"keyword\">var</span> val = get.substring(idx + <span class=\"number\">1</span>);<span class=\"comment\">//获取变量值</span>\n   setCookie(name, val, <span class=\"number\">1</span>);<span class=\"comment\">//创建Cookie</span>\n}\n</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span>\n</code></pre>\n<p>备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>　　前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚.<br>　　2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。<br>　　本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。</p>\n</blockquote>","more":"<h2 id=\"什么是cookie\"><a href=\"#什么是cookie\" class=\"headerlink\" title=\"什么是cookie　\"></a>什么是cookie　</h2><p>　　官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。<br>　　再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。<br><img src=\"http://images2015.cnblogs.com/blog/776370/201702/776370-20170227220454188-452465694.jpg\" alt=\"\"></p>\n<h2 id=\"cookie的作用\"><a href=\"#cookie的作用\" class=\"headerlink\" title=\"cookie的作用　\"></a>cookie的作用　</h2><p>　　HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。　　 \n　　　　</p>\n<h2 id=\"cookie的属性\"><a href=\"#cookie的属性\" class=\"headerlink\" title=\"cookie的属性\"></a>cookie的属性</h2><p>我们先来看一张图：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201702/776370-20170227233400204-472517564.png\" alt=\"\"><br>　　在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性<br>　　如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解<br><code>Name：</code><br>该Cookie的名称，一旦创建，名称便不可更改<br><code>value:</code><br>该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码<br><code>domain：</code><br>可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”<br><strong>这个domain稍作解释：</strong><br>　　非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。<br>　　顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。<br>　　二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。<br>顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。<br><code>Path:</code><br>　　path字段为可以访问此cookie的页面路径。 比如domain是abc.com,  path是/detail，那么只有/detail 路径下的页面可以读取此cookie。<br><code>Expires/Max-Age:</code><br>　　该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。<br>　　 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie.<br>　　 如果为0，表示删除Cookie。默认是-1<br><code>Size:</code><br>cookie的大小<br><code>http：</code><br>　　 cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。<br>比如截图中的__jsluid<br><code>secure：</code><br>  设置是否只能通过https来传递此条cookie</p>\n<h2 id=\"cookie的特性\"><a href=\"#cookie的特性\" class=\"headerlink\" title=\"cookie的特性\"></a>cookie的特性</h2><p>1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie<br>2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同<br>3、Cookie的不可跨域名性。<br>　　例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。</p>\n<h2 id=\"cookie的分类\"><a href=\"#cookie的分类\" class=\"headerlink\" title=\"cookie的分类\"></a>cookie的分类</h2><p>cookie有两种类型：</p>\n<ul>\n<li>临时Cookie（会话Cookie）</li>\n<li>永久Cookie<br>　　不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore<br>　　设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。<br>　　存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore</li>\n</ul>\n<h2 id=\"cookie的操作\"><a href=\"#cookie的操作\" class=\"headerlink\" title=\"cookie的操作\"></a>cookie的操作</h2><p><strong>1、 cookie的发送：</strong><br>　　服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">·Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot;</div></pre></td></tr></table></figure></p>\n<p>其中<code>name=value</code>是必选项，其它都是可选项。<br><img src=\"https://segmentfault.com/img/bVthn4?_=6476991\" alt=\"\"><br>　　客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍</p>\n<p><strong>2、cookie的读取</strong><br>　这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCookie</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> cookieName=<span class=\"built_in\">encodeURIComponent</span>(name)+<span class=\"string\">\"=\"</span>,</div><div class=\"line\">    cookieStart=<span class=\"built_in\">document</span>.cookie.indexOf(cookieName),</div><div class=\"line\">    cookieValue=<span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span>(cookieStart&gt;<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> cookieEnd=<span class=\"built_in\">document</span>.cookie.indexOf(<span class=\"string\">\";\"</span>,cookieStart);</div><div class=\"line\">        <span class=\"keyword\">if</span>(cookieEnd==<span class=\"number\">-1</span>)&#123;</div><div class=\"line\">            cookieEnd=<span class=\"built_in\">document</span>.cookie.Length;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cookieValue=<span class=\"built_in\">decodeURIComponent</span>(<span class=\"built_in\">document</span>.cookie.substring(cookieStart+<span class=\"built_in\">document</span>.cookie.length,cookieEnd));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> cookieValue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong> 3、cookie的修改与删除 </strong><br>　　Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。<br>　　如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。</p>\n<h2 id=\"Cookie的实现原理\"><a href=\"#Cookie的实现原理\" class=\"headerlink\" title=\"Cookie的实现原理\"></a>Cookie的实现原理</h2><p> 　　Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示：<br><img src=\"http://hi.csdn.net/attachment/201111/9/0_13208318702UfF.gif\" alt=\"\"></p>\n<p>这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：<br>（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。<br>（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。<br>（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。<br>（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。<br>（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。</p>\n<h2 id=\"Cookie的安全问题\"><a href=\"#Cookie的安全问题\" class=\"headerlink\" title=\"Cookie的安全问题\"></a>Cookie的安全问题</h2><p>　　通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。</p>\n<p><strong>如何来防范cookie的安全呢？有以下几种方法：</strong></p>\n<ul>\n<li>HttpOnly属性<br>　　 如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</li>\n<li>secure属性<br>　　当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。<br>　　我们再来看看一道经典的面试题：<br><code>登录时候用cookie的话，安全性问题怎么解决？</code><br>这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的）<blockquote>\n<p>第1种是：<br>把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。<br>密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥<br>当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。<br>这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>第2种是：<br>将用户的认证信息保存在一个cookie中，具体如下： </p>\n<ol>\n<li>cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 </li>\n<li>cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)<br>这样子设计有以下几个优点：<br>1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。<br>2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。<br>3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。<br>4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。</li>\n</ol>\n</blockquote>\n<h2 id=\"cookie跨地址，跨域问题以及解决方案\"><a href=\"#cookie跨地址，跨域问题以及解决方案\" class=\"headerlink\" title=\"cookie跨地址，跨域问题以及解决方案\"></a>cookie跨地址，跨域问题以及解决方案</h2><p>　　cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料，<br>　　在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。<br>　　总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。<br>　　前2种具体的实现方法可以点击看这里:<a href=\"http://www.cnblogs.com/hujunzheng/p/5744755.html\">点我</a><br><strong>1、nginx方向代理：</strong><br>　　反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>　　反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。<br><strong>2、jsonp方法：</strong><br>　　这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，<a href=\"http://developer.51cto.com/art/201104/255729.htm\">点我</a>　<br><strong>3、nodejs的superagent</strong><br><strong>4、iframe方法：</strong><br>比如有个<code>www.a.com/index.html</code>的页面，往<code>www.b.com/index.html</code>的页面传递cookie<br><code>www.a.com/index.html</code>这样写：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我是a页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">\"name=\"</span> + <span class=\"string\">\"value;\"</span> + <span class=\"string\">\"expires=\"</span> + <span class=\"string\">\"datatime;\"</span> + <span class=\"string\">\"domain=\"</span> + <span class=\"string\">\"\"</span> + <span class=\"string\">\"path=\"</span> + <span class=\"string\">\"/path\"</span> + <span class=\"string\">\"; secure\"</span>;</div><div class=\"line\"><span class=\"comment\">//name Cookie名字</span></div><div class=\"line\"><span class=\"comment\">//value Cookie值</span></div><div class=\"line\"><span class=\"comment\">//expires 有效期截至(单位毫秒)</span></div><div class=\"line\"><span class=\"comment\">//path 子目录</span></div><div class=\"line\"><span class=\"comment\">//domain 有效域</span></div><div class=\"line\"><span class=\"comment\">//secure 是否安全</span></div><div class=\"line\"><span class=\"built_in\">window</span>.location = <span class=\"string\">\"http://www.b.com/index.html?\"</span> + <span class=\"built_in\">document</span>.cookie;  <span class=\"comment\">//跳转到b页面</span></div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>www.b.com/index.html 这样写：</p>\n<pre><code class=\"html\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>我是b页面<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">'http://www.a.com/index.html'</span> <span class=\"attr\">width</span>=<span class=\"string\">'100'</span> <span class=\"attr\">height</span>=<span class=\"string\">'100'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\">\n<span class=\"keyword\">var</span> url = <span class=\"built_in\">window</span>.location.toString();<span class=\"comment\">//获取地址</span>\n<span class=\"keyword\">var</span> get = url.substring(url.indexOf(<span class=\"string\">\"abc\"</span>));<span class=\"comment\">//获取变量和变量值</span>\n<span class=\"keyword\">var</span> idx = get.indexOf(<span class=\"string\">\"=\"</span>);<span class=\"comment\">//获取变量名长度</span>\n<span class=\"keyword\">if</span> (idx != <span class=\"number\">-1</span>) {\n   <span class=\"keyword\">var</span> name = get.substring(<span class=\"number\">0</span>, idx);<span class=\"comment\">//获取变量名</span>\n   <span class=\"keyword\">var</span> val = get.substring(idx + <span class=\"number\">1</span>);<span class=\"comment\">//获取变量值</span>\n   setCookie(name, val, <span class=\"number\">1</span>);<span class=\"comment\">//创建Cookie</span>\n}\n</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span>\n</code></pre>\n<p>备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出</p>"},{"title":"最近的思考","date":"2017-07-09T07:38:00.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp;最近比较迷茫，所以想静下来分析分析最近自己心态的变化，以及职业规划以及接下啦的学习计划\n\n* 迷茫1： 现在在网易大部分做的工作感觉没什么技术含量，都是一些运营类的东西，没有参与到阴阳师藏宝阁的项目\n* 迷茫2： 同事还是挺厉害的，感觉差距还是挺大的，但是不知道怎么追赶\n* 迷茫3： 不知道该学什么东西，学习进入迷茫期和瓶颈期，如何提升自己的能力\n* 迷茫4： 对于职业规划，对于以后想走的路还没想好，是继续技术呢，还是走管理，或者是转行其他的，这点没想好\n* 迷茫5： 现在只是在学习一些技术，没有提高自己其他相应的能力，比如沟通，管理，产品思维等等\n\n解决办法：\n** 迷茫1： **\n    如果没有啥技术含量，那么就把业务代码写好，可以换换其他写法，没有必要一直都是用一种或者啥的。\n没有参与到阴阳师藏宝阁的项目，那么可以自己私底下弄一个，包括搭环境啊什么的，全部自己弄一遍，这样才能学的更多\n\n** 迷茫2： **\n   人家厉害那是因为人家工作的年限比你久，人家比你早工作两三年呢，这是很正常的。放平心态，多跟他们学习，怎么学习呢，比如他们会的，自己不会的，就赶紧补上，\n而且有人比你厉害，是好事呢。第一要放平心态，虚心学习，第二列好目标，缺啥补啥\n\n** 迷茫3： **\n其实还是很多可以学的，比如\n1. mock的使用，自己看看文档，总结一篇博客\n2. webpack2,gulp的使用，已经很久没有搭过环境了，可以再看看文档，怎么搭呢，我不是要用vue自己写一个阴阳师藏宝阁吗？那就以这个项目来搞，从零开始搞起，加上mock\n3. 我的node.js的博客还没搞完呢，啥时候开始启动，等阴阳师藏宝阁vue的搞完，后面就开始设计我自己的网站，后面的学习都是围绕这个网站进行下去。\n4. 对于看技术书籍，有空就看看嘛，没空就先不看\n\n** 迷茫4： **\n** 迷茫5： **\n\n &ensp;对于职业规划，迷茫4和迷茫5其实是差不多的，可以这么理解，有意识的去培养自己其他方面的能力，现在公司有那么多的人给你去学习，培养自己的全局观，不要局限于前端上面，视野太小了，所以有时候应该从前端这里走出来，了解一下产品，了解一下交互，设计，用户体验，淘宝客等，不要一直局限于前端，有时候可以跳出来看看外面的世界，或许你会发觉外面的世界很精彩。\n\n &ensp;对于职业规划，可能不会一直从事技术，但是前提是先把技术学好，可能会从事淘宝客啊，梦想是自创一个麻辣烫品牌，所以啊，除了技术之于，多积累一下其他方面的东西，包括各种产品什么的能力，先靠技术赚钱，因为也比较喜欢技术，然后可能转行啊，做管理啊，做产品啊，售前啊什么的，所以，趁年轻，好好学习自己的人脉，交际，谈判，沟通等能力。\n\n &ensp;最后，想对自己说，放平心态，积极的过好每一天的生活，积极面对每一天，不要每天都愁眉苦脸啊什么的，放开一点，不用那么拘谨的，学习如何和领导说话，这点也是自己一直欠缺的，记住，是一直，所以要改了，多多交流，有空停下来跟自己对对话，聊聊天，安慰一下自己的内心。\n","source":"_drafts/最近的规划.md","raw":"---\ntitle: 最近的思考\ndate: 2017-07-09 15:38\ncategories:\ntags:\n     - js\n     - 高阶函数\n---\n\n&ensp;&ensp;&ensp;&ensp;最近比较迷茫，所以想静下来分析分析最近自己心态的变化，以及职业规划以及接下啦的学习计划\n\n* 迷茫1： 现在在网易大部分做的工作感觉没什么技术含量，都是一些运营类的东西，没有参与到阴阳师藏宝阁的项目\n* 迷茫2： 同事还是挺厉害的，感觉差距还是挺大的，但是不知道怎么追赶\n* 迷茫3： 不知道该学什么东西，学习进入迷茫期和瓶颈期，如何提升自己的能力\n* 迷茫4： 对于职业规划，对于以后想走的路还没想好，是继续技术呢，还是走管理，或者是转行其他的，这点没想好\n* 迷茫5： 现在只是在学习一些技术，没有提高自己其他相应的能力，比如沟通，管理，产品思维等等\n\n解决办法：\n** 迷茫1： **\n    如果没有啥技术含量，那么就把业务代码写好，可以换换其他写法，没有必要一直都是用一种或者啥的。\n没有参与到阴阳师藏宝阁的项目，那么可以自己私底下弄一个，包括搭环境啊什么的，全部自己弄一遍，这样才能学的更多\n\n** 迷茫2： **\n   人家厉害那是因为人家工作的年限比你久，人家比你早工作两三年呢，这是很正常的。放平心态，多跟他们学习，怎么学习呢，比如他们会的，自己不会的，就赶紧补上，\n而且有人比你厉害，是好事呢。第一要放平心态，虚心学习，第二列好目标，缺啥补啥\n\n** 迷茫3： **\n其实还是很多可以学的，比如\n1. mock的使用，自己看看文档，总结一篇博客\n2. webpack2,gulp的使用，已经很久没有搭过环境了，可以再看看文档，怎么搭呢，我不是要用vue自己写一个阴阳师藏宝阁吗？那就以这个项目来搞，从零开始搞起，加上mock\n3. 我的node.js的博客还没搞完呢，啥时候开始启动，等阴阳师藏宝阁vue的搞完，后面就开始设计我自己的网站，后面的学习都是围绕这个网站进行下去。\n4. 对于看技术书籍，有空就看看嘛，没空就先不看\n\n** 迷茫4： **\n** 迷茫5： **\n\n &ensp;对于职业规划，迷茫4和迷茫5其实是差不多的，可以这么理解，有意识的去培养自己其他方面的能力，现在公司有那么多的人给你去学习，培养自己的全局观，不要局限于前端上面，视野太小了，所以有时候应该从前端这里走出来，了解一下产品，了解一下交互，设计，用户体验，淘宝客等，不要一直局限于前端，有时候可以跳出来看看外面的世界，或许你会发觉外面的世界很精彩。\n\n &ensp;对于职业规划，可能不会一直从事技术，但是前提是先把技术学好，可能会从事淘宝客啊，梦想是自创一个麻辣烫品牌，所以啊，除了技术之于，多积累一下其他方面的东西，包括各种产品什么的能力，先靠技术赚钱，因为也比较喜欢技术，然后可能转行啊，做管理啊，做产品啊，售前啊什么的，所以，趁年轻，好好学习自己的人脉，交际，谈判，沟通等能力。\n\n &ensp;最后，想对自己说，放平心态，积极的过好每一天的生活，积极面对每一天，不要每天都愁眉苦脸啊什么的，放开一点，不用那么拘谨的，学习如何和领导说话，这点也是自己一直欠缺的，记住，是一直，所以要改了，多多交流，有空停下来跟自己对对话，聊聊天，安慰一下自己的内心。\n","slug":"最近的规划","published":0,"updated":"2017-07-10T15:55:44.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr4j00029gscs53ybbwd","content":"<p>&ensp;&ensp;&ensp;&ensp;最近比较迷茫，所以想静下来分析分析最近自己心态的变化，以及职业规划以及接下啦的学习计划</p>\n<ul>\n<li>迷茫1： 现在在网易大部分做的工作感觉没什么技术含量，都是一些运营类的东西，没有参与到阴阳师藏宝阁的项目</li>\n<li>迷茫2： 同事还是挺厉害的，感觉差距还是挺大的，但是不知道怎么追赶</li>\n<li>迷茫3： 不知道该学什么东西，学习进入迷茫期和瓶颈期，如何提升自己的能力</li>\n<li>迷茫4： 对于职业规划，对于以后想走的路还没想好，是继续技术呢，还是走管理，或者是转行其他的，这点没想好</li>\n<li>迷茫5： 现在只是在学习一些技术，没有提高自己其他相应的能力，比如沟通，管理，产品思维等等</li>\n</ul>\n<p>解决办法：<br><strong> 迷茫1： </strong><br>    如果没有啥技术含量，那么就把业务代码写好，可以换换其他写法，没有必要一直都是用一种或者啥的。<br>没有参与到阴阳师藏宝阁的项目，那么可以自己私底下弄一个，包括搭环境啊什么的，全部自己弄一遍，这样才能学的更多</p>\n<p><strong> 迷茫2： </strong><br>   人家厉害那是因为人家工作的年限比你久，人家比你早工作两三年呢，这是很正常的。放平心态，多跟他们学习，怎么学习呢，比如他们会的，自己不会的，就赶紧补上，<br>而且有人比你厉害，是好事呢。第一要放平心态，虚心学习，第二列好目标，缺啥补啥</p>\n<p><strong> 迷茫3： </strong><br>其实还是很多可以学的，比如</p>\n<ol>\n<li>mock的使用，自己看看文档，总结一篇博客</li>\n<li>webpack2,gulp的使用，已经很久没有搭过环境了，可以再看看文档，怎么搭呢，我不是要用vue自己写一个阴阳师藏宝阁吗？那就以这个项目来搞，从零开始搞起，加上mock</li>\n<li>我的node.js的博客还没搞完呢，啥时候开始启动，等阴阳师藏宝阁vue的搞完，后面就开始设计我自己的网站，后面的学习都是围绕这个网站进行下去。</li>\n<li>对于看技术书籍，有空就看看嘛，没空就先不看</li>\n</ol>\n<p><strong> 迷茫4： </strong><br><strong> 迷茫5： </strong></p>\n<p> &ensp;对于职业规划，迷茫4和迷茫5其实是差不多的，可以这么理解，有意识的去培养自己其他方面的能力，现在公司有那么多的人给你去学习，培养自己的全局观，不要局限于前端上面，视野太小了，所以有时候应该从前端这里走出来，了解一下产品，了解一下交互，设计，用户体验，淘宝客等，不要一直局限于前端，有时候可以跳出来看看外面的世界，或许你会发觉外面的世界很精彩。</p>\n<p> &ensp;对于职业规划，可能不会一直从事技术，但是前提是先把技术学好，可能会从事淘宝客啊，梦想是自创一个麻辣烫品牌，所以啊，除了技术之于，多积累一下其他方面的东西，包括各种产品什么的能力，先靠技术赚钱，因为也比较喜欢技术，然后可能转行啊，做管理啊，做产品啊，售前啊什么的，所以，趁年轻，好好学习自己的人脉，交际，谈判，沟通等能力。</p>\n<p> &ensp;最后，想对自己说，放平心态，积极的过好每一天的生活，积极面对每一天，不要每天都愁眉苦脸啊什么的，放开一点，不用那么拘谨的，学习如何和领导说话，这点也是自己一直欠缺的，记住，是一直，所以要改了，多多交流，有空停下来跟自己对对话，聊聊天，安慰一下自己的内心。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&ensp;&ensp;&ensp;&ensp;最近比较迷茫，所以想静下来分析分析最近自己心态的变化，以及职业规划以及接下啦的学习计划</p>\n<ul>\n<li>迷茫1： 现在在网易大部分做的工作感觉没什么技术含量，都是一些运营类的东西，没有参与到阴阳师藏宝阁的项目</li>\n<li>迷茫2： 同事还是挺厉害的，感觉差距还是挺大的，但是不知道怎么追赶</li>\n<li>迷茫3： 不知道该学什么东西，学习进入迷茫期和瓶颈期，如何提升自己的能力</li>\n<li>迷茫4： 对于职业规划，对于以后想走的路还没想好，是继续技术呢，还是走管理，或者是转行其他的，这点没想好</li>\n<li>迷茫5： 现在只是在学习一些技术，没有提高自己其他相应的能力，比如沟通，管理，产品思维等等</li>\n</ul>\n<p>解决办法：<br><strong> 迷茫1： </strong><br>    如果没有啥技术含量，那么就把业务代码写好，可以换换其他写法，没有必要一直都是用一种或者啥的。<br>没有参与到阴阳师藏宝阁的项目，那么可以自己私底下弄一个，包括搭环境啊什么的，全部自己弄一遍，这样才能学的更多</p>\n<p><strong> 迷茫2： </strong><br>   人家厉害那是因为人家工作的年限比你久，人家比你早工作两三年呢，这是很正常的。放平心态，多跟他们学习，怎么学习呢，比如他们会的，自己不会的，就赶紧补上，<br>而且有人比你厉害，是好事呢。第一要放平心态，虚心学习，第二列好目标，缺啥补啥</p>\n<p><strong> 迷茫3： </strong><br>其实还是很多可以学的，比如</p>\n<ol>\n<li>mock的使用，自己看看文档，总结一篇博客</li>\n<li>webpack2,gulp的使用，已经很久没有搭过环境了，可以再看看文档，怎么搭呢，我不是要用vue自己写一个阴阳师藏宝阁吗？那就以这个项目来搞，从零开始搞起，加上mock</li>\n<li>我的node.js的博客还没搞完呢，啥时候开始启动，等阴阳师藏宝阁vue的搞完，后面就开始设计我自己的网站，后面的学习都是围绕这个网站进行下去。</li>\n<li>对于看技术书籍，有空就看看嘛，没空就先不看</li>\n</ol>\n<p><strong> 迷茫4： </strong><br><strong> 迷茫5： </strong></p>\n<p> &ensp;对于职业规划，迷茫4和迷茫5其实是差不多的，可以这么理解，有意识的去培养自己其他方面的能力，现在公司有那么多的人给你去学习，培养自己的全局观，不要局限于前端上面，视野太小了，所以有时候应该从前端这里走出来，了解一下产品，了解一下交互，设计，用户体验，淘宝客等，不要一直局限于前端，有时候可以跳出来看看外面的世界，或许你会发觉外面的世界很精彩。</p>\n<p> &ensp;对于职业规划，可能不会一直从事技术，但是前提是先把技术学好，可能会从事淘宝客啊，梦想是自创一个麻辣烫品牌，所以啊，除了技术之于，多积累一下其他方面的东西，包括各种产品什么的能力，先靠技术赚钱，因为也比较喜欢技术，然后可能转行啊，做管理啊，做产品啊，售前啊什么的，所以，趁年轻，好好学习自己的人脉，交际，谈判，沟通等能力。</p>\n<p> &ensp;最后，想对自己说，放平心态，积极的过好每一天的生活，积极面对每一天，不要每天都愁眉苦脸啊什么的，放开一点，不用那么拘谨的，学习如何和领导说话，这点也是自己一直欠缺的，记住，是一直，所以要改了，多多交流，有空停下来跟自己对对话，聊聊天，安慰一下自己的内心。</p>\n"},{"title":"javascript高阶函数","date":"2017-07-03T02:38:00.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp;最近在看js设计模式相关的书籍，发觉很多模式都有用到高阶函数这个东东，发觉自己之前没有总结过这类文章，所以来个小小的总结。总结的篇幅有点少，纯属做做笔记\n\n<!--more-->\n\n## 1. 高阶函数的定义\n高阶函数（Higher Order Function）,按照维基百科上面的定义，至少满足下列一个条件的函数：\n* 1 函数作为参数传入\n* 2 返回值为一个函数\n\n只要满足上面两个条件中的其中一个，就属于高阶函数，我们下面用代码来更好的理解一下\n\n** 函数作为参数传入 **\n```javascript\nfunction add(a,b,fn){\n    return fn(a)+fn(b);\n}\nvar fn=function (a){\n  return a*a;\n}\nadd(2,3,fn); //13\n```\n** 函数作为返回值 **\n```javascript\nvar getSingle = function(fn) {\n    var ret;\n    return function() {\n        return ret || (ret = fn.apply(this, arguments));\n    };\n};\n```\n## 2. 函数柯里化\n为啥会在这里穿插函数柯里化呢，因为函数柯里化里面包含了很多的高阶函数，所以这里也一并总结总结\n\n** 定义 **\n\n&ensp;&ensp;柯里化（Currying），又称部分求值，一个currying的函数首先会接受一些参数，接受这些参数之后，函数**并不会立即求值**，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。\n&ensp;&ensp;比如有下面的场景：有个销售需要统计每天的销售额，待到月底的时候再统一计算该月的销售总额。\n用代码的形式如下：\n```javascript\nvar currying = function(fn) {\n    var args = [];\n    return function() {\n      if(arguments.length === 0) {\n        return fn.apply(this,args);\n      } else {\n          Array.prototype.push.apply(args,arguments);\n          return arguments.callee;\n      }\n    }\n}\nvar sell = function() {\n  var sum = 0;\n  for(var i = 0,len = arguments.length; i < len; i++) {\n    sum += arguments[i];\n  }\n  return sum;\n}\nvar sellAmount = currying(sell);\nsellAmount(100);\nsellAmount(200);\nsellAmount(300);\nconsole.log(sellAmount()); //600\n```\n上面的代码就是函数柯里化的一种形式，我传入了每天的销售额，并不会立即求值，而是等到月底，我需要统计总额的时候才一次性求值\n\n## 3. 高阶函数实战\n* 1.比较常用的一个地方,为一个元素添加事件;\n```javascript\nvar addEvent = function(elem, type, handler) {\n   if (window.addEventListener) {\n      addEvent = function(elem, type, handler) {\n        elem.addEventListener(type, handler, false);\n      }\n   } else if (window.attachEvent) {\n      addEvent = function(elem, type, handler) {\n        elem.attachEvent('on' + type, handler);\n      }\n  }\n  addEvent(elem, type, handler);\n};\n```\n* 2.函数节流\n比如在window.resize中，不想被频繁的触发事件，想每隔一定的间隔事件来触发\n```javascript\nfunction throttle(fn, interval) {\n  var doing = false;\n\n  return function() {\n    if (doing) {\n      return;\n    }\n    doing = true;\n    fn.apply(this, arguments);\n    setTimeout(function() {\n      doing = false;\n    }, interval);\n  }\n}\n\nwindow.onresize = throttle(function(){\n    console.log('execute');\n}, 500);\n```\n<br >\n&ensp;&ensp;&ensp;&ensp;高阶函数在设计模式中用的还是比较多的，也是比较有用的一个东西，所以掌握它是比较有必要性的。\n最近在看曾探写的《Javascript设计模式与开发实践》，非常不错，值得推荐\n\n\n\n参考资料:《Javascript设计模式与开发实践》\n","source":"_posts/javascript高阶函数.md","raw":"---\ntitle: javascript高阶函数\ndate: 2017-07-03 10:38\ncategories:\ntags:\n     - js\n     - 高阶函数\n---\n\n&ensp;&ensp;&ensp;&ensp;最近在看js设计模式相关的书籍，发觉很多模式都有用到高阶函数这个东东，发觉自己之前没有总结过这类文章，所以来个小小的总结。总结的篇幅有点少，纯属做做笔记\n\n<!--more-->\n\n## 1. 高阶函数的定义\n高阶函数（Higher Order Function）,按照维基百科上面的定义，至少满足下列一个条件的函数：\n* 1 函数作为参数传入\n* 2 返回值为一个函数\n\n只要满足上面两个条件中的其中一个，就属于高阶函数，我们下面用代码来更好的理解一下\n\n** 函数作为参数传入 **\n```javascript\nfunction add(a,b,fn){\n    return fn(a)+fn(b);\n}\nvar fn=function (a){\n  return a*a;\n}\nadd(2,3,fn); //13\n```\n** 函数作为返回值 **\n```javascript\nvar getSingle = function(fn) {\n    var ret;\n    return function() {\n        return ret || (ret = fn.apply(this, arguments));\n    };\n};\n```\n## 2. 函数柯里化\n为啥会在这里穿插函数柯里化呢，因为函数柯里化里面包含了很多的高阶函数，所以这里也一并总结总结\n\n** 定义 **\n\n&ensp;&ensp;柯里化（Currying），又称部分求值，一个currying的函数首先会接受一些参数，接受这些参数之后，函数**并不会立即求值**，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。\n&ensp;&ensp;比如有下面的场景：有个销售需要统计每天的销售额，待到月底的时候再统一计算该月的销售总额。\n用代码的形式如下：\n```javascript\nvar currying = function(fn) {\n    var args = [];\n    return function() {\n      if(arguments.length === 0) {\n        return fn.apply(this,args);\n      } else {\n          Array.prototype.push.apply(args,arguments);\n          return arguments.callee;\n      }\n    }\n}\nvar sell = function() {\n  var sum = 0;\n  for(var i = 0,len = arguments.length; i < len; i++) {\n    sum += arguments[i];\n  }\n  return sum;\n}\nvar sellAmount = currying(sell);\nsellAmount(100);\nsellAmount(200);\nsellAmount(300);\nconsole.log(sellAmount()); //600\n```\n上面的代码就是函数柯里化的一种形式，我传入了每天的销售额，并不会立即求值，而是等到月底，我需要统计总额的时候才一次性求值\n\n## 3. 高阶函数实战\n* 1.比较常用的一个地方,为一个元素添加事件;\n```javascript\nvar addEvent = function(elem, type, handler) {\n   if (window.addEventListener) {\n      addEvent = function(elem, type, handler) {\n        elem.addEventListener(type, handler, false);\n      }\n   } else if (window.attachEvent) {\n      addEvent = function(elem, type, handler) {\n        elem.attachEvent('on' + type, handler);\n      }\n  }\n  addEvent(elem, type, handler);\n};\n```\n* 2.函数节流\n比如在window.resize中，不想被频繁的触发事件，想每隔一定的间隔事件来触发\n```javascript\nfunction throttle(fn, interval) {\n  var doing = false;\n\n  return function() {\n    if (doing) {\n      return;\n    }\n    doing = true;\n    fn.apply(this, arguments);\n    setTimeout(function() {\n      doing = false;\n    }, interval);\n  }\n}\n\nwindow.onresize = throttle(function(){\n    console.log('execute');\n}, 500);\n```\n<br >\n&ensp;&ensp;&ensp;&ensp;高阶函数在设计模式中用的还是比较多的，也是比较有用的一个东西，所以掌握它是比较有必要性的。\n最近在看曾探写的《Javascript设计模式与开发实践》，非常不错，值得推荐\n\n\n\n参考资料:《Javascript设计模式与开发实践》\n","slug":"javascript高阶函数","published":1,"updated":"2017-07-09T03:51:59.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr5b00059gscxke46v1e","content":"<p>&ensp;&ensp;&ensp;&ensp;最近在看js设计模式相关的书籍，发觉很多模式都有用到高阶函数这个东东，发觉自己之前没有总结过这类文章，所以来个小小的总结。总结的篇幅有点少，纯属做做笔记</p>\n<a id=\"more\"></a>\n<h2 id=\"1-高阶函数的定义\"><a href=\"#1-高阶函数的定义\" class=\"headerlink\" title=\"1. 高阶函数的定义\"></a>1. 高阶函数的定义</h2><p>高阶函数（Higher Order Function）,按照维基百科上面的定义，至少满足下列一个条件的函数：</p>\n<ul>\n<li>1 函数作为参数传入</li>\n<li>2 返回值为一个函数</li>\n</ul>\n<p>只要满足上面两个条件中的其中一个，就属于高阶函数，我们下面用代码来更好的理解一下</p>\n<p><strong> 函数作为参数传入 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a,b,fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn(a)+fn(b);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> fn=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a*a;</div><div class=\"line\">&#125;</div><div class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">3</span>,fn); <span class=\"comment\">//13</span></div></pre></td></tr></table></figure></p>\n<p><strong> 函数作为返回值 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getSingle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ret;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ret || (ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-函数柯里化\"><a href=\"#2-函数柯里化\" class=\"headerlink\" title=\"2. 函数柯里化\"></a>2. 函数柯里化</h2><p>为啥会在这里穿插函数柯里化呢，因为函数柯里化里面包含了很多的高阶函数，所以这里也一并总结总结</p>\n<p><strong> 定义 </strong></p>\n<p>&ensp;&ensp;柯里化（Currying），又称部分求值，一个currying的函数首先会接受一些参数，接受这些参数之后，函数<strong>并不会立即求值</strong>，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。<br>&ensp;&ensp;比如有下面的场景：有个销售需要统计每天的销售额，待到月底的时候再统一计算该月的销售总额。<br>用代码的形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>,args);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">Array</span>.prototype.push.apply(args,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>.callee;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> sell = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    sum += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> sellAmount = currying(sell);</div><div class=\"line\">sellAmount(<span class=\"number\">100</span>);</div><div class=\"line\">sellAmount(<span class=\"number\">200</span>);</div><div class=\"line\">sellAmount(<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(sellAmount()); <span class=\"comment\">//600</span></div></pre></td></tr></table></figure></p>\n<p>上面的代码就是函数柯里化的一种形式，我传入了每天的销售额，并不会立即求值，而是等到月底，我需要统计总额的时候才一次性求值</p>\n<h2 id=\"3-高阶函数实战\"><a href=\"#3-高阶函数实战\" class=\"headerlink\" title=\"3. 高阶函数实战\"></a>3. 高阶函数实战</h2><ul>\n<li><p>1.比较常用的一个地方,为一个元素添加事件;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.addEventListener) &#123;</div><div class=\"line\">      addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">        elem.addEventListener(type, handler, <span class=\"literal\">false</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">      addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">        elem.attachEvent(<span class=\"string\">'on'</span> + type, handler);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  addEvent(elem, type, handler);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.函数节流<br>比如在window.resize中，不想被频繁的触发事件，想每隔一定的间隔事件来触发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, interval</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> doing = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (doing) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    doing = <span class=\"literal\">true</span>;</div><div class=\"line\">    fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      doing = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;, interval);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.onresize = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'execute'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br><br>&ensp;&ensp;&ensp;&ensp;高阶函数在设计模式中用的还是比较多的，也是比较有用的一个东西，所以掌握它是比较有必要性的。<br>最近在看曾探写的《Javascript设计模式与开发实践》，非常不错，值得推荐</p>\n<p>参考资料:《Javascript设计模式与开发实践》</p>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;&ensp;&ensp;最近在看js设计模式相关的书籍，发觉很多模式都有用到高阶函数这个东东，发觉自己之前没有总结过这类文章，所以来个小小的总结。总结的篇幅有点少，纯属做做笔记</p>","more":"<h2 id=\"1-高阶函数的定义\"><a href=\"#1-高阶函数的定义\" class=\"headerlink\" title=\"1. 高阶函数的定义\"></a>1. 高阶函数的定义</h2><p>高阶函数（Higher Order Function）,按照维基百科上面的定义，至少满足下列一个条件的函数：</p>\n<ul>\n<li>1 函数作为参数传入</li>\n<li>2 返回值为一个函数</li>\n</ul>\n<p>只要满足上面两个条件中的其中一个，就属于高阶函数，我们下面用代码来更好的理解一下</p>\n<p><strong> 函数作为参数传入 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a,b,fn</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> fn(a)+fn(b);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> fn=<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a*a;</div><div class=\"line\">&#125;</div><div class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">3</span>,fn); <span class=\"comment\">//13</span></div></pre></td></tr></table></figure></p>\n<p><strong> 函数作为返回值 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> getSingle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> ret;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> ret || (ret = fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-函数柯里化\"><a href=\"#2-函数柯里化\" class=\"headerlink\" title=\"2. 函数柯里化\"></a>2. 函数柯里化</h2><p>为啥会在这里穿插函数柯里化呢，因为函数柯里化里面包含了很多的高阶函数，所以这里也一并总结总结</p>\n<p><strong> 定义 </strong></p>\n<p>&ensp;&ensp;柯里化（Currying），又称部分求值，一个currying的函数首先会接受一些参数，接受这些参数之后，函数<strong>并不会立即求值</strong>，而是继续返回另一个函数，刚才传入的参数在函数形成的闭包中被保存起来，待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。<br>&ensp;&ensp;比如有下面的场景：有个销售需要统计每天的销售额，待到月底的时候再统一计算该月的销售总额。<br>用代码的形式如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currying = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>,args);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"built_in\">Array</span>.prototype.push.apply(args,<span class=\"built_in\">arguments</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>.callee;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> sell = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = <span class=\"built_in\">arguments</span>.length; i &lt; len; i++) &#123;</div><div class=\"line\">    sum += <span class=\"built_in\">arguments</span>[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> sellAmount = currying(sell);</div><div class=\"line\">sellAmount(<span class=\"number\">100</span>);</div><div class=\"line\">sellAmount(<span class=\"number\">200</span>);</div><div class=\"line\">sellAmount(<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(sellAmount()); <span class=\"comment\">//600</span></div></pre></td></tr></table></figure></p>\n<p>上面的代码就是函数柯里化的一种形式，我传入了每天的销售额，并不会立即求值，而是等到月底，我需要统计总额的时候才一次性求值</p>\n<h2 id=\"3-高阶函数实战\"><a href=\"#3-高阶函数实战\" class=\"headerlink\" title=\"3. 高阶函数实战\"></a>3. 高阶函数实战</h2><ul>\n<li><p>1.比较常用的一个地方,为一个元素添加事件;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.addEventListener) &#123;</div><div class=\"line\">      addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">        elem.addEventListener(type, handler, <span class=\"literal\">false</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.attachEvent) &#123;</div><div class=\"line\">      addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">elem, type, handler</span>) </span>&#123;</div><div class=\"line\">        elem.attachEvent(<span class=\"string\">'on'</span> + type, handler);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  addEvent(elem, type, handler);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.函数节流<br>比如在window.resize中，不想被频繁的触发事件，想每隔一定的间隔事件来触发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, interval</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> doing = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (doing) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    doing = <span class=\"literal\">true</span>;</div><div class=\"line\">    fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      doing = <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;, interval);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.onresize = throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'execute'</span>);</div><div class=\"line\">&#125;, <span class=\"number\">500</span>);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br ><br>&ensp;&ensp;&ensp;&ensp;高阶函数在设计模式中用的还是比较多的，也是比较有用的一个东西，所以掌握它是比较有必要性的。<br>最近在看曾探写的《Javascript设计模式与开发实践》，非常不错，值得推荐</p>\n<p>参考资料:《Javascript设计模式与开发实践》</p>"},{"title":"git常用命令总结","date":"2017-03-31T07:50:00.000Z","_content":"\n平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅\n\n<!--more-->\n\n## 正常的开发流程命令\n\n1、在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息)\n```\nGit clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu\n```\n2、进入项目目录，创建分支\n      `git branch `                看看当前的分支\n      `git checkout -b develop`    切换到develop分支.\n\n3、在自己的分支上进行代码的修改，修改好后，可以提交到远程分支上,提交方法看步骤4\n\n4、每次提交代码时候，需要先同步项目主分支代码\n* `git status`               是哪些文件有所修改\n* `git diff`                 可以查询所修改的代码(`git diff 文件名`可以查看指定文件修改的内容)\n* `git add -A .`             添加所有文件到暂缓区(`git add 文件名`文添加指定的文件)\n* `git commit -a -m \"这里是注释的内容\"`    提交所有修改的代码到当前分支上\n* `git push origin develop`  提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面\n\n5、发布测试的时候可能用的是分支的代码，测试完了，没问题，要上线了，这时候需要将代码merge到主分支上\n\n6、首先需要切换到主分支master上`git checkout master`,然后合并分支`git merge name`这里的name为分支名字。\n\n7、删除分支`git branch -d name`,然后推送到远程master `git push origin master`;\n\n* 有时候可能会是在别人的分支上进行代码的修改，此时，步骤3之后插多一个步骤：\n将自己的项目分支同步项目主分支（我们项目分支为develop分支）\n```\ngit pull git@xxx.gitlab.com:xxx/SELand_Vertu develop\n```\n\n## 若代码有冲突，可以这样解决\n\n1、`git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop`     先同步一下会出现以上的错误\n2、pull会使用git merge导致冲突，需要将冲突的文件resolve掉   `git add -u`,\n3、在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码\n4、`git commit` 之后才能成功\n\n## 添加修改\n1、添加文件到暂缓区：\n* `git add -A .`一次添加所有改变的文件\n* `git add xx`将xx文件添加到暂存区\n* `git add .` 添加新文件和编辑过的文件不包括删除的文件\n* `git add -u` 添加编辑或者删除的文件，不包括新添加的文件。\n\n2、commit文件\n* `git commit -m \"这里是注释\"` 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。\n* `git commit -a -m \"这里是注释\"` 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。\n* `git commit --amend`有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 --amend 选项。\n* `git commit --amend -a`用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交\n\n\n## 撤销修改\n\n#### 1、撤销commit\n方法1:\n&ensp;&ensp;执行`git log`查看 commit日志，然后`git reset --hard commit_id `commit_id是控制台上的hash值\n方法2:\n&ensp;&ensp;`git reset  –hard HEAD^`,如果是上上一个版本`git reset  –hard HEAD^^`,如果是上一百个版本`git reset  –hard HEAD~100 `;\n方法3:\n&ensp;&ensp;`git checkout  —-文件名` 撤销对某个文件的修改,例：`git checkout  —-readme.txt`；\n&ensp;&ensp;`git checkout -- .`撤销对所有文件的修改\n\n！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：`git push -f origin 分支名`\n\n#### 2、恢复到某一版本\n现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:\n`git reflog`查看历史版本；`git reset --hard 版本号 `\n\n#### 3、撤销add\n&ensp;&ensp;`git reset head <文件名>`   撤销对某个文件的add命令\n&ensp;&ensp;`git reset head .`  撤销所有文件的add命令\n\n\n## 创建与合并分支命令如下：\n* 查看分支：`git branch`\n* 创建分支：`git branch name`\n* 切换分支：`git checkout name`\n* 创建+切换分支：`git checkout –b name`\n* 合并某分支到当前分支：`git merge name`.比如将dev分支合并到master下，那么在master分支下执行`git merge dev`\n* 删除分支：`git branch –d name`\n\n\n## github提交时想忽略某些文件\n比如我提交的时候，不想提交`node_modules`这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加`.gitignore`这个文件\n`.gitignore`里面的内容参考如下：\n```bash\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 本地文件想提交到远程\n1、如果本地没有初始化git,在本地执行 `git init`\n2、`git add -A .`添加所有文件到暂缓区\n3、`git commit -a -m \"添加所有文件\"`\n4、`git remote add origin https://github.com/xianyulaodi/blogBackups.git`。注意需要将origin后面换成自己的Git地址。\n5、将本地仓库推送到远程仓库`git push -u origin master`第一次需要这样，以后只要执行`git push origin master`\n6、**关键！！**在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：`git pull --rebase origin master`将远程文件同步下来。然后在执行推送即可。\n  完成后在后续的推送文件到远程仓库中可直接执行`git push origin master`\n可以看看[这里](http://blog.sina.com.cn/s/blog_6cf7405b0102w5f9.html)\n\n## git常用命令\n* 创建一个空目录 XX指目录名` mkdir XX `\n* 显示当前目录的路径`pwd`\n* 把当前的目录变成可以管理的git仓库，生成隐藏.git文件`git init`\n* 把xx文件添加到暂存区去`git add XX`\n* 提交文件 –m 后面的是注释`git commit –m \"XX\"`\n* 查看仓库状态 `git status`\n* 查看XX文件修改了那些内容 `git diff XX`\n* 查看历史记录 ` git log`\n* 回退到上一个版本 `git reset  –hard HEAD^` 或者 `git reset  –hard HEAD~ `\n如果想回退到100个版本，使用`git reset –hard HEAD~100`\n* 查看XX文件内容 `cat XX`\n* 查看历史记录的版本号id `git reflog`\n* 把XX文件在工作区的修改全部撤销 `git checkout --XX`\n* 删除XX文件 `git rm XX`\n* 关联一个远程库 `git remote add origin https://github.com/xx`\n* 把当前master分支推送到远程库 `git push –u(第一次要用-u 以后不需要) origin master`\n* 从远程库中克隆 `git clone https://github.com/xx`\n* 创建dev分支 并切换到dev分支上 `git checkout –b dev`\n* 查看当前所有的分支 `git branch`\n* 切换回master分支 `git checkout master`\n* 在当前的分支上合并dev分支 ` git merge dev`\n* 删除dev分支 `git branch –d dev`\n* 创建分支 `git branch name`\n* 把当前的工作隐藏起来 等以后恢复现场后继续工作 `git stash`\n* 查看所有被隐藏的文件列表`git stash list`\n* 恢复被隐藏的文件，但是内容不删除`git stash apply `\n* 删除被隐藏文件 `git stash drop`\n* 恢复文件的同时 也删除文件 `git stash pop `\n* 查看远程库的信息`git remote`\n* 查看远程库的详细信息 `git remote –v`\n* 把master分支推送到远程库对应的远程分支上 `git push origin master`\n* 把分支推送到远程的分支`git push origin develop`或者`git push origin 本地分支名:远程分支名`\n\n\n## 常见问题(持续更新)\n问题1\n![](http://tutorialspots.com/wp-content/uploads/2016/10/Another-git-process-seems-to-be-running-in-this-repository.jpg)   \n解决方法：执行`rm .git/index.lock`\n\n问题2\n在git pull代码的时候，可能会遇到这个问题\n```bash\nerror: Your local changes to the following files would be overwritten by merge:\n    xxx/xxx/xxx.php\nPlease, commit your changes or stash them before you can merge.\nAborting\n```\n出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。\n\n**保留本地的修改 的改法**\n1）直接commit本地的修改\n2）通过`git stash`\n```bash\ngit stash\ngit pull\ngit stash pop\n```\n&ensp;&ensp;&ensp;&ensp;通过`git stash`将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。\n&ensp;&ensp;&ensp;&ensp;`git stash`: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。\n`git stash pop`: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。\n&ensp;&ensp;&ensp;&ensp;`git stash list`: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。\n&ensp;&ensp;&ensp;&ensp;`git stash clear`: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。\n\n**放弃本地修改 的改法**\n`git reset --hard`\n`git pull`\n\n问题3\n![](http://images2015.cnblogs.com/blog/630011/201603/630011-20160315120522896-1718649799.jpg)\ngit 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:\n1.按键盘字母 i 进入insert模式\n2.修改最上面那行黄色合并信息,可以不修改\n3.按键盘左上角\"Esc\"\n4.输入\":wq\",注意是冒号+wq,按回车键即可\n\n问题4\n`git pull`的时候，可能会遇到下面的报错\n```bash\nremote: Counting objects: 369, done.  \nefrror: RPC failed; result=56, HTTP code = 200  \natal: The remote end hung up unexpectedly  \nfatal: protocol error: bad pack header  \n```\n**解决方法**\n依次输入以下命令\n```bash\ngit config --global pack.windowMemory \"100m\"  \ngit config --global pack.SizeLimit \"100m\"  \ngit config --global pack.threads \"1\"\n```\n\n问题5\ngit clone的时候，可能会遇到这个报错，很烦人\n\n```bash\nakagi201@akgentoo ~/a20-kernel (master*) $ git config http.postBuffer 5024288000\nakagi201@akgentoo ~/a20-kernel (master*) $ git submodule update\nCloning into 'linux-sunxi'...\nremote: Counting objects: 4022357, done.\nremote: Compressing objects: 100% (682462/682462), done.\nerror: RPC failed; result=18, HTTP code = 200.31 MiB | 654.00 KiB/s\nfatal: The remote end hung up unexpectedly\nfatal: early EOF\nfatal: index-pack failed\nClone of 'https://github.com/linux-sunxi/linux-sunxi.git' into submodule path 'linux-sunxi' failed\n```\n解决方法：亲测有效\n\n```bash\ngit clone url --depth  1\n```\n比如：\n```bash\ngit clone https://github.com/xianyulaodi/express-study.git --depth  1\n```\n\n问题6\ngit pull的时候，可能会遇到如下报错\n\n```bash\n$ git pull\nerror: You have not concluded your merge (MERGE_HEAD exists).\nhint: Please, commit your changes before merging.\nfatal: Exiting because of unfinished merge.\n```\n错误可能是因为在你以前pull下来的代码没有自动合并导致的.\n有2个解决办法:\n1. 保留你本地的修改\n`git merge --abort`\n`git reset --merge`\n`git commit xxx -m \"注释\"`  合并后记得一定要提交这个本地的合并\n`git pull`\n\n2. 抛弃本地的修改\n不建议这样做,但是如果你本地修改不大,或者自己有一份备份留存,可以直接用线上最新版本覆盖到本地\n`git fetch --all`\n`git reset --hard origin/master`\n`git fetch`\n","source":"_posts/git常用命令总结.md","raw":"---\ntitle: git常用命令总结\ndate: 2017-03-31 15:50\ncategories:\ntags:\n     - git\n---\n\n平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅\n\n<!--more-->\n\n## 正常的开发流程命令\n\n1、在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息)\n```\nGit clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu\n```\n2、进入项目目录，创建分支\n      `git branch `                看看当前的分支\n      `git checkout -b develop`    切换到develop分支.\n\n3、在自己的分支上进行代码的修改，修改好后，可以提交到远程分支上,提交方法看步骤4\n\n4、每次提交代码时候，需要先同步项目主分支代码\n* `git status`               是哪些文件有所修改\n* `git diff`                 可以查询所修改的代码(`git diff 文件名`可以查看指定文件修改的内容)\n* `git add -A .`             添加所有文件到暂缓区(`git add 文件名`文添加指定的文件)\n* `git commit -a -m \"这里是注释的内容\"`    提交所有修改的代码到当前分支上\n* `git push origin develop`  提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面\n\n5、发布测试的时候可能用的是分支的代码，测试完了，没问题，要上线了，这时候需要将代码merge到主分支上\n\n6、首先需要切换到主分支master上`git checkout master`,然后合并分支`git merge name`这里的name为分支名字。\n\n7、删除分支`git branch -d name`,然后推送到远程master `git push origin master`;\n\n* 有时候可能会是在别人的分支上进行代码的修改，此时，步骤3之后插多一个步骤：\n将自己的项目分支同步项目主分支（我们项目分支为develop分支）\n```\ngit pull git@xxx.gitlab.com:xxx/SELand_Vertu develop\n```\n\n## 若代码有冲突，可以这样解决\n\n1、`git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop`     先同步一下会出现以上的错误\n2、pull会使用git merge导致冲突，需要将冲突的文件resolve掉   `git add -u`,\n3、在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码\n4、`git commit` 之后才能成功\n\n## 添加修改\n1、添加文件到暂缓区：\n* `git add -A .`一次添加所有改变的文件\n* `git add xx`将xx文件添加到暂存区\n* `git add .` 添加新文件和编辑过的文件不包括删除的文件\n* `git add -u` 添加编辑或者删除的文件，不包括新添加的文件。\n\n2、commit文件\n* `git commit -m \"这里是注释\"` 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。\n* `git commit -a -m \"这里是注释\"` 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。\n* `git commit --amend`有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 --amend 选项。\n* `git commit --amend -a`用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交\n\n\n## 撤销修改\n\n#### 1、撤销commit\n方法1:\n&ensp;&ensp;执行`git log`查看 commit日志，然后`git reset --hard commit_id `commit_id是控制台上的hash值\n方法2:\n&ensp;&ensp;`git reset  –hard HEAD^`,如果是上上一个版本`git reset  –hard HEAD^^`,如果是上一百个版本`git reset  –hard HEAD~100 `;\n方法3:\n&ensp;&ensp;`git checkout  —-文件名` 撤销对某个文件的修改,例：`git checkout  —-readme.txt`；\n&ensp;&ensp;`git checkout -- .`撤销对所有文件的修改\n\n！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：`git push -f origin 分支名`\n\n#### 2、恢复到某一版本\n现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:\n`git reflog`查看历史版本；`git reset --hard 版本号 `\n\n#### 3、撤销add\n&ensp;&ensp;`git reset head <文件名>`   撤销对某个文件的add命令\n&ensp;&ensp;`git reset head .`  撤销所有文件的add命令\n\n\n## 创建与合并分支命令如下：\n* 查看分支：`git branch`\n* 创建分支：`git branch name`\n* 切换分支：`git checkout name`\n* 创建+切换分支：`git checkout –b name`\n* 合并某分支到当前分支：`git merge name`.比如将dev分支合并到master下，那么在master分支下执行`git merge dev`\n* 删除分支：`git branch –d name`\n\n\n## github提交时想忽略某些文件\n比如我提交的时候，不想提交`node_modules`这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加`.gitignore`这个文件\n`.gitignore`里面的内容参考如下：\n```bash\n.DS_Store\nThumbs.db\ndb.json\n*.log\nnode_modules/\npublic/\n.deploy*/\n```\n\n## 本地文件想提交到远程\n1、如果本地没有初始化git,在本地执行 `git init`\n2、`git add -A .`添加所有文件到暂缓区\n3、`git commit -a -m \"添加所有文件\"`\n4、`git remote add origin https://github.com/xianyulaodi/blogBackups.git`。注意需要将origin后面换成自己的Git地址。\n5、将本地仓库推送到远程仓库`git push -u origin master`第一次需要这样，以后只要执行`git push origin master`\n6、**关键！！**在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：`git pull --rebase origin master`将远程文件同步下来。然后在执行推送即可。\n  完成后在后续的推送文件到远程仓库中可直接执行`git push origin master`\n可以看看[这里](http://blog.sina.com.cn/s/blog_6cf7405b0102w5f9.html)\n\n## git常用命令\n* 创建一个空目录 XX指目录名` mkdir XX `\n* 显示当前目录的路径`pwd`\n* 把当前的目录变成可以管理的git仓库，生成隐藏.git文件`git init`\n* 把xx文件添加到暂存区去`git add XX`\n* 提交文件 –m 后面的是注释`git commit –m \"XX\"`\n* 查看仓库状态 `git status`\n* 查看XX文件修改了那些内容 `git diff XX`\n* 查看历史记录 ` git log`\n* 回退到上一个版本 `git reset  –hard HEAD^` 或者 `git reset  –hard HEAD~ `\n如果想回退到100个版本，使用`git reset –hard HEAD~100`\n* 查看XX文件内容 `cat XX`\n* 查看历史记录的版本号id `git reflog`\n* 把XX文件在工作区的修改全部撤销 `git checkout --XX`\n* 删除XX文件 `git rm XX`\n* 关联一个远程库 `git remote add origin https://github.com/xx`\n* 把当前master分支推送到远程库 `git push –u(第一次要用-u 以后不需要) origin master`\n* 从远程库中克隆 `git clone https://github.com/xx`\n* 创建dev分支 并切换到dev分支上 `git checkout –b dev`\n* 查看当前所有的分支 `git branch`\n* 切换回master分支 `git checkout master`\n* 在当前的分支上合并dev分支 ` git merge dev`\n* 删除dev分支 `git branch –d dev`\n* 创建分支 `git branch name`\n* 把当前的工作隐藏起来 等以后恢复现场后继续工作 `git stash`\n* 查看所有被隐藏的文件列表`git stash list`\n* 恢复被隐藏的文件，但是内容不删除`git stash apply `\n* 删除被隐藏文件 `git stash drop`\n* 恢复文件的同时 也删除文件 `git stash pop `\n* 查看远程库的信息`git remote`\n* 查看远程库的详细信息 `git remote –v`\n* 把master分支推送到远程库对应的远程分支上 `git push origin master`\n* 把分支推送到远程的分支`git push origin develop`或者`git push origin 本地分支名:远程分支名`\n\n\n## 常见问题(持续更新)\n问题1\n![](http://tutorialspots.com/wp-content/uploads/2016/10/Another-git-process-seems-to-be-running-in-this-repository.jpg)   \n解决方法：执行`rm .git/index.lock`\n\n问题2\n在git pull代码的时候，可能会遇到这个问题\n```bash\nerror: Your local changes to the following files would be overwritten by merge:\n    xxx/xxx/xxx.php\nPlease, commit your changes or stash them before you can merge.\nAborting\n```\n出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。\n\n**保留本地的修改 的改法**\n1）直接commit本地的修改\n2）通过`git stash`\n```bash\ngit stash\ngit pull\ngit stash pop\n```\n&ensp;&ensp;&ensp;&ensp;通过`git stash`将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。\n&ensp;&ensp;&ensp;&ensp;`git stash`: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。\n`git stash pop`: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。\n&ensp;&ensp;&ensp;&ensp;`git stash list`: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。\n&ensp;&ensp;&ensp;&ensp;`git stash clear`: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。\n\n**放弃本地修改 的改法**\n`git reset --hard`\n`git pull`\n\n问题3\n![](http://images2015.cnblogs.com/blog/630011/201603/630011-20160315120522896-1718649799.jpg)\ngit 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:\n1.按键盘字母 i 进入insert模式\n2.修改最上面那行黄色合并信息,可以不修改\n3.按键盘左上角\"Esc\"\n4.输入\":wq\",注意是冒号+wq,按回车键即可\n\n问题4\n`git pull`的时候，可能会遇到下面的报错\n```bash\nremote: Counting objects: 369, done.  \nefrror: RPC failed; result=56, HTTP code = 200  \natal: The remote end hung up unexpectedly  \nfatal: protocol error: bad pack header  \n```\n**解决方法**\n依次输入以下命令\n```bash\ngit config --global pack.windowMemory \"100m\"  \ngit config --global pack.SizeLimit \"100m\"  \ngit config --global pack.threads \"1\"\n```\n\n问题5\ngit clone的时候，可能会遇到这个报错，很烦人\n\n```bash\nakagi201@akgentoo ~/a20-kernel (master*) $ git config http.postBuffer 5024288000\nakagi201@akgentoo ~/a20-kernel (master*) $ git submodule update\nCloning into 'linux-sunxi'...\nremote: Counting objects: 4022357, done.\nremote: Compressing objects: 100% (682462/682462), done.\nerror: RPC failed; result=18, HTTP code = 200.31 MiB | 654.00 KiB/s\nfatal: The remote end hung up unexpectedly\nfatal: early EOF\nfatal: index-pack failed\nClone of 'https://github.com/linux-sunxi/linux-sunxi.git' into submodule path 'linux-sunxi' failed\n```\n解决方法：亲测有效\n\n```bash\ngit clone url --depth  1\n```\n比如：\n```bash\ngit clone https://github.com/xianyulaodi/express-study.git --depth  1\n```\n\n问题6\ngit pull的时候，可能会遇到如下报错\n\n```bash\n$ git pull\nerror: You have not concluded your merge (MERGE_HEAD exists).\nhint: Please, commit your changes before merging.\nfatal: Exiting because of unfinished merge.\n```\n错误可能是因为在你以前pull下来的代码没有自动合并导致的.\n有2个解决办法:\n1. 保留你本地的修改\n`git merge --abort`\n`git reset --merge`\n`git commit xxx -m \"注释\"`  合并后记得一定要提交这个本地的合并\n`git pull`\n\n2. 抛弃本地的修改\n不建议这样做,但是如果你本地修改不大,或者自己有一份备份留存,可以直接用线上最新版本覆盖到本地\n`git fetch --all`\n`git reset --hard origin/master`\n`git fetch`\n","slug":"git常用命令总结","published":1,"updated":"2017-05-06T02:51:09.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr5v00079gscpsno978p","content":"<p>平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅</p>\n<a id=\"more\"></a>\n<h2 id=\"正常的开发流程命令\"><a href=\"#正常的开发流程命令\" class=\"headerlink\" title=\"正常的开发流程命令\"></a>正常的开发流程命令</h2><p>1、在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Git clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu</div></pre></td></tr></table></figure></p>\n<p>2、进入项目目录，创建分支<br>      <code>git branch</code>                看看当前的分支<br>      <code>git checkout -b develop</code>    切换到develop分支.</p>\n<p>3、在自己的分支上进行代码的修改，修改好后，可以提交到远程分支上,提交方法看步骤4</p>\n<p>4、每次提交代码时候，需要先同步项目主分支代码</p>\n<ul>\n<li><code>git status</code>               是哪些文件有所修改</li>\n<li><code>git diff</code>                 可以查询所修改的代码(<code>git diff 文件名</code>可以查看指定文件修改的内容)</li>\n<li><code>git add -A .</code>             添加所有文件到暂缓区(<code>git add 文件名</code>文添加指定的文件)</li>\n<li><code>git commit -a -m &quot;这里是注释的内容&quot;</code>    提交所有修改的代码到当前分支上</li>\n<li><code>git push origin develop</code>  提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面</li>\n</ul>\n<p>5、发布测试的时候可能用的是分支的代码，测试完了，没问题，要上线了，这时候需要将代码merge到主分支上</p>\n<p>6、首先需要切换到主分支master上<code>git checkout master</code>,然后合并分支<code>git merge name</code>这里的name为分支名字。</p>\n<p>7、删除分支<code>git branch -d name</code>,然后推送到远程master <code>git push origin master</code>;</p>\n<ul>\n<li>有时候可能会是在别人的分支上进行代码的修改，此时，步骤3之后插多一个步骤：<br>将自己的项目分支同步项目主分支（我们项目分支为develop分支）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"若代码有冲突，可以这样解决\"><a href=\"#若代码有冲突，可以这样解决\" class=\"headerlink\" title=\"若代码有冲突，可以这样解决\"></a>若代码有冲突，可以这样解决</h2><p>1、<code>git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop</code>     先同步一下会出现以上的错误<br>2、pull会使用git merge导致冲突，需要将冲突的文件resolve掉   <code>git add -u</code>,<br>3、在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码<br>4、<code>git commit</code> 之后才能成功</p>\n<h2 id=\"添加修改\"><a href=\"#添加修改\" class=\"headerlink\" title=\"添加修改\"></a>添加修改</h2><p>1、添加文件到暂缓区：</p>\n<ul>\n<li><code>git add -A .</code>一次添加所有改变的文件</li>\n<li><code>git add xx</code>将xx文件添加到暂存区</li>\n<li><code>git add .</code> 添加新文件和编辑过的文件不包括删除的文件</li>\n<li><code>git add -u</code> 添加编辑或者删除的文件，不包括新添加的文件。</li>\n</ul>\n<p>2、commit文件</p>\n<ul>\n<li><code>git commit -m &quot;这里是注释&quot;</code> 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</li>\n<li><code>git commit -a -m &quot;这里是注释&quot;</code> 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。</li>\n<li><code>git commit --amend</code>有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。</li>\n<li><code>git commit --amend -a</code>用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交</li>\n</ul>\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><h4 id=\"1、撤销commit\"><a href=\"#1、撤销commit\" class=\"headerlink\" title=\"1、撤销commit\"></a>1、撤销commit</h4><p>方法1:<br>&ensp;&ensp;执行<code>git log</code>查看 commit日志，然后<code>git reset --hard commit_id</code>commit_id是控制台上的hash值<br>方法2:<br>&ensp;&ensp;<code>git reset  –hard HEAD^</code>,如果是上上一个版本<code>git reset  –hard HEAD^^</code>,如果是上一百个版本<code>git reset  –hard HEAD~100</code>;<br>方法3:<br>&ensp;&ensp;<code>git checkout  —-文件名</code> 撤销对某个文件的修改,例：<code>git checkout  —-readme.txt</code>；<br>&ensp;&ensp;<code>git checkout -- .</code>撤销对所有文件的修改</p>\n<p>！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：<code>git push -f origin 分支名</code></p>\n<h4 id=\"2、恢复到某一版本\"><a href=\"#2、恢复到某一版本\" class=\"headerlink\" title=\"2、恢复到某一版本\"></a>2、恢复到某一版本</h4><p>现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:<br><code>git reflog</code>查看历史版本；<code>git reset --hard 版本号</code></p>\n<h4 id=\"3、撤销add\"><a href=\"#3、撤销add\" class=\"headerlink\" title=\"3、撤销add\"></a>3、撤销add</h4><p>&ensp;&ensp;<code>git reset head &lt;文件名&gt;</code>   撤销对某个文件的add命令<br>&ensp;&ensp;<code>git reset head .</code>  撤销所有文件的add命令</p>\n<h2 id=\"创建与合并分支命令如下：\"><a href=\"#创建与合并分支命令如下：\" class=\"headerlink\" title=\"创建与合并分支命令如下：\"></a>创建与合并分支命令如下：</h2><ul>\n<li>查看分支：<code>git branch</code></li>\n<li>创建分支：<code>git branch name</code></li>\n<li>切换分支：<code>git checkout name</code></li>\n<li>创建+切换分支：<code>git checkout –b name</code></li>\n<li>合并某分支到当前分支：<code>git merge name</code>.比如将dev分支合并到master下，那么在master分支下执行<code>git merge dev</code></li>\n<li>删除分支：<code>git branch –d name</code></li>\n</ul>\n<h2 id=\"github提交时想忽略某些文件\"><a href=\"#github提交时想忽略某些文件\" class=\"headerlink\" title=\"github提交时想忽略某些文件\"></a>github提交时想忽略某些文件</h2><p>比如我提交的时候，不想提交<code>node_modules</code>这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加<code>.gitignore</code>这个文件<br><code>.gitignore</code>里面的内容参考如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">db.json</div><div class=\"line\">*.log</div><div class=\"line\">node_modules/</div><div class=\"line\">public/</div><div class=\"line\">.deploy*/</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地文件想提交到远程\"><a href=\"#本地文件想提交到远程\" class=\"headerlink\" title=\"本地文件想提交到远程\"></a>本地文件想提交到远程</h2><p>1、如果本地没有初始化git,在本地执行 <code>git init</code><br>2、<code>git add -A .</code>添加所有文件到暂缓区<br>3、<code>git commit -a -m &quot;添加所有文件&quot;</code><br>4、<code>git remote add origin https://github.com/xianyulaodi/blogBackups.git</code>。注意需要将origin后面换成自己的Git地址。<br>5、将本地仓库推送到远程仓库<code>git push -u origin master</code>第一次需要这样，以后只要执行<code>git push origin master</code><br>6、<strong>关键！！</strong>在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：<code>git pull --rebase origin master</code>将远程文件同步下来。然后在执行推送即可。<br>  完成后在后续的推送文件到远程仓库中可直接执行<code>git push origin master</code><br>可以看看<a href=\"http://blog.sina.com.cn/s/blog_6cf7405b0102w5f9.html\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"git常用命令\"><a href=\"#git常用命令\" class=\"headerlink\" title=\"git常用命令\"></a>git常用命令</h2><ul>\n<li>创建一个空目录 XX指目录名<code>mkdir XX</code></li>\n<li>显示当前目录的路径<code>pwd</code></li>\n<li>把当前的目录变成可以管理的git仓库，生成隐藏.git文件<code>git init</code></li>\n<li>把xx文件添加到暂存区去<code>git add XX</code></li>\n<li>提交文件 –m 后面的是注释<code>git commit –m &quot;XX&quot;</code></li>\n<li>查看仓库状态 <code>git status</code></li>\n<li>查看XX文件修改了那些内容 <code>git diff XX</code></li>\n<li>查看历史记录 <code>git log</code></li>\n<li>回退到上一个版本 <code>git reset  –hard HEAD^</code> 或者 <code>git reset  –hard HEAD~</code><br>如果想回退到100个版本，使用<code>git reset –hard HEAD~100</code></li>\n<li>查看XX文件内容 <code>cat XX</code></li>\n<li>查看历史记录的版本号id <code>git reflog</code></li>\n<li>把XX文件在工作区的修改全部撤销 <code>git checkout --XX</code></li>\n<li>删除XX文件 <code>git rm XX</code></li>\n<li>关联一个远程库 <code>git remote add origin https://github.com/xx</code></li>\n<li>把当前master分支推送到远程库 <code>git push –u(第一次要用-u 以后不需要) origin master</code></li>\n<li>从远程库中克隆 <code>git clone https://github.com/xx</code></li>\n<li>创建dev分支 并切换到dev分支上 <code>git checkout –b dev</code></li>\n<li>查看当前所有的分支 <code>git branch</code></li>\n<li>切换回master分支 <code>git checkout master</code></li>\n<li>在当前的分支上合并dev分支 <code>git merge dev</code></li>\n<li>删除dev分支 <code>git branch –d dev</code></li>\n<li>创建分支 <code>git branch name</code></li>\n<li>把当前的工作隐藏起来 等以后恢复现场后继续工作 <code>git stash</code></li>\n<li>查看所有被隐藏的文件列表<code>git stash list</code></li>\n<li>恢复被隐藏的文件，但是内容不删除<code>git stash apply</code></li>\n<li>删除被隐藏文件 <code>git stash drop</code></li>\n<li>恢复文件的同时 也删除文件 <code>git stash pop</code></li>\n<li>查看远程库的信息<code>git remote</code></li>\n<li>查看远程库的详细信息 <code>git remote –v</code></li>\n<li>把master分支推送到远程库对应的远程分支上 <code>git push origin master</code></li>\n<li>把分支推送到远程的分支<code>git push origin develop</code>或者<code>git push origin 本地分支名:远程分支名</code></li>\n</ul>\n<h2 id=\"常见问题-持续更新\"><a href=\"#常见问题-持续更新\" class=\"headerlink\" title=\"常见问题(持续更新)\"></a>常见问题(持续更新)</h2><p>问题1<br><img src=\"http://tutorialspots.com/wp-content/uploads/2016/10/Another-git-process-seems-to-be-running-in-this-repository.jpg\" alt=\"\"><br>解决方法：执行<code>rm .git/index.lock</code></p>\n<p>问题2<br>在git pull代码的时候，可能会遇到这个问题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: Your <span class=\"built_in\">local</span> changes to the following files would be overwritten by merge:</div><div class=\"line\">    xxx/xxx/xxx.php</div><div class=\"line\">Please, commit your changes or stash them before you can merge.</div><div class=\"line\">Aborting</div></pre></td></tr></table></figure></p>\n<p>出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。</p>\n<p><strong>保留本地的修改 的改法</strong><br>1）直接commit本地的修改<br>2）通过<code>git stash</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git stash</div><div class=\"line\">git pull</div><div class=\"line\">git stash pop</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;通过<code>git stash</code>将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash</code>: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br><code>git stash pop</code>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash list</code>: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash clear</code>: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>\n<p><strong>放弃本地修改 的改法</strong><br><code>git reset --hard</code><br><code>git pull</code></p>\n<p>问题3<br><img src=\"http://images2015.cnblogs.com/blog/630011/201603/630011-20160315120522896-1718649799.jpg\" alt=\"\"><br>git 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:<br>1.按键盘字母 i 进入insert模式<br>2.修改最上面那行黄色合并信息,可以不修改<br>3.按键盘左上角”Esc”<br>4.输入”:wq”,注意是冒号+wq,按回车键即可</p>\n<p>问题4<br><code>git pull</code>的时候，可能会遇到下面的报错<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">remote: Counting objects: 369, done.  </div><div class=\"line\">efrror: RPC failed; result=56, HTTP code = 200  </div><div class=\"line\">atal: The remote end hung up unexpectedly  </div><div class=\"line\">fatal: protocol error: bad pack header</div></pre></td></tr></table></figure></p>\n<p><strong>解决方法</strong><br>依次输入以下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global pack.windowMemory <span class=\"string\">\"100m\"</span>  </div><div class=\"line\">git config --global pack.SizeLimit <span class=\"string\">\"100m\"</span>  </div><div class=\"line\">git config --global pack.threads <span class=\"string\">\"1\"</span></div></pre></td></tr></table></figure></p>\n<p>问题5<br>git clone的时候，可能会遇到这个报错，很烦人</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">akagi201@akgentoo ~/a20-kernel (master*) $ git config http.postBuffer 5024288000</div><div class=\"line\">akagi201@akgentoo ~/a20-kernel (master*) $ git submodule update</div><div class=\"line\">Cloning into <span class=\"string\">'linux-sunxi'</span>...</div><div class=\"line\">remote: Counting objects: 4022357, done.</div><div class=\"line\">remote: Compressing objects: 100% (682462/682462), done.</div><div class=\"line\">error: RPC failed; result=18, HTTP code = 200.31 MiB | 654.00 KiB/s</div><div class=\"line\">fatal: The remote end hung up unexpectedly</div><div class=\"line\">fatal: early EOF</div><div class=\"line\">fatal: index-pack failed</div><div class=\"line\">Clone of <span class=\"string\">'https://github.com/linux-sunxi/linux-sunxi.git'</span> into submodule path <span class=\"string\">'linux-sunxi'</span> failed</div></pre></td></tr></table></figure>\n<p>解决方法：亲测有效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> url --depth  1</div></pre></td></tr></table></figure>\n<p>比如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xianyulaodi/express-study.git --depth  1</div></pre></td></tr></table></figure></p>\n<p>问题6<br>git pull的时候，可能会遇到如下报错</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull</div><div class=\"line\">error: You have not concluded your merge (MERGE_HEAD exists).</div><div class=\"line\">hint: Please, commit your changes before merging.</div><div class=\"line\">fatal: Exiting because of unfinished merge.</div></pre></td></tr></table></figure>\n<p>错误可能是因为在你以前pull下来的代码没有自动合并导致的.<br>有2个解决办法:</p>\n<ol>\n<li><p>保留你本地的修改<br><code>git merge --abort</code><br><code>git reset --merge</code><br><code>git commit xxx -m &quot;注释&quot;</code>  合并后记得一定要提交这个本地的合并<br><code>git pull</code></p>\n</li>\n<li><p>抛弃本地的修改<br>不建议这样做,但是如果你本地修改不大,或者自己有一份备份留存,可以直接用线上最新版本覆盖到本地<br><code>git fetch --all</code><br><code>git reset --hard origin/master</code><br><code>git fetch</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅</p>","more":"<h2 id=\"正常的开发流程命令\"><a href=\"#正常的开发流程命令\" class=\"headerlink\" title=\"正常的开发流程命令\"></a>正常的开发流程命令</h2><p>1、在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Git clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu</div></pre></td></tr></table></figure></p>\n<p>2、进入项目目录，创建分支<br>      <code>git branch</code>                看看当前的分支<br>      <code>git checkout -b develop</code>    切换到develop分支.</p>\n<p>3、在自己的分支上进行代码的修改，修改好后，可以提交到远程分支上,提交方法看步骤4</p>\n<p>4、每次提交代码时候，需要先同步项目主分支代码</p>\n<ul>\n<li><code>git status</code>               是哪些文件有所修改</li>\n<li><code>git diff</code>                 可以查询所修改的代码(<code>git diff 文件名</code>可以查看指定文件修改的内容)</li>\n<li><code>git add -A .</code>             添加所有文件到暂缓区(<code>git add 文件名</code>文添加指定的文件)</li>\n<li><code>git commit -a -m &quot;这里是注释的内容&quot;</code>    提交所有修改的代码到当前分支上</li>\n<li><code>git push origin develop</code>  提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面</li>\n</ul>\n<p>5、发布测试的时候可能用的是分支的代码，测试完了，没问题，要上线了，这时候需要将代码merge到主分支上</p>\n<p>6、首先需要切换到主分支master上<code>git checkout master</code>,然后合并分支<code>git merge name</code>这里的name为分支名字。</p>\n<p>7、删除分支<code>git branch -d name</code>,然后推送到远程master <code>git push origin master</code>;</p>\n<ul>\n<li>有时候可能会是在别人的分支上进行代码的修改，此时，步骤3之后插多一个步骤：<br>将自己的项目分支同步项目主分支（我们项目分支为develop分支）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"若代码有冲突，可以这样解决\"><a href=\"#若代码有冲突，可以这样解决\" class=\"headerlink\" title=\"若代码有冲突，可以这样解决\"></a>若代码有冲突，可以这样解决</h2><p>1、<code>git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop</code>     先同步一下会出现以上的错误<br>2、pull会使用git merge导致冲突，需要将冲突的文件resolve掉   <code>git add -u</code>,<br>3、在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码<br>4、<code>git commit</code> 之后才能成功</p>\n<h2 id=\"添加修改\"><a href=\"#添加修改\" class=\"headerlink\" title=\"添加修改\"></a>添加修改</h2><p>1、添加文件到暂缓区：</p>\n<ul>\n<li><code>git add -A .</code>一次添加所有改变的文件</li>\n<li><code>git add xx</code>将xx文件添加到暂存区</li>\n<li><code>git add .</code> 添加新文件和编辑过的文件不包括删除的文件</li>\n<li><code>git add -u</code> 添加编辑或者删除的文件，不包括新添加的文件。</li>\n</ul>\n<p>2、commit文件</p>\n<ul>\n<li><code>git commit -m &quot;这里是注释&quot;</code> 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。</li>\n<li><code>git commit -a -m &quot;这里是注释&quot;</code> 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。</li>\n<li><code>git commit --amend</code>有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。</li>\n<li><code>git commit --amend -a</code>用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交</li>\n</ul>\n<h2 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h2><h4 id=\"1、撤销commit\"><a href=\"#1、撤销commit\" class=\"headerlink\" title=\"1、撤销commit\"></a>1、撤销commit</h4><p>方法1:<br>&ensp;&ensp;执行<code>git log</code>查看 commit日志，然后<code>git reset --hard commit_id</code>commit_id是控制台上的hash值<br>方法2:<br>&ensp;&ensp;<code>git reset  –hard HEAD^</code>,如果是上上一个版本<code>git reset  –hard HEAD^^</code>,如果是上一百个版本<code>git reset  –hard HEAD~100</code>;<br>方法3:<br>&ensp;&ensp;<code>git checkout  —-文件名</code> 撤销对某个文件的修改,例：<code>git checkout  —-readme.txt</code>；<br>&ensp;&ensp;<code>git checkout -- .</code>撤销对所有文件的修改</p>\n<p>！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：<code>git push -f origin 分支名</code></p>\n<h4 id=\"2、恢复到某一版本\"><a href=\"#2、恢复到某一版本\" class=\"headerlink\" title=\"2、恢复到某一版本\"></a>2、恢复到某一版本</h4><p>现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:<br><code>git reflog</code>查看历史版本；<code>git reset --hard 版本号</code></p>\n<h4 id=\"3、撤销add\"><a href=\"#3、撤销add\" class=\"headerlink\" title=\"3、撤销add\"></a>3、撤销add</h4><p>&ensp;&ensp;<code>git reset head &lt;文件名&gt;</code>   撤销对某个文件的add命令<br>&ensp;&ensp;<code>git reset head .</code>  撤销所有文件的add命令</p>\n<h2 id=\"创建与合并分支命令如下：\"><a href=\"#创建与合并分支命令如下：\" class=\"headerlink\" title=\"创建与合并分支命令如下：\"></a>创建与合并分支命令如下：</h2><ul>\n<li>查看分支：<code>git branch</code></li>\n<li>创建分支：<code>git branch name</code></li>\n<li>切换分支：<code>git checkout name</code></li>\n<li>创建+切换分支：<code>git checkout –b name</code></li>\n<li>合并某分支到当前分支：<code>git merge name</code>.比如将dev分支合并到master下，那么在master分支下执行<code>git merge dev</code></li>\n<li>删除分支：<code>git branch –d name</code></li>\n</ul>\n<h2 id=\"github提交时想忽略某些文件\"><a href=\"#github提交时想忽略某些文件\" class=\"headerlink\" title=\"github提交时想忽略某些文件\"></a>github提交时想忽略某些文件</h2><p>比如我提交的时候，不想提交<code>node_modules</code>这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加<code>.gitignore</code>这个文件<br><code>.gitignore</code>里面的内容参考如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.DS_Store</div><div class=\"line\">Thumbs.db</div><div class=\"line\">db.json</div><div class=\"line\">*.log</div><div class=\"line\">node_modules/</div><div class=\"line\">public/</div><div class=\"line\">.deploy*/</div></pre></td></tr></table></figure></p>\n<h2 id=\"本地文件想提交到远程\"><a href=\"#本地文件想提交到远程\" class=\"headerlink\" title=\"本地文件想提交到远程\"></a>本地文件想提交到远程</h2><p>1、如果本地没有初始化git,在本地执行 <code>git init</code><br>2、<code>git add -A .</code>添加所有文件到暂缓区<br>3、<code>git commit -a -m &quot;添加所有文件&quot;</code><br>4、<code>git remote add origin https://github.com/xianyulaodi/blogBackups.git</code>。注意需要将origin后面换成自己的Git地址。<br>5、将本地仓库推送到远程仓库<code>git push -u origin master</code>第一次需要这样，以后只要执行<code>git push origin master</code><br>6、<strong>关键！！</strong>在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：<code>git pull --rebase origin master</code>将远程文件同步下来。然后在执行推送即可。<br>  完成后在后续的推送文件到远程仓库中可直接执行<code>git push origin master</code><br>可以看看<a href=\"http://blog.sina.com.cn/s/blog_6cf7405b0102w5f9.html\">这里</a></p>\n<h2 id=\"git常用命令\"><a href=\"#git常用命令\" class=\"headerlink\" title=\"git常用命令\"></a>git常用命令</h2><ul>\n<li>创建一个空目录 XX指目录名<code>mkdir XX</code></li>\n<li>显示当前目录的路径<code>pwd</code></li>\n<li>把当前的目录变成可以管理的git仓库，生成隐藏.git文件<code>git init</code></li>\n<li>把xx文件添加到暂存区去<code>git add XX</code></li>\n<li>提交文件 –m 后面的是注释<code>git commit –m &quot;XX&quot;</code></li>\n<li>查看仓库状态 <code>git status</code></li>\n<li>查看XX文件修改了那些内容 <code>git diff XX</code></li>\n<li>查看历史记录 <code>git log</code></li>\n<li>回退到上一个版本 <code>git reset  –hard HEAD^</code> 或者 <code>git reset  –hard HEAD~</code><br>如果想回退到100个版本，使用<code>git reset –hard HEAD~100</code></li>\n<li>查看XX文件内容 <code>cat XX</code></li>\n<li>查看历史记录的版本号id <code>git reflog</code></li>\n<li>把XX文件在工作区的修改全部撤销 <code>git checkout --XX</code></li>\n<li>删除XX文件 <code>git rm XX</code></li>\n<li>关联一个远程库 <code>git remote add origin https://github.com/xx</code></li>\n<li>把当前master分支推送到远程库 <code>git push –u(第一次要用-u 以后不需要) origin master</code></li>\n<li>从远程库中克隆 <code>git clone https://github.com/xx</code></li>\n<li>创建dev分支 并切换到dev分支上 <code>git checkout –b dev</code></li>\n<li>查看当前所有的分支 <code>git branch</code></li>\n<li>切换回master分支 <code>git checkout master</code></li>\n<li>在当前的分支上合并dev分支 <code>git merge dev</code></li>\n<li>删除dev分支 <code>git branch –d dev</code></li>\n<li>创建分支 <code>git branch name</code></li>\n<li>把当前的工作隐藏起来 等以后恢复现场后继续工作 <code>git stash</code></li>\n<li>查看所有被隐藏的文件列表<code>git stash list</code></li>\n<li>恢复被隐藏的文件，但是内容不删除<code>git stash apply</code></li>\n<li>删除被隐藏文件 <code>git stash drop</code></li>\n<li>恢复文件的同时 也删除文件 <code>git stash pop</code></li>\n<li>查看远程库的信息<code>git remote</code></li>\n<li>查看远程库的详细信息 <code>git remote –v</code></li>\n<li>把master分支推送到远程库对应的远程分支上 <code>git push origin master</code></li>\n<li>把分支推送到远程的分支<code>git push origin develop</code>或者<code>git push origin 本地分支名:远程分支名</code></li>\n</ul>\n<h2 id=\"常见问题-持续更新\"><a href=\"#常见问题-持续更新\" class=\"headerlink\" title=\"常见问题(持续更新)\"></a>常见问题(持续更新)</h2><p>问题1<br><img src=\"http://tutorialspots.com/wp-content/uploads/2016/10/Another-git-process-seems-to-be-running-in-this-repository.jpg\" alt=\"\"><br>解决方法：执行<code>rm .git/index.lock</code></p>\n<p>问题2<br>在git pull代码的时候，可能会遇到这个问题<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: Your <span class=\"built_in\">local</span> changes to the following files would be overwritten by merge:</div><div class=\"line\">    xxx/xxx/xxx.php</div><div class=\"line\">Please, commit your changes or stash them before you can merge.</div><div class=\"line\">Aborting</div></pre></td></tr></table></figure></p>\n<p>出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。</p>\n<p><strong>保留本地的修改 的改法</strong><br>1）直接commit本地的修改<br>2）通过<code>git stash</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git stash</div><div class=\"line\">git pull</div><div class=\"line\">git stash pop</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;通过<code>git stash</code>将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash</code>: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。<br><code>git stash pop</code>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash list</code>: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。<br>&ensp;&ensp;&ensp;&ensp;<code>git stash clear</code>: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</p>\n<p><strong>放弃本地修改 的改法</strong><br><code>git reset --hard</code><br><code>git pull</code></p>\n<p>问题3<br><img src=\"http://images2015.cnblogs.com/blog/630011/201603/630011-20160315120522896-1718649799.jpg\" alt=\"\"><br>git 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:<br>1.按键盘字母 i 进入insert模式<br>2.修改最上面那行黄色合并信息,可以不修改<br>3.按键盘左上角”Esc”<br>4.输入”:wq”,注意是冒号+wq,按回车键即可</p>\n<p>问题4<br><code>git pull</code>的时候，可能会遇到下面的报错<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">remote: Counting objects: 369, done.  </div><div class=\"line\">efrror: RPC failed; result=56, HTTP code = 200  </div><div class=\"line\">atal: The remote end hung up unexpectedly  </div><div class=\"line\">fatal: protocol error: bad pack header</div></pre></td></tr></table></figure></p>\n<p><strong>解决方法</strong><br>依次输入以下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git config --global pack.windowMemory <span class=\"string\">\"100m\"</span>  </div><div class=\"line\">git config --global pack.SizeLimit <span class=\"string\">\"100m\"</span>  </div><div class=\"line\">git config --global pack.threads <span class=\"string\">\"1\"</span></div></pre></td></tr></table></figure></p>\n<p>问题5<br>git clone的时候，可能会遇到这个报错，很烦人</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">akagi201@akgentoo ~/a20-kernel (master*) $ git config http.postBuffer 5024288000</div><div class=\"line\">akagi201@akgentoo ~/a20-kernel (master*) $ git submodule update</div><div class=\"line\">Cloning into <span class=\"string\">'linux-sunxi'</span>...</div><div class=\"line\">remote: Counting objects: 4022357, done.</div><div class=\"line\">remote: Compressing objects: 100% (682462/682462), done.</div><div class=\"line\">error: RPC failed; result=18, HTTP code = 200.31 MiB | 654.00 KiB/s</div><div class=\"line\">fatal: The remote end hung up unexpectedly</div><div class=\"line\">fatal: early EOF</div><div class=\"line\">fatal: index-pack failed</div><div class=\"line\">Clone of <span class=\"string\">'https://github.com/linux-sunxi/linux-sunxi.git'</span> into submodule path <span class=\"string\">'linux-sunxi'</span> failed</div></pre></td></tr></table></figure>\n<p>解决方法：亲测有效</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> url --depth  1</div></pre></td></tr></table></figure>\n<p>比如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/xianyulaodi/express-study.git --depth  1</div></pre></td></tr></table></figure></p>\n<p>问题6<br>git pull的时候，可能会遇到如下报错</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git pull</div><div class=\"line\">error: You have not concluded your merge (MERGE_HEAD exists).</div><div class=\"line\">hint: Please, commit your changes before merging.</div><div class=\"line\">fatal: Exiting because of unfinished merge.</div></pre></td></tr></table></figure>\n<p>错误可能是因为在你以前pull下来的代码没有自动合并导致的.<br>有2个解决办法:</p>\n<ol>\n<li><p>保留你本地的修改<br><code>git merge --abort</code><br><code>git reset --merge</code><br><code>git commit xxx -m &quot;注释&quot;</code>  合并后记得一定要提交这个本地的合并<br><code>git pull</code></p>\n</li>\n<li><p>抛弃本地的修改<br>不建议这样做,但是如果你本地修改不大,或者自己有一份备份留存,可以直接用线上最新版本覆盖到本地<br><code>git fetch --all</code><br><code>git reset --hard origin/master</code><br><code>git fetch</code></p>\n</li>\n</ol>"},{"title":"nodejs之path模块","date":"2017-05-07T10:50:00.000Z","_content":"&ensp;&ensp;&ensp;&ensp;path 模块是 node 用于整理、转换、合并路径的神器，只要是路径问题，都可以交给它处理。但它仅仅是处理路径字符串，而不会去坚持或处理文件。\n\n<!-- more -->\n\n### 格式化路径 path.normalize(p);\n作用：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n```javascript\nvar path = require('path');\npath.normalize('/foo/bar//baz/asdf/quux/..');\n //==>  '/foo/bar/baz/asdf'\n```\n\n### 路径合并 path.join([path1], [path2], […]);\n作用：将所有名称用path.seq串联起来，然后用normailze格式化，规范化的路径字符串。\n```javascript\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n//==>  '/foo/bar/baz/asdf'\n```\n\n### 绝对路径 path.resolve([from …], to);\n作用：相当于不断的调用系统的cd命令\n```javascript\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n//相当于：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n```\n\n### 相对路径 path.relative(from, to);\n作用： 返回某个路径下相对于另一个路径的相对位置串.\n```javascript\n/**\n * from 当前路径，并且方法返回值是基于from指定到to的相对路径\n * to   到哪路径，\n */\nvar from = 'c:\\\\from\\\\a\\\\',\n    to = 'c:/test/b';\nvar _path = path.relative(from, to);\nconsole.log(_path); //..\\..\\test\\b; 表示从from到to的相对路径\n```\n\n## 文件路径 path.dirname\n作用： 根据一个文件或目录得到它所在的目录路径，这个很常用。\n```javascript\nvar myPath = path.dirname(__dirname + '/test/util you.mp3');\nconsole.log(myPath);   // E:/doc/test/util you.mp3\n```\n\n## 文件名称 path.basename(p, [ext]);\n作用： 返回最后一个路径分割后面的文件名，不论是文件还是目录，第二个参数可以忽略文件后缀。\n```javascript\nvar str = path.basename('path/upload/file/123.jpg');\nconsole.log(str); // 123.jpg\nvar str = path.basename('path/upload/file/123.jpg', '.jpg');\nconsole.log(str); // 123\n```\n\n## 文件扩展名 path.extname(path);\n作用：返回最后一个 . 之后的字符串，没有则返回空。\n```javascript\nvar str = path.extname('path/file/abc.txt');\nconsole.log(str); // '.txt'\n\nvar str = path.extname('path/file/abc.');\nconsole.log(str); // '.'\n\nvar str = path.extname('path/upload/file/');\nconsole.log(str); // ''\n```\n\n## 解析路径 path.parse\n作用：把一个路径解析为一个 `{root:'', dir:'', base:'', ext:'', name:''}` 这样的对象。\n```javascript\npath.parse('/home/user/dir/file.txt')\n// returns\n{\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n}\n// windows\npath.parse('C:\\\\path\\\\dir\\\\index.html')\n// returns\n{\n    root : \"C:\\\\\",\n    dir : \"C:\\\\path\\\\dir\",\n    base : \"index.html\",\n    ext : \".html\",\n    name : \"index\"\n}\n```\n\n## 生成路径 path.format\n作用：跟 `path.parse` 相反，这个则是根据 `{root:'', dir:'', base:'', ext:'', name:''}` 这样的对象来生成字符串\n```javascript\npath.format({\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n})\n// returns\n'/home/user/dir/file.txt'\n```\n","source":"_posts/nodejs之path模块.md","raw":"---\ntitle: nodejs之path模块\ndate: 2017-05-07 18:50\ncategories:\ntags:\n     - path\n     - node\n---\n&ensp;&ensp;&ensp;&ensp;path 模块是 node 用于整理、转换、合并路径的神器，只要是路径问题，都可以交给它处理。但它仅仅是处理路径字符串，而不会去坚持或处理文件。\n\n<!-- more -->\n\n### 格式化路径 path.normalize(p);\n作用：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断\n```javascript\nvar path = require('path');\npath.normalize('/foo/bar//baz/asdf/quux/..');\n //==>  '/foo/bar/baz/asdf'\n```\n\n### 路径合并 path.join([path1], [path2], […]);\n作用：将所有名称用path.seq串联起来，然后用normailze格式化，规范化的路径字符串。\n```javascript\npath.join('///foo', 'bar', '//baz/asdf', 'quux', '..');\n//==>  '/foo/bar/baz/asdf'\n```\n\n### 绝对路径 path.resolve([from …], to);\n作用：相当于不断的调用系统的cd命令\n```javascript\npath.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n//相当于：\n// cd foo/bar\n// cd /tmp/file/\n// cd ..\n// cd a/../subfile\n// pwd\n```\n\n### 相对路径 path.relative(from, to);\n作用： 返回某个路径下相对于另一个路径的相对位置串.\n```javascript\n/**\n * from 当前路径，并且方法返回值是基于from指定到to的相对路径\n * to   到哪路径，\n */\nvar from = 'c:\\\\from\\\\a\\\\',\n    to = 'c:/test/b';\nvar _path = path.relative(from, to);\nconsole.log(_path); //..\\..\\test\\b; 表示从from到to的相对路径\n```\n\n## 文件路径 path.dirname\n作用： 根据一个文件或目录得到它所在的目录路径，这个很常用。\n```javascript\nvar myPath = path.dirname(__dirname + '/test/util you.mp3');\nconsole.log(myPath);   // E:/doc/test/util you.mp3\n```\n\n## 文件名称 path.basename(p, [ext]);\n作用： 返回最后一个路径分割后面的文件名，不论是文件还是目录，第二个参数可以忽略文件后缀。\n```javascript\nvar str = path.basename('path/upload/file/123.jpg');\nconsole.log(str); // 123.jpg\nvar str = path.basename('path/upload/file/123.jpg', '.jpg');\nconsole.log(str); // 123\n```\n\n## 文件扩展名 path.extname(path);\n作用：返回最后一个 . 之后的字符串，没有则返回空。\n```javascript\nvar str = path.extname('path/file/abc.txt');\nconsole.log(str); // '.txt'\n\nvar str = path.extname('path/file/abc.');\nconsole.log(str); // '.'\n\nvar str = path.extname('path/upload/file/');\nconsole.log(str); // ''\n```\n\n## 解析路径 path.parse\n作用：把一个路径解析为一个 `{root:'', dir:'', base:'', ext:'', name:''}` 这样的对象。\n```javascript\npath.parse('/home/user/dir/file.txt')\n// returns\n{\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n}\n// windows\npath.parse('C:\\\\path\\\\dir\\\\index.html')\n// returns\n{\n    root : \"C:\\\\\",\n    dir : \"C:\\\\path\\\\dir\",\n    base : \"index.html\",\n    ext : \".html\",\n    name : \"index\"\n}\n```\n\n## 生成路径 path.format\n作用：跟 `path.parse` 相反，这个则是根据 `{root:'', dir:'', base:'', ext:'', name:''}` 这样的对象来生成字符串\n```javascript\npath.format({\n    root : \"/\",\n    dir : \"/home/user/dir\",\n    base : \"file.txt\",\n    ext : \".txt\",\n    name : \"file\"\n})\n// returns\n'/home/user/dir/file.txt'\n```\n","slug":"nodejs之path模块","published":1,"updated":"2017-05-09T15:25:04.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr6700089gscba5rxndr","content":"<p>&ensp;&ensp;&ensp;&ensp;path 模块是 node 用于整理、转换、合并路径的神器，只要是路径问题，都可以交给它处理。但它仅仅是处理路径字符串，而不会去坚持或处理文件。</p>\n<a id=\"more\"></a>\n<h3 id=\"格式化路径-path-normalize-p\"><a href=\"#格式化路径-path-normalize-p\" class=\"headerlink\" title=\"格式化路径 path.normalize(p);\"></a>格式化路径 path.normalize(p);</h3><p>作用：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</div><div class=\"line\"> <span class=\"comment\">//==&gt;  '/foo/bar/baz/asdf'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"路径合并-path-join-path1-path2-…\"><a href=\"#路径合并-path-join-path1-path2-…\" class=\"headerlink\" title=\"路径合并 path.join([path1], [path2], […]);\"></a>路径合并 path.join([path1], [path2], […]);</h3><p>作用：将所有名称用path.seq串联起来，然后用normailze格式化，规范化的路径字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</div><div class=\"line\"><span class=\"comment\">//==&gt;  '/foo/bar/baz/asdf'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"绝对路径-path-resolve-from-…-to\"><a href=\"#绝对路径-path-resolve-from-…-to\" class=\"headerlink\" title=\"绝对路径 path.resolve([from …], to);\"></a>绝对路径 path.resolve([from …], to);</h3><p>作用：相当于不断的调用系统的cd命令<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>)</div><div class=\"line\"><span class=\"comment\">//相当于：</span></div><div class=\"line\"><span class=\"comment\">// cd foo/bar</span></div><div class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></div><div class=\"line\"><span class=\"comment\">// cd ..</span></div><div class=\"line\"><span class=\"comment\">// cd a/../subfile</span></div><div class=\"line\"><span class=\"comment\">// pwd</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"相对路径-path-relative-from-to\"><a href=\"#相对路径-path-relative-from-to\" class=\"headerlink\" title=\"相对路径 path.relative(from, to);\"></a>相对路径 path.relative(from, to);</h3><p>作用： 返回某个路径下相对于另一个路径的相对位置串.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * from 当前路径，并且方法返回值是基于from指定到to的相对路径</div><div class=\"line\"> * to   到哪路径，</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">from</span> = <span class=\"string\">'c:\\\\from\\\\a\\\\'</span>,</div><div class=\"line\">    to = <span class=\"string\">'c:/test/b'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> _path = path.relative(<span class=\"keyword\">from</span>, to);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(_path); <span class=\"comment\">//..\\..\\test\\b; 表示从from到to的相对路径</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件路径-path-dirname\"><a href=\"#文件路径-path-dirname\" class=\"headerlink\" title=\"文件路径 path.dirname\"></a>文件路径 path.dirname</h2><p>作用： 根据一个文件或目录得到它所在的目录路径，这个很常用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myPath = path.dirname(__dirname + <span class=\"string\">'/test/util you.mp3'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(myPath);   <span class=\"comment\">// E:/doc/test/util you.mp3</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件名称-path-basename-p-ext\"><a href=\"#文件名称-path-basename-p-ext\" class=\"headerlink\" title=\"文件名称 path.basename(p, [ext]);\"></a>文件名称 path.basename(p, [ext]);</h2><p>作用： 返回最后一个路径分割后面的文件名，不论是文件还是目录，第二个参数可以忽略文件后缀。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = path.basename(<span class=\"string\">'path/upload/file/123.jpg'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123.jpg</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.basename(<span class=\"string\">'path/upload/file/123.jpg'</span>, <span class=\"string\">'.jpg'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件扩展名-path-extname-path\"><a href=\"#文件扩展名-path-extname-path\" class=\"headerlink\" title=\"文件扩展名 path.extname(path);\"></a>文件扩展名 path.extname(path);</h2><p>作用：返回最后一个 . 之后的字符串，没有则返回空。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/file/abc.txt'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// '.txt'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/file/abc.'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// '.'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/upload/file/'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// ''</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"解析路径-path-parse\"><a href=\"#解析路径-path-parse\" class=\"headerlink\" title=\"解析路径 path.parse\"></a>解析路径 path.parse</h2><p>作用：把一个路径解析为一个 <code>{root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;}</code> 这样的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.parse(<span class=\"string\">'/home/user/dir/file.txt'</span>)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"/\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"/home/user/dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"file.txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"file\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// windows</span></div><div class=\"line\">path.parse(<span class=\"string\">'C:\\\\path\\\\dir\\\\index.html'</span>)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"C:\\\\\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"C:\\\\path\\\\dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"index.html\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".html\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"index\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"生成路径-path-format\"><a href=\"#生成路径-path-format\" class=\"headerlink\" title=\"生成路径 path.format\"></a>生成路径 path.format</h2><p>作用：跟 <code>path.parse</code> 相反，这个则是根据 <code>{root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;}</code> 这样的对象来生成字符串<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.format(&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"/\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"/home/user/dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"file.txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"file\"</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\"><span class=\"string\">'/home/user/dir/file.txt'</span></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;&ensp;&ensp;path 模块是 node 用于整理、转换、合并路径的神器，只要是路径问题，都可以交给它处理。但它仅仅是处理路径字符串，而不会去坚持或处理文件。</p>","more":"<h3 id=\"格式化路径-path-normalize-p\"><a href=\"#格式化路径-path-normalize-p\" class=\"headerlink\" title=\"格式化路径 path.normalize(p);\"></a>格式化路径 path.normalize(p);</h3><p>作用：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</div><div class=\"line\">path.normalize(<span class=\"string\">'/foo/bar//baz/asdf/quux/..'</span>);</div><div class=\"line\"> <span class=\"comment\">//==&gt;  '/foo/bar/baz/asdf'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"路径合并-path-join-path1-path2-…\"><a href=\"#路径合并-path-join-path1-path2-…\" class=\"headerlink\" title=\"路径合并 path.join([path1], [path2], […]);\"></a>路径合并 path.join([path1], [path2], […]);</h3><p>作用：将所有名称用path.seq串联起来，然后用normailze格式化，规范化的路径字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.join(<span class=\"string\">'///foo'</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'//baz/asdf'</span>, <span class=\"string\">'quux'</span>, <span class=\"string\">'..'</span>);</div><div class=\"line\"><span class=\"comment\">//==&gt;  '/foo/bar/baz/asdf'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"绝对路径-path-resolve-from-…-to\"><a href=\"#绝对路径-path-resolve-from-…-to\" class=\"headerlink\" title=\"绝对路径 path.resolve([from …], to);\"></a>绝对路径 path.resolve([from …], to);</h3><p>作用：相当于不断的调用系统的cd命令<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.resolve(<span class=\"string\">'foo/bar'</span>, <span class=\"string\">'/tmp/file/'</span>, <span class=\"string\">'..'</span>, <span class=\"string\">'a/../subfile'</span>)</div><div class=\"line\"><span class=\"comment\">//相当于：</span></div><div class=\"line\"><span class=\"comment\">// cd foo/bar</span></div><div class=\"line\"><span class=\"comment\">// cd /tmp/file/</span></div><div class=\"line\"><span class=\"comment\">// cd ..</span></div><div class=\"line\"><span class=\"comment\">// cd a/../subfile</span></div><div class=\"line\"><span class=\"comment\">// pwd</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"相对路径-path-relative-from-to\"><a href=\"#相对路径-path-relative-from-to\" class=\"headerlink\" title=\"相对路径 path.relative(from, to);\"></a>相对路径 path.relative(from, to);</h3><p>作用： 返回某个路径下相对于另一个路径的相对位置串.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * from 当前路径，并且方法返回值是基于from指定到to的相对路径</div><div class=\"line\"> * to   到哪路径，</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">from</span> = <span class=\"string\">'c:\\\\from\\\\a\\\\'</span>,</div><div class=\"line\">    to = <span class=\"string\">'c:/test/b'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> _path = path.relative(<span class=\"keyword\">from</span>, to);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(_path); <span class=\"comment\">//..\\..\\test\\b; 表示从from到to的相对路径</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件路径-path-dirname\"><a href=\"#文件路径-path-dirname\" class=\"headerlink\" title=\"文件路径 path.dirname\"></a>文件路径 path.dirname</h2><p>作用： 根据一个文件或目录得到它所在的目录路径，这个很常用。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> myPath = path.dirname(__dirname + <span class=\"string\">'/test/util you.mp3'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(myPath);   <span class=\"comment\">// E:/doc/test/util you.mp3</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件名称-path-basename-p-ext\"><a href=\"#文件名称-path-basename-p-ext\" class=\"headerlink\" title=\"文件名称 path.basename(p, [ext]);\"></a>文件名称 path.basename(p, [ext]);</h2><p>作用： 返回最后一个路径分割后面的文件名，不论是文件还是目录，第二个参数可以忽略文件后缀。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = path.basename(<span class=\"string\">'path/upload/file/123.jpg'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123.jpg</span></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.basename(<span class=\"string\">'path/upload/file/123.jpg'</span>, <span class=\"string\">'.jpg'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// 123</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"文件扩展名-path-extname-path\"><a href=\"#文件扩展名-path-extname-path\" class=\"headerlink\" title=\"文件扩展名 path.extname(path);\"></a>文件扩展名 path.extname(path);</h2><p>作用：返回最后一个 . 之后的字符串，没有则返回空。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/file/abc.txt'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// '.txt'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/file/abc.'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// '.'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = path.extname(<span class=\"string\">'path/upload/file/'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">// ''</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"解析路径-path-parse\"><a href=\"#解析路径-path-parse\" class=\"headerlink\" title=\"解析路径 path.parse\"></a>解析路径 path.parse</h2><p>作用：把一个路径解析为一个 <code>{root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;}</code> 这样的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.parse(<span class=\"string\">'/home/user/dir/file.txt'</span>)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"/\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"/home/user/dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"file.txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"file\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// windows</span></div><div class=\"line\">path.parse(<span class=\"string\">'C:\\\\path\\\\dir\\\\index.html'</span>)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"C:\\\\\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"C:\\\\path\\\\dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"index.html\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".html\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"index\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"生成路径-path-format\"><a href=\"#生成路径-path-format\" class=\"headerlink\" title=\"生成路径 path.format\"></a>生成路径 path.format</h2><p>作用：跟 <code>path.parse</code> 相反，这个则是根据 <code>{root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;}</code> 这样的对象来生成字符串<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">path.format(&#123;</div><div class=\"line\">    <span class=\"attr\">root</span> : <span class=\"string\">\"/\"</span>,</div><div class=\"line\">    <span class=\"attr\">dir</span> : <span class=\"string\">\"/home/user/dir\"</span>,</div><div class=\"line\">    <span class=\"attr\">base</span> : <span class=\"string\">\"file.txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">ext</span> : <span class=\"string\">\".txt\"</span>,</div><div class=\"line\">    <span class=\"attr\">name</span> : <span class=\"string\">\"file\"</span></div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// returns</span></div><div class=\"line\"><span class=\"string\">'/home/user/dir/file.txt'</span></div></pre></td></tr></table></figure></p>"},{"title":"node核心模块--fs","date":"2017-04-18T15:17:00.000Z","_content":"\n\n## 文件系统fs-简介\n> fs模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其它模块不同的是，fs模块中所有的操作都提供了`异步`和`同步`的两个版本。\n\n<!-- more -->\n\n# 一、文件读取--完整性读写  \n---\n## 1、fs.readFile\n `fs.readFile(filename,[encoding],[callback(error,data)]`是最简单的文件读取函数，它接受一个必选参数filename，表示读取的文件名。\n    第二个参数encoding是可选的，表示文件字符编码。callback是回调函数，用于接收文件的内容。如果不指定encoding，则callback就是第二个参数。\n 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。\n 如果指定encoding，data是一个解析后的字符串，否则将会以Buffer形式表示的二进制数据。\n\n**demo1**\n```javascript\nconst fs = require('fs');\nfs.readFile('./file/readFile.txt','utf8', function(err, data) {\n    if (err) {\n        throw err;\n    }\n    // 读取文件成功\n    console.log('异步测试： -->'+data);\n});\n//同步\nvar data=fs.readFileSync('./file/readFile.txt','utf-8');\nconsole.log('同步测试：-->'+data);\n```\n\n## 2、fs.writeFile\n`fs.writeFile(filename,data,[options],callback)`用来写文件，其中options为对象，有以下几个值：\n```JSON\nencoding {String | null} default='utf-8'\nmode {Number} default=438(aka 0666 in Octal)\nflag {String} default='w'\n```\n这里主要flag值，默认为w,会清空文件，然后再写。flag值，`r代表读取文件`，`w代表写文件`，`a代表追加。`\n\n**demo2**\n```javascript\nconst fs = require('fs');\n// 写入文件内容（如果文件不存在会创建一个文件）\n// 写入时会先清空文件\nfs.writeFile('./file/writeFile.txt', '写入成功：hello world', function(err) {\n    if (err) {\n        throw err;\n    }\n    // 写入成功后读取测试\n    var data=fs.readFileSync('./file/writeFile.txt', 'utf-8');\n    console.log('new data -->'+data);\n});\n\n// 数据追加\nsetTimeout(function(){\n\t// 追加\n\tfs.writeFile('./file/writeFile.txt', '这里是追加的数据', {'flag':'a'},function(err) {\n\t    if (err) {\n\t        throw err;\n\t    }\n\t    console.log('success');\n\t    var data=fs.readFileSync('./file/writeFile.txt', 'utf-8')\n\t    // 写入成功后读取测试\n\t    console.log('追加后的数据 -->'+data);\n\t});\n},1000);\n```\n\n## 3、fs.appendFile\n`fs.appendFile(filename, data, [options], callback)`该方法以异步的方式将 data 插入到文件里，如果文件不存在会自动创建。data可以是任意字符串或者缓存。\n与`fs.writeFile` 方法差别就是 [options]的flag默认值是\"a\"，所以它以追加方式写入数据.\n**demo3**\n```javascript\nconst fs = require('fs');\n// 写入文件内容（如果文件不存在会创建一个文件）\nfs.appendFile('./file/appendFile.txt', '新数据456', function(err) {\n    if (err) {\n        throw err;\n    }\n    // 写入成功后读取测试\n    var data=fs.readFileSync('./file/appendFile.txt', 'utf-8');\n    console.log(data);\n});\n```\n\n## 4、删除文件 unlink\n比较简单，没啥好说的，直接上demo\n\n**demo4**\n```javascript\nconst fs =require('fs');\nfs.unlink('./file/unlink.txt',function(err){\n\tif(err) return;\n\tconsole.log('成功删除了unlink.txt这个文件');\n});\n```\n# 二、文件读取-指定位置读写\n---\n&ensp;&ensp;这个跟上面的过程相比，流程稍微麻烦一点点，要先用fs.open来打开文件，然后才可以用fs.read去读，或者用fs.write去写文件，最后，你需要用fs.close去关掉文件。\n## 1、fs.open\n用法：`fs.open(path,flags,[mode],callback)`\n* path 文件路径\n* flags打开文件的方式<br/>\n  flags部分值为(没全部列出，需要的话去查即可)：<br/>\n  `r:以读取模式打开文件`<br/>\n  `r+：以读写模式`<br/>\n  `w：以写入模式打开，如果不存在则创建`<br/>\n  `w+：以读写模式打开，如果不存在则创建`<br/>\n  `a:以追加模式打开文件，如果不存在则创建`<br/>\n  `a+:以读取追加模式打开文件，如果文件不存在则创建。`\n* [mode] 是文件的权限（可选参数，默认值是0666）\n* callback 回调函数\n**demo5**\n```javascript\nconst fs = require('fs');\nfs.open('./file/open.txt','r','0666',function(err,fd){\n   console.log(fd); //返回的第二个参数为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄\n})\n```\n\n## 2、fs.read\n用法`fs.read(fd, buffer, offset, length, position, callback);`\n* fd, 使用fs.open打开成功后返回的文件描述符\n* buffer, 一个Buffer对象，v8引擎分配的一段内存\n* offset, 整数，向缓存区中写入时的初始位置，以字节为单位\n* length, 整数，读取文件的长度\n* position, 整数，读取文件初始位置；文件大小以字节为单位\n* callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead:实际读取字节数，buffer:被读取的缓存区对象\n\n**demo6**\n```javascript\nfs.open('./file/open.txt', 'r', function (err, fd) {\n  if(err) {\n    return;\n\n  } else {\n\n    var buffer = new Buffer(255);\n    //每一个汉字utf8编码是3个字节，英文是1个字节\n    fs.read(fd, buffer, 0, 9, 0, function (err, bytesRead, buffer) {\n      if(err) {\n        throw err;\n      } else {\n        console.log(bytesRead);\n        console.log(buffer.slice(0, bytesRead).toString());  \n        //读取完后，再使用fd读取时，基点是基于上次读取位置计算；\n        fs.read(fd, buffer, 0, 20, null, function (err, bytesRead, buffer) {\n          console.log(bytesRead);\n          console.log(buffer.slice(0, bytesRead).toString());\n        });\n      }\n    });\n  }\n});\n```\n\n## 3、fs.write\n用法`fs.write(fd, buffer, offset, length, position, callback);`\n * fd, 使用fs.open打开成功后返回的文件描述符\n * buffer, 一个Buffer对象，v8引擎分配的一段内存\n * offset, 整数，从缓存区中读取时的初始位置，以字节为单位\n * length, 整数，从缓存区中读取数据的字节数\n * position, 整数，写入文件初始位置；\n * callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象\n\n**demo7**\n```javascript\nconst fs = require('fs');\n\nfs.open(__dirname + '/file/open.txt', 'a', function (err, fd) {\n  if(err) {\n    console.error(err);\n    return;\n  } else {\n    var buffer = new Buffer('写入文件数据内容');\n    //写入'入文件'三个字\n    fs.write(fd, buffer, 3, 9, 12, function (err, written, buffer) {\n      if(err) {\n        console.log('写入文件失败');\n        console.error(err);\n        return;\n      } else {\n        console.log(buffer.toString());\n        //写入'数据内'三个字\n        fs.write(fd, buffer, 12, 9, null, function (err, written, buffer) {\n          console.log(buffer.toString());\n        })\n      }\n    });\n  }\n});\n\n```\n\n## fs.close\n用法`fs.close(fd,callback) `\n* fd 文件open时传递的文件描述符\n* callback 回调函数\n\n# 三、目录操作\n---\n## 1、fs.mkdir创建目录\n** demo5**\n```javascript\nconst fs = require('fs');\nfs.mkdir('./mkdir',function(err){\n  if(err) return;\n  console.log('创建目录成功');\n})\n```\n## 2、fs.rmdir删除目录\n**demo8**\n```javascript\nconst fs = require('fs');\nfs.rmdir('./mkdir',function(err){\n  if(err) return;\n  console.log('删除目录成功');\n})\n```\n## 3、fs.readdir读取目录\n返回的data为一个数组，包含该文件夹的所有文件\n\n**demo9**\n```javascript\nconst fs = require('fs');\nfs.readdir('./file',function(err,data){\n  if(err) return;\n  //data为一个数组\n  console.log('读取的数据为：'+data[0]);\n});\n```\n# 四、链接文件操作\n---\n## 1、fs.link 创建一个链接\n`fs.link(srcpath, dstpath, [callback(err)])`\n* `srcpath`为源文件目录或文件的路径\n* `dstpath`为转换后的路径\n\n可以理解为复制了一份文件到另一个文件，比如下面的demo8,我们在file文件有一个link.txt，执行后，file文件里面生成了linkFile文件，而且两者的内容是一样的,或者说是源文件的备份\n\n#### 进一步理解\n`fs.link(srcpath, dstpath, [callback])`、和 `fs.symlink(linkdata, path, [callback])`\n建立文件链接，除非回调函数执行过程出现了异常，否则不会传递任何参数。link和symlink的区别是： link 创建的是`hard link` 所谓硬链接; symlink创建的是`symbolic link` 所谓符号链接 硬链接就是备份，软连接就是快捷方式\n\n**demo10**\n```javascript\nconst fs = require('fs');\nfs.link('./file/link.txt','./file/linkFile.txt',function(err){\n   if(err) return;\n})\n```\n## fs.readlink、fs.realpath、fs.unlink\n* `fs.readlink(path, [callback])` 读取链接源地址,**注意**：读取的是软连接中的实际中文名，也就是symlink设置的软连接\n* `fs.realpath(path, [callback])` 获取当前目录或者文件的绝对路径\n* `fs.unlink(path, [callback])`  删除某一个文件链接(删除的是硬链接)\n\n**demo11**\n```javascript\nconst fs = require('fs');\n// readlink\nfs.readlink('./file/link2.txt',function(err,data){\n   console.log(data); //.\\file\\link.txt  返回创建它的软链接,这里，link2是由link创建的软链接\n});\n\n// realpath\nfs.realpath('./file/linkFile.txt', function (err, resolvedPath) {\n  if (err) throw err;\n  console.log(resolvedPath);\n  //F:\\myFile\\express\\express-study\\fs\\fsTest\\file\\linkFile.txt  返回绝对路径\n});\n\n```\n\n# 五、watchfile()，unwatchfile()\nwatchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。\n\n**demo12**\n```javascript\nvar fs = require('fs');\n\nfs.watchFile('./testFile.txt', function (curr, prev) {\n  console.log('the current mtime is: ' + curr.mtime);\n  console.log('the previous mtime was: ' + prev.mtime);\n});\n\nfs.writeFile('./testFile.txt', \"changed\", function (err) {\n  if (err) throw err;\n\n  console.log(\"file write complete\");   \n});\n```\nunwatchfile方法用于解除对文件的监听。\n<br />\n<br />\n<br />\n&ensp;&ensp;&ensp;后记,当然,fs的方法不止上面我列的这些，其他需要用到的话还需要去查。另外，有一个 `fs-extra`模块也不错，扩展了fs的一些方法。可以去查查\n","source":"_posts/node核心模块--fs.md","raw":"---\ntitle: node核心模块--fs\ndate: 2017-04-18 23:17\ncategories:\ntags:\n     - fs\n     - node\n---\n\n\n## 文件系统fs-简介\n> fs模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其它模块不同的是，fs模块中所有的操作都提供了`异步`和`同步`的两个版本。\n\n<!-- more -->\n\n# 一、文件读取--完整性读写  \n---\n## 1、fs.readFile\n `fs.readFile(filename,[encoding],[callback(error,data)]`是最简单的文件读取函数，它接受一个必选参数filename，表示读取的文件名。\n    第二个参数encoding是可选的，表示文件字符编码。callback是回调函数，用于接收文件的内容。如果不指定encoding，则callback就是第二个参数。\n 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。\n 如果指定encoding，data是一个解析后的字符串，否则将会以Buffer形式表示的二进制数据。\n\n**demo1**\n```javascript\nconst fs = require('fs');\nfs.readFile('./file/readFile.txt','utf8', function(err, data) {\n    if (err) {\n        throw err;\n    }\n    // 读取文件成功\n    console.log('异步测试： -->'+data);\n});\n//同步\nvar data=fs.readFileSync('./file/readFile.txt','utf-8');\nconsole.log('同步测试：-->'+data);\n```\n\n## 2、fs.writeFile\n`fs.writeFile(filename,data,[options],callback)`用来写文件，其中options为对象，有以下几个值：\n```JSON\nencoding {String | null} default='utf-8'\nmode {Number} default=438(aka 0666 in Octal)\nflag {String} default='w'\n```\n这里主要flag值，默认为w,会清空文件，然后再写。flag值，`r代表读取文件`，`w代表写文件`，`a代表追加。`\n\n**demo2**\n```javascript\nconst fs = require('fs');\n// 写入文件内容（如果文件不存在会创建一个文件）\n// 写入时会先清空文件\nfs.writeFile('./file/writeFile.txt', '写入成功：hello world', function(err) {\n    if (err) {\n        throw err;\n    }\n    // 写入成功后读取测试\n    var data=fs.readFileSync('./file/writeFile.txt', 'utf-8');\n    console.log('new data -->'+data);\n});\n\n// 数据追加\nsetTimeout(function(){\n\t// 追加\n\tfs.writeFile('./file/writeFile.txt', '这里是追加的数据', {'flag':'a'},function(err) {\n\t    if (err) {\n\t        throw err;\n\t    }\n\t    console.log('success');\n\t    var data=fs.readFileSync('./file/writeFile.txt', 'utf-8')\n\t    // 写入成功后读取测试\n\t    console.log('追加后的数据 -->'+data);\n\t});\n},1000);\n```\n\n## 3、fs.appendFile\n`fs.appendFile(filename, data, [options], callback)`该方法以异步的方式将 data 插入到文件里，如果文件不存在会自动创建。data可以是任意字符串或者缓存。\n与`fs.writeFile` 方法差别就是 [options]的flag默认值是\"a\"，所以它以追加方式写入数据.\n**demo3**\n```javascript\nconst fs = require('fs');\n// 写入文件内容（如果文件不存在会创建一个文件）\nfs.appendFile('./file/appendFile.txt', '新数据456', function(err) {\n    if (err) {\n        throw err;\n    }\n    // 写入成功后读取测试\n    var data=fs.readFileSync('./file/appendFile.txt', 'utf-8');\n    console.log(data);\n});\n```\n\n## 4、删除文件 unlink\n比较简单，没啥好说的，直接上demo\n\n**demo4**\n```javascript\nconst fs =require('fs');\nfs.unlink('./file/unlink.txt',function(err){\n\tif(err) return;\n\tconsole.log('成功删除了unlink.txt这个文件');\n});\n```\n# 二、文件读取-指定位置读写\n---\n&ensp;&ensp;这个跟上面的过程相比，流程稍微麻烦一点点，要先用fs.open来打开文件，然后才可以用fs.read去读，或者用fs.write去写文件，最后，你需要用fs.close去关掉文件。\n## 1、fs.open\n用法：`fs.open(path,flags,[mode],callback)`\n* path 文件路径\n* flags打开文件的方式<br/>\n  flags部分值为(没全部列出，需要的话去查即可)：<br/>\n  `r:以读取模式打开文件`<br/>\n  `r+：以读写模式`<br/>\n  `w：以写入模式打开，如果不存在则创建`<br/>\n  `w+：以读写模式打开，如果不存在则创建`<br/>\n  `a:以追加模式打开文件，如果不存在则创建`<br/>\n  `a+:以读取追加模式打开文件，如果文件不存在则创建。`\n* [mode] 是文件的权限（可选参数，默认值是0666）\n* callback 回调函数\n**demo5**\n```javascript\nconst fs = require('fs');\nfs.open('./file/open.txt','r','0666',function(err,fd){\n   console.log(fd); //返回的第二个参数为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄\n})\n```\n\n## 2、fs.read\n用法`fs.read(fd, buffer, offset, length, position, callback);`\n* fd, 使用fs.open打开成功后返回的文件描述符\n* buffer, 一个Buffer对象，v8引擎分配的一段内存\n* offset, 整数，向缓存区中写入时的初始位置，以字节为单位\n* length, 整数，读取文件的长度\n* position, 整数，读取文件初始位置；文件大小以字节为单位\n* callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead:实际读取字节数，buffer:被读取的缓存区对象\n\n**demo6**\n```javascript\nfs.open('./file/open.txt', 'r', function (err, fd) {\n  if(err) {\n    return;\n\n  } else {\n\n    var buffer = new Buffer(255);\n    //每一个汉字utf8编码是3个字节，英文是1个字节\n    fs.read(fd, buffer, 0, 9, 0, function (err, bytesRead, buffer) {\n      if(err) {\n        throw err;\n      } else {\n        console.log(bytesRead);\n        console.log(buffer.slice(0, bytesRead).toString());  \n        //读取完后，再使用fd读取时，基点是基于上次读取位置计算；\n        fs.read(fd, buffer, 0, 20, null, function (err, bytesRead, buffer) {\n          console.log(bytesRead);\n          console.log(buffer.slice(0, bytesRead).toString());\n        });\n      }\n    });\n  }\n});\n```\n\n## 3、fs.write\n用法`fs.write(fd, buffer, offset, length, position, callback);`\n * fd, 使用fs.open打开成功后返回的文件描述符\n * buffer, 一个Buffer对象，v8引擎分配的一段内存\n * offset, 整数，从缓存区中读取时的初始位置，以字节为单位\n * length, 整数，从缓存区中读取数据的字节数\n * position, 整数，写入文件初始位置；\n * callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象\n\n**demo7**\n```javascript\nconst fs = require('fs');\n\nfs.open(__dirname + '/file/open.txt', 'a', function (err, fd) {\n  if(err) {\n    console.error(err);\n    return;\n  } else {\n    var buffer = new Buffer('写入文件数据内容');\n    //写入'入文件'三个字\n    fs.write(fd, buffer, 3, 9, 12, function (err, written, buffer) {\n      if(err) {\n        console.log('写入文件失败');\n        console.error(err);\n        return;\n      } else {\n        console.log(buffer.toString());\n        //写入'数据内'三个字\n        fs.write(fd, buffer, 12, 9, null, function (err, written, buffer) {\n          console.log(buffer.toString());\n        })\n      }\n    });\n  }\n});\n\n```\n\n## fs.close\n用法`fs.close(fd,callback) `\n* fd 文件open时传递的文件描述符\n* callback 回调函数\n\n# 三、目录操作\n---\n## 1、fs.mkdir创建目录\n** demo5**\n```javascript\nconst fs = require('fs');\nfs.mkdir('./mkdir',function(err){\n  if(err) return;\n  console.log('创建目录成功');\n})\n```\n## 2、fs.rmdir删除目录\n**demo8**\n```javascript\nconst fs = require('fs');\nfs.rmdir('./mkdir',function(err){\n  if(err) return;\n  console.log('删除目录成功');\n})\n```\n## 3、fs.readdir读取目录\n返回的data为一个数组，包含该文件夹的所有文件\n\n**demo9**\n```javascript\nconst fs = require('fs');\nfs.readdir('./file',function(err,data){\n  if(err) return;\n  //data为一个数组\n  console.log('读取的数据为：'+data[0]);\n});\n```\n# 四、链接文件操作\n---\n## 1、fs.link 创建一个链接\n`fs.link(srcpath, dstpath, [callback(err)])`\n* `srcpath`为源文件目录或文件的路径\n* `dstpath`为转换后的路径\n\n可以理解为复制了一份文件到另一个文件，比如下面的demo8,我们在file文件有一个link.txt，执行后，file文件里面生成了linkFile文件，而且两者的内容是一样的,或者说是源文件的备份\n\n#### 进一步理解\n`fs.link(srcpath, dstpath, [callback])`、和 `fs.symlink(linkdata, path, [callback])`\n建立文件链接，除非回调函数执行过程出现了异常，否则不会传递任何参数。link和symlink的区别是： link 创建的是`hard link` 所谓硬链接; symlink创建的是`symbolic link` 所谓符号链接 硬链接就是备份，软连接就是快捷方式\n\n**demo10**\n```javascript\nconst fs = require('fs');\nfs.link('./file/link.txt','./file/linkFile.txt',function(err){\n   if(err) return;\n})\n```\n## fs.readlink、fs.realpath、fs.unlink\n* `fs.readlink(path, [callback])` 读取链接源地址,**注意**：读取的是软连接中的实际中文名，也就是symlink设置的软连接\n* `fs.realpath(path, [callback])` 获取当前目录或者文件的绝对路径\n* `fs.unlink(path, [callback])`  删除某一个文件链接(删除的是硬链接)\n\n**demo11**\n```javascript\nconst fs = require('fs');\n// readlink\nfs.readlink('./file/link2.txt',function(err,data){\n   console.log(data); //.\\file\\link.txt  返回创建它的软链接,这里，link2是由link创建的软链接\n});\n\n// realpath\nfs.realpath('./file/linkFile.txt', function (err, resolvedPath) {\n  if (err) throw err;\n  console.log(resolvedPath);\n  //F:\\myFile\\express\\express-study\\fs\\fsTest\\file\\linkFile.txt  返回绝对路径\n});\n\n```\n\n# 五、watchfile()，unwatchfile()\nwatchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。\n\n**demo12**\n```javascript\nvar fs = require('fs');\n\nfs.watchFile('./testFile.txt', function (curr, prev) {\n  console.log('the current mtime is: ' + curr.mtime);\n  console.log('the previous mtime was: ' + prev.mtime);\n});\n\nfs.writeFile('./testFile.txt', \"changed\", function (err) {\n  if (err) throw err;\n\n  console.log(\"file write complete\");   \n});\n```\nunwatchfile方法用于解除对文件的监听。\n<br />\n<br />\n<br />\n&ensp;&ensp;&ensp;后记,当然,fs的方法不止上面我列的这些，其他需要用到的话还需要去查。另外，有一个 `fs-extra`模块也不错，扩展了fs的一些方法。可以去查查\n","slug":"node核心模块--fs","published":1,"updated":"2017-04-18T15:27:29.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr6n000a9gscmadpn3b7","content":"<h2 id=\"文件系统fs-简介\"><a href=\"#文件系统fs-简介\" class=\"headerlink\" title=\"文件系统fs-简介\"></a>文件系统fs-简介</h2><blockquote>\n<p>fs模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其它模块不同的是，fs模块中所有的操作都提供了<code>异步</code>和<code>同步</code>的两个版本。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"一、文件读取–完整性读写\"><a href=\"#一、文件读取–完整性读写\" class=\"headerlink\" title=\"一、文件读取–完整性读写\"></a>一、文件读取–完整性读写</h1><hr>\n<h2 id=\"1、fs-readFile\"><a href=\"#1、fs-readFile\" class=\"headerlink\" title=\"1、fs.readFile\"></a>1、fs.readFile</h2><p> <code>fs.readFile(filename,[encoding],[callback(error,data)]</code>是最简单的文件读取函数，它接受一个必选参数filename，表示读取的文件名。<br>    第二个参数encoding是可选的，表示文件字符编码。callback是回调函数，用于接收文件的内容。如果不指定encoding，则callback就是第二个参数。<br> 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。<br> 如果指定encoding，data是一个解析后的字符串，否则将会以Buffer形式表示的二进制数据。</p>\n<p><strong>demo1</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'./file/readFile.txt'</span>,<span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 读取文件成功</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'异步测试： --&gt;'</span>+data);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//同步</span></div><div class=\"line\"><span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/readFile.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'同步测试：--&gt;'</span>+data);</div></pre></td></tr></table></figure></p>\n<h2 id=\"2、fs-writeFile\"><a href=\"#2、fs-writeFile\" class=\"headerlink\" title=\"2、fs.writeFile\"></a>2、fs.writeFile</h2><p><code>fs.writeFile(filename,data,[options],callback)</code>用来写文件，其中options为对象，有以下几个值：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">encoding &#123;String | null&#125; default='utf-8'</div><div class=\"line\">mode &#123;Number&#125; default=438(aka 0666 in Octal)</div><div class=\"line\">flag &#123;String&#125; default='w'</div></pre></td></tr></table></figure></p>\n<p>这里主要flag值，默认为w,会清空文件，然后再写。flag值，<code>r代表读取文件</code>，<code>w代表写文件</code>，<code>a代表追加。</code></p>\n<p><strong>demo2</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 写入文件内容（如果文件不存在会创建一个文件）</span></div><div class=\"line\"><span class=\"comment\">// 写入时会先清空文件</span></div><div class=\"line\">fs.writeFile(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'写入成功：hello world'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'new data --&gt;'</span>+data);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 数据追加</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 追加</span></div><div class=\"line\">\tfs.writeFile(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'这里是追加的数据'</span>, &#123;<span class=\"string\">'flag'</span>:<span class=\"string\">'a'</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">\t    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">\t        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">\t    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'追加后的数据 --&gt;'</span>+data);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-appendFile\"><a href=\"#3、fs-appendFile\" class=\"headerlink\" title=\"3、fs.appendFile\"></a>3、fs.appendFile</h2><p><code>fs.appendFile(filename, data, [options], callback)</code>该方法以异步的方式将 data 插入到文件里，如果文件不存在会自动创建。data可以是任意字符串或者缓存。<br>与<code>fs.writeFile</code> 方法差别就是 [options]的flag默认值是”a”，所以它以追加方式写入数据.<br><strong>demo3</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 写入文件内容（如果文件不存在会创建一个文件）</span></div><div class=\"line\">fs.appendFile(<span class=\"string\">'./file/appendFile.txt'</span>, <span class=\"string\">'新数据456'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/appendFile.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"4、删除文件-unlink\"><a href=\"#4、删除文件-unlink\" class=\"headerlink\" title=\"4、删除文件 unlink\"></a>4、删除文件 unlink</h2><p>比较简单，没啥好说的，直接上demo</p>\n<p><strong>demo4</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs =<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.unlink(<span class=\"string\">'./file/unlink.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'成功删除了unlink.txt这个文件'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"二、文件读取-指定位置读写\"><a href=\"#二、文件读取-指定位置读写\" class=\"headerlink\" title=\"二、文件读取-指定位置读写\"></a>二、文件读取-指定位置读写</h1><hr>\n<p>&ensp;&ensp;这个跟上面的过程相比，流程稍微麻烦一点点，要先用fs.open来打开文件，然后才可以用fs.read去读，或者用fs.write去写文件，最后，你需要用fs.close去关掉文件。</p>\n<h2 id=\"1、fs-open\"><a href=\"#1、fs-open\" class=\"headerlink\" title=\"1、fs.open\"></a>1、fs.open</h2><p>用法：<code>fs.open(path,flags,[mode],callback)</code></p>\n<ul>\n<li>path 文件路径</li>\n<li>flags打开文件的方式<br><br>flags部分值为(没全部列出，需要的话去查即可)：<br><br><code>r:以读取模式打开文件</code><br><br><code>r+：以读写模式</code><br><br><code>w：以写入模式打开，如果不存在则创建</code><br><br><code>w+：以读写模式打开，如果不存在则创建</code><br><br><code>a:以追加模式打开文件，如果不存在则创建</code><br><br><code>a+:以读取追加模式打开文件，如果文件不存在则创建。</code></li>\n<li>[mode] 是文件的权限（可选参数，默认值是0666）</li>\n<li>callback 回调函数<br><strong>demo5</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.open(<span class=\"string\">'./file/open.txt'</span>,<span class=\"string\">'r'</span>,<span class=\"string\">'0666'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(fd); <span class=\"comment\">//返回的第二个参数为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2、fs-read\"><a href=\"#2、fs-read\" class=\"headerlink\" title=\"2、fs.read\"></a>2、fs.read</h2><p>用法<code>fs.read(fd, buffer, offset, length, position, callback);</code></p>\n<ul>\n<li>fd, 使用fs.open打开成功后返回的文件描述符</li>\n<li>buffer, 一个Buffer对象，v8引擎分配的一段内存</li>\n<li>offset, 整数，向缓存区中写入时的初始位置，以字节为单位</li>\n<li>length, 整数，读取文件的长度</li>\n<li>position, 整数，读取文件初始位置；文件大小以字节为单位</li>\n<li>callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead:实际读取字节数，buffer:被读取的缓存区对象</li>\n</ul>\n<p><strong>demo6</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.open(<span class=\"string\">'./file/open.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, fd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">255</span>);</div><div class=\"line\">    <span class=\"comment\">//每一个汉字utf8编码是3个字节，英文是1个字节</span></div><div class=\"line\">    fs.read(fd, buffer, <span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, bytesRead, buffer</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(bytesRead);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer.slice(<span class=\"number\">0</span>, bytesRead).toString());  </div><div class=\"line\">        <span class=\"comment\">//读取完后，再使用fd读取时，基点是基于上次读取位置计算；</span></div><div class=\"line\">        fs.read(fd, buffer, <span class=\"number\">0</span>, <span class=\"number\">20</span>, <span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, bytesRead, buffer</span>) </span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(bytesRead);</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(buffer.slice(<span class=\"number\">0</span>, bytesRead).toString());</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-write\"><a href=\"#3、fs-write\" class=\"headerlink\" title=\"3、fs.write\"></a>3、fs.write</h2><p>用法<code>fs.write(fd, buffer, offset, length, position, callback);</code></p>\n<ul>\n<li>fd, 使用fs.open打开成功后返回的文件描述符</li>\n<li>buffer, 一个Buffer对象，v8引擎分配的一段内存</li>\n<li>offset, 整数，从缓存区中读取时的初始位置，以字节为单位</li>\n<li>length, 整数，从缓存区中读取数据的字节数</li>\n<li>position, 整数，写入文件初始位置；</li>\n<li>callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象</li>\n</ul>\n<p><strong>demo7</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.open(__dirname + <span class=\"string\">'/file/open.txt'</span>, <span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, fd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'写入文件数据内容'</span>);</div><div class=\"line\">    <span class=\"comment\">//写入'入文件'三个字</span></div><div class=\"line\">    fs.write(fd, buffer, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, written, buffer</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入文件失败'</span>);</div><div class=\"line\">        <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer.toString());</div><div class=\"line\">        <span class=\"comment\">//写入'数据内'三个字</span></div><div class=\"line\">        fs.write(fd, buffer, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, written, buffer</span>) </span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(buffer.toString());</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"fs-close\"><a href=\"#fs-close\" class=\"headerlink\" title=\"fs.close\"></a>fs.close</h2><p>用法<code>fs.close(fd,callback)</code></p>\n<ul>\n<li>fd 文件open时传递的文件描述符</li>\n<li>callback 回调函数</li>\n</ul>\n<h1 id=\"三、目录操作\"><a href=\"#三、目录操作\" class=\"headerlink\" title=\"三、目录操作\"></a>三、目录操作</h1><hr>\n<h2 id=\"1、fs-mkdir创建目录\"><a href=\"#1、fs-mkdir创建目录\" class=\"headerlink\" title=\"1、fs.mkdir创建目录\"></a>1、fs.mkdir创建目录</h2><p><strong> demo5</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.mkdir(<span class=\"string\">'./mkdir'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'创建目录成功'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"2、fs-rmdir删除目录\"><a href=\"#2、fs-rmdir删除目录\" class=\"headerlink\" title=\"2、fs.rmdir删除目录\"></a>2、fs.rmdir删除目录</h2><p><strong>demo8</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.rmdir(<span class=\"string\">'./mkdir'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除目录成功'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-readdir读取目录\"><a href=\"#3、fs-readdir读取目录\" class=\"headerlink\" title=\"3、fs.readdir读取目录\"></a>3、fs.readdir读取目录</h2><p>返回的data为一个数组，包含该文件夹的所有文件</p>\n<p><strong>demo9</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readdir(<span class=\"string\">'./file'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"comment\">//data为一个数组</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'读取的数据为：'</span>+data[<span class=\"number\">0</span>]);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"四、链接文件操作\"><a href=\"#四、链接文件操作\" class=\"headerlink\" title=\"四、链接文件操作\"></a>四、链接文件操作</h1><hr>\n<h2 id=\"1、fs-link-创建一个链接\"><a href=\"#1、fs-link-创建一个链接\" class=\"headerlink\" title=\"1、fs.link 创建一个链接\"></a>1、fs.link 创建一个链接</h2><p><code>fs.link(srcpath, dstpath, [callback(err)])</code></p>\n<ul>\n<li><code>srcpath</code>为源文件目录或文件的路径</li>\n<li><code>dstpath</code>为转换后的路径</li>\n</ul>\n<p>可以理解为复制了一份文件到另一个文件，比如下面的demo8,我们在file文件有一个link.txt，执行后，file文件里面生成了linkFile文件，而且两者的内容是一样的,或者说是源文件的备份</p>\n<h4 id=\"进一步理解\"><a href=\"#进一步理解\" class=\"headerlink\" title=\"进一步理解\"></a>进一步理解</h4><p><code>fs.link(srcpath, dstpath, [callback])</code>、和 <code>fs.symlink(linkdata, path, [callback])</code><br>建立文件链接，除非回调函数执行过程出现了异常，否则不会传递任何参数。link和symlink的区别是： link 创建的是<code>hard link</code> 所谓硬链接; symlink创建的是<code>symbolic link</code> 所谓符号链接 硬链接就是备份，软连接就是快捷方式</p>\n<p><strong>demo10</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.link(<span class=\"string\">'./file/link.txt'</span>,<span class=\"string\">'./file/linkFile.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"fs-readlink、fs-realpath、fs-unlink\"><a href=\"#fs-readlink、fs-realpath、fs-unlink\" class=\"headerlink\" title=\"fs.readlink、fs.realpath、fs.unlink\"></a>fs.readlink、fs.realpath、fs.unlink</h2><ul>\n<li><code>fs.readlink(path, [callback])</code> 读取链接源地址,<strong>注意</strong>：读取的是软连接中的实际中文名，也就是symlink设置的软连接</li>\n<li><code>fs.realpath(path, [callback])</code> 获取当前目录或者文件的绝对路径</li>\n<li><code>fs.unlink(path, [callback])</code>  删除某一个文件链接(删除的是硬链接)</li>\n</ul>\n<p><strong>demo11</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// readlink</span></div><div class=\"line\">fs.readlink(<span class=\"string\">'./file/link2.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">//.\\file\\link.txt  返回创建它的软链接,这里，link2是由link创建的软链接</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// realpath</span></div><div class=\"line\">fs.realpath(<span class=\"string\">'./file/linkFile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, resolvedPath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(resolvedPath);</div><div class=\"line\">  <span class=\"comment\">//F:\\myFile\\express\\express-study\\fs\\fsTest\\file\\linkFile.txt  返回绝对路径</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"五、watchfile-，unwatchfile\"><a href=\"#五、watchfile-，unwatchfile\" class=\"headerlink\" title=\"五、watchfile()，unwatchfile()\"></a>五、watchfile()，unwatchfile()</h1><p>watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。</p>\n<p><strong>demo12</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.watchFile(<span class=\"string\">'./testFile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">curr, prev</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'the current mtime is: '</span> + curr.mtime);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'the previous mtime was: '</span> + prev.mtime);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">fs.writeFile(<span class=\"string\">'./testFile.txt'</span>, <span class=\"string\">\"changed\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"file write complete\"</span>);   </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>unwatchfile方法用于解除对文件的监听。<br><br><br><br><br><br><br>&ensp;&ensp;&ensp;后记,当然,fs的方法不止上面我列的这些，其他需要用到的话还需要去查。另外，有一个 <code>fs-extra</code>模块也不错，扩展了fs的一些方法。可以去查查</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"文件系统fs-简介\"><a href=\"#文件系统fs-简介\" class=\"headerlink\" title=\"文件系统fs-简介\"></a>文件系统fs-简介</h2><blockquote>\n<p>fs模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其它模块不同的是，fs模块中所有的操作都提供了<code>异步</code>和<code>同步</code>的两个版本。</p>\n</blockquote>","more":"<h1 id=\"一、文件读取–完整性读写\"><a href=\"#一、文件读取–完整性读写\" class=\"headerlink\" title=\"一、文件读取–完整性读写\"></a>一、文件读取–完整性读写</h1><hr>\n<h2 id=\"1、fs-readFile\"><a href=\"#1、fs-readFile\" class=\"headerlink\" title=\"1、fs.readFile\"></a>1、fs.readFile</h2><p> <code>fs.readFile(filename,[encoding],[callback(error,data)]</code>是最简单的文件读取函数，它接受一个必选参数filename，表示读取的文件名。<br>    第二个参数encoding是可选的，表示文件字符编码。callback是回调函数，用于接收文件的内容。如果不指定encoding，则callback就是第二个参数。<br> 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。<br> 如果指定encoding，data是一个解析后的字符串，否则将会以Buffer形式表示的二进制数据。</p>\n<p><strong>demo1</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readFile(<span class=\"string\">'./file/readFile.txt'</span>,<span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 读取文件成功</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'异步测试： --&gt;'</span>+data);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">//同步</span></div><div class=\"line\"><span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/readFile.txt'</span>,<span class=\"string\">'utf-8'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'同步测试：--&gt;'</span>+data);</div></pre></td></tr></table></figure></p>\n<h2 id=\"2、fs-writeFile\"><a href=\"#2、fs-writeFile\" class=\"headerlink\" title=\"2、fs.writeFile\"></a>2、fs.writeFile</h2><p><code>fs.writeFile(filename,data,[options],callback)</code>用来写文件，其中options为对象，有以下几个值：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">encoding &#123;String | null&#125; default='utf-8'</div><div class=\"line\">mode &#123;Number&#125; default=438(aka 0666 in Octal)</div><div class=\"line\">flag &#123;String&#125; default='w'</div></pre></td></tr></table></figure></p>\n<p>这里主要flag值，默认为w,会清空文件，然后再写。flag值，<code>r代表读取文件</code>，<code>w代表写文件</code>，<code>a代表追加。</code></p>\n<p><strong>demo2</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 写入文件内容（如果文件不存在会创建一个文件）</span></div><div class=\"line\"><span class=\"comment\">// 写入时会先清空文件</span></div><div class=\"line\">fs.writeFile(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'写入成功：hello world'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'new data --&gt;'</span>+data);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 数据追加</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 追加</span></div><div class=\"line\">\tfs.writeFile(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'这里是追加的数据'</span>, &#123;<span class=\"string\">'flag'</span>:<span class=\"string\">'a'</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">\t    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">\t        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>);</div><div class=\"line\">\t    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/writeFile.txt'</span>, <span class=\"string\">'utf-8'</span>)</div><div class=\"line\">\t    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">\t    <span class=\"built_in\">console</span>.log(<span class=\"string\">'追加后的数据 --&gt;'</span>+data);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-appendFile\"><a href=\"#3、fs-appendFile\" class=\"headerlink\" title=\"3、fs.appendFile\"></a>3、fs.appendFile</h2><p><code>fs.appendFile(filename, data, [options], callback)</code>该方法以异步的方式将 data 插入到文件里，如果文件不存在会自动创建。data可以是任意字符串或者缓存。<br>与<code>fs.writeFile</code> 方法差别就是 [options]的flag默认值是”a”，所以它以追加方式写入数据.<br><strong>demo3</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 写入文件内容（如果文件不存在会创建一个文件）</span></div><div class=\"line\">fs.appendFile(<span class=\"string\">'./file/appendFile.txt'</span>, <span class=\"string\">'新数据456'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// 写入成功后读取测试</span></div><div class=\"line\">    <span class=\"keyword\">var</span> data=fs.readFileSync(<span class=\"string\">'./file/appendFile.txt'</span>, <span class=\"string\">'utf-8'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"4、删除文件-unlink\"><a href=\"#4、删除文件-unlink\" class=\"headerlink\" title=\"4、删除文件 unlink\"></a>4、删除文件 unlink</h2><p>比较简单，没啥好说的，直接上demo</p>\n<p><strong>demo4</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs =<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.unlink(<span class=\"string\">'./file/unlink.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'成功删除了unlink.txt这个文件'</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"二、文件读取-指定位置读写\"><a href=\"#二、文件读取-指定位置读写\" class=\"headerlink\" title=\"二、文件读取-指定位置读写\"></a>二、文件读取-指定位置读写</h1><hr>\n<p>&ensp;&ensp;这个跟上面的过程相比，流程稍微麻烦一点点，要先用fs.open来打开文件，然后才可以用fs.read去读，或者用fs.write去写文件，最后，你需要用fs.close去关掉文件。</p>\n<h2 id=\"1、fs-open\"><a href=\"#1、fs-open\" class=\"headerlink\" title=\"1、fs.open\"></a>1、fs.open</h2><p>用法：<code>fs.open(path,flags,[mode],callback)</code></p>\n<ul>\n<li>path 文件路径</li>\n<li>flags打开文件的方式<br/><br>flags部分值为(没全部列出，需要的话去查即可)：<br/><br><code>r:以读取模式打开文件</code><br/><br><code>r+：以读写模式</code><br/><br><code>w：以写入模式打开，如果不存在则创建</code><br/><br><code>w+：以读写模式打开，如果不存在则创建</code><br/><br><code>a:以追加模式打开文件，如果不存在则创建</code><br/><br><code>a+:以读取追加模式打开文件，如果文件不存在则创建。</code></li>\n<li>[mode] 是文件的权限（可选参数，默认值是0666）</li>\n<li>callback 回调函数<br><strong>demo5</strong><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.open(<span class=\"string\">'./file/open.txt'</span>,<span class=\"string\">'r'</span>,<span class=\"string\">'0666'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(fd); <span class=\"comment\">//返回的第二个参数为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2、fs-read\"><a href=\"#2、fs-read\" class=\"headerlink\" title=\"2、fs.read\"></a>2、fs.read</h2><p>用法<code>fs.read(fd, buffer, offset, length, position, callback);</code></p>\n<ul>\n<li>fd, 使用fs.open打开成功后返回的文件描述符</li>\n<li>buffer, 一个Buffer对象，v8引擎分配的一段内存</li>\n<li>offset, 整数，向缓存区中写入时的初始位置，以字节为单位</li>\n<li>length, 整数，读取文件的长度</li>\n<li>position, 整数，读取文件初始位置；文件大小以字节为单位</li>\n<li>callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead:实际读取字节数，buffer:被读取的缓存区对象</li>\n</ul>\n<p><strong>demo6</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">fs.open(<span class=\"string\">'./file/open.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, fd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\"></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"number\">255</span>);</div><div class=\"line\">    <span class=\"comment\">//每一个汉字utf8编码是3个字节，英文是1个字节</span></div><div class=\"line\">    fs.read(fd, buffer, <span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, bytesRead, buffer</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> err;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(bytesRead);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer.slice(<span class=\"number\">0</span>, bytesRead).toString());  </div><div class=\"line\">        <span class=\"comment\">//读取完后，再使用fd读取时，基点是基于上次读取位置计算；</span></div><div class=\"line\">        fs.read(fd, buffer, <span class=\"number\">0</span>, <span class=\"number\">20</span>, <span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, bytesRead, buffer</span>) </span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(bytesRead);</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(buffer.slice(<span class=\"number\">0</span>, bytesRead).toString());</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-write\"><a href=\"#3、fs-write\" class=\"headerlink\" title=\"3、fs.write\"></a>3、fs.write</h2><p>用法<code>fs.write(fd, buffer, offset, length, position, callback);</code></p>\n<ul>\n<li>fd, 使用fs.open打开成功后返回的文件描述符</li>\n<li>buffer, 一个Buffer对象，v8引擎分配的一段内存</li>\n<li>offset, 整数，从缓存区中读取时的初始位置，以字节为单位</li>\n<li>length, 整数，从缓存区中读取数据的字节数</li>\n<li>position, 整数，写入文件初始位置；</li>\n<li>callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象</li>\n</ul>\n<p><strong>demo7</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.open(__dirname + <span class=\"string\">'/file/open.txt'</span>, <span class=\"string\">'a'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, fd</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(<span class=\"string\">'写入文件数据内容'</span>);</div><div class=\"line\">    <span class=\"comment\">//写入'入文件'三个字</span></div><div class=\"line\">    fs.write(fd, buffer, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, written, buffer</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span>(err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'写入文件失败'</span>);</div><div class=\"line\">        <span class=\"built_in\">console</span>.error(err);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(buffer.toString());</div><div class=\"line\">        <span class=\"comment\">//写入'数据内'三个字</span></div><div class=\"line\">        fs.write(fd, buffer, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"literal\">null</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, written, buffer</span>) </span>&#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(buffer.toString());</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h2 id=\"fs-close\"><a href=\"#fs-close\" class=\"headerlink\" title=\"fs.close\"></a>fs.close</h2><p>用法<code>fs.close(fd,callback)</code></p>\n<ul>\n<li>fd 文件open时传递的文件描述符</li>\n<li>callback 回调函数</li>\n</ul>\n<h1 id=\"三、目录操作\"><a href=\"#三、目录操作\" class=\"headerlink\" title=\"三、目录操作\"></a>三、目录操作</h1><hr>\n<h2 id=\"1、fs-mkdir创建目录\"><a href=\"#1、fs-mkdir创建目录\" class=\"headerlink\" title=\"1、fs.mkdir创建目录\"></a>1、fs.mkdir创建目录</h2><p><strong> demo5</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.mkdir(<span class=\"string\">'./mkdir'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'创建目录成功'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"2、fs-rmdir删除目录\"><a href=\"#2、fs-rmdir删除目录\" class=\"headerlink\" title=\"2、fs.rmdir删除目录\"></a>2、fs.rmdir删除目录</h2><p><strong>demo8</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.rmdir(<span class=\"string\">'./mkdir'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'删除目录成功'</span>);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"3、fs-readdir读取目录\"><a href=\"#3、fs-readdir读取目录\" class=\"headerlink\" title=\"3、fs.readdir读取目录\"></a>3、fs.readdir读取目录</h2><p>返回的data为一个数组，包含该文件夹的所有文件</p>\n<p><strong>demo9</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.readdir(<span class=\"string\">'./file'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"comment\">//data为一个数组</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'读取的数据为：'</span>+data[<span class=\"number\">0</span>]);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"四、链接文件操作\"><a href=\"#四、链接文件操作\" class=\"headerlink\" title=\"四、链接文件操作\"></a>四、链接文件操作</h1><hr>\n<h2 id=\"1、fs-link-创建一个链接\"><a href=\"#1、fs-link-创建一个链接\" class=\"headerlink\" title=\"1、fs.link 创建一个链接\"></a>1、fs.link 创建一个链接</h2><p><code>fs.link(srcpath, dstpath, [callback(err)])</code></p>\n<ul>\n<li><code>srcpath</code>为源文件目录或文件的路径</li>\n<li><code>dstpath</code>为转换后的路径</li>\n</ul>\n<p>可以理解为复制了一份文件到另一个文件，比如下面的demo8,我们在file文件有一个link.txt，执行后，file文件里面生成了linkFile文件，而且两者的内容是一样的,或者说是源文件的备份</p>\n<h4 id=\"进一步理解\"><a href=\"#进一步理解\" class=\"headerlink\" title=\"进一步理解\"></a>进一步理解</h4><p><code>fs.link(srcpath, dstpath, [callback])</code>、和 <code>fs.symlink(linkdata, path, [callback])</code><br>建立文件链接，除非回调函数执行过程出现了异常，否则不会传递任何参数。link和symlink的区别是： link 创建的是<code>hard link</code> 所谓硬链接; symlink创建的是<code>symbolic link</code> 所谓符号链接 硬链接就是备份，软连接就是快捷方式</p>\n<p><strong>demo10</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.link(<span class=\"string\">'./file/link.txt'</span>,<span class=\"string\">'./file/linkFile.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"fs-readlink、fs-realpath、fs-unlink\"><a href=\"#fs-readlink、fs-realpath、fs-unlink\" class=\"headerlink\" title=\"fs.readlink、fs.realpath、fs.unlink\"></a>fs.readlink、fs.realpath、fs.unlink</h2><ul>\n<li><code>fs.readlink(path, [callback])</code> 读取链接源地址,<strong>注意</strong>：读取的是软连接中的实际中文名，也就是symlink设置的软连接</li>\n<li><code>fs.realpath(path, [callback])</code> 获取当前目录或者文件的绝对路径</li>\n<li><code>fs.unlink(path, [callback])</code>  删除某一个文件链接(删除的是硬链接)</li>\n</ul>\n<p><strong>demo11</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// readlink</span></div><div class=\"line\">fs.readlink(<span class=\"string\">'./file/link2.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</div><div class=\"line\">   <span class=\"built_in\">console</span>.log(data); <span class=\"comment\">//.\\file\\link.txt  返回创建它的软链接,这里，link2是由link创建的软链接</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// realpath</span></div><div class=\"line\">fs.realpath(<span class=\"string\">'./file/linkFile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, resolvedPath</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(resolvedPath);</div><div class=\"line\">  <span class=\"comment\">//F:\\myFile\\express\\express-study\\fs\\fsTest\\file\\linkFile.txt  返回绝对路径</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h1 id=\"五、watchfile-，unwatchfile\"><a href=\"#五、watchfile-，unwatchfile\" class=\"headerlink\" title=\"五、watchfile()，unwatchfile()\"></a>五、watchfile()，unwatchfile()</h1><p>watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。</p>\n<p><strong>demo12</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\">fs.watchFile(<span class=\"string\">'./testFile.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">curr, prev</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'the current mtime is: '</span> + curr.mtime);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'the previous mtime was: '</span> + prev.mtime);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">fs.writeFile(<span class=\"string\">'./testFile.txt'</span>, <span class=\"string\">\"changed\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"file write complete\"</span>);   </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>unwatchfile方法用于解除对文件的监听。<br><br /><br><br /><br><br /><br>&ensp;&ensp;&ensp;后记,当然,fs的方法不止上面我列的这些，其他需要用到的话还需要去查。另外，有一个 <code>fs-extra</code>模块也不错，扩展了fs的一些方法。可以去查查</p>"},{"title":"mongoose的一些操作命令","date":"2017-05-06T03:50:00.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp;最近在用express+mongoose写一个网站，因为经常要用到mongoose的一些操作命令，经常去查还挺麻烦的，所以总结一篇mongoose的使用以及一些操作命令。mongoose里面有三个概念，schemal、model、entity。先来对其三者做个小小的总结概括。\n`Schema` ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力\n`Model` ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对\n`Entity` ： 由Model创建的实体，他的操作也会影响数据库\n<!-- more -->\n&ensp;&ensp;&ensp;&ensp;Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。\n&ensp;&ensp;&ensp;&ensp;你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。\n\n\n\n ## 1.Schema\nschema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；\n每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力.\n仅仅只是一段代码，无法通往数据库端, 仅仅只是数据库模型在程序片段中的一种表现\n\n定义Schema\n```javascript\nvar mongoose = require('./db.js'),\n\nvar UserSchema = new mongoose.Schema({          \n    username : { type: String },                    \n    userpwd: {type: String},                        \n    userage: {type: Number},                       \n    logindate : { type: Date}                      \n});\n```\n\n** Schema Types的内置类型 **\n\n* `String`\n* `Number`\n* `Boolean | Bool`\n* `Array`\n* `Buffer`\n* `Date`\n* `ObjectId | Oid`\n* `Mixed`\n\n## 2. Model模型\n\nModel模型，是经过Schema构造来的，是Schema的编译版本。一个model的实例直接映射为数据库中的一个文档。基于这种关系， 以后的增删改查（CURD）都要通过这个Model实现。\n\n下面我们来定义我们的model\n```javascript\nvar mongoose = require('./db.js');\nvar ObjectId = mongoose.Schema.ObjectId;\nvar UserSchema = new mongoose.Schema({          \n    name : { type: String },                                       \n    age: {type: Number},   \n    updated:{type:new Date},                  \n    binary:{ type:Buffer },\n    _id : { type:ObjectId },\n    mixed : { type: Mixed },    \n    isMerried :{ type : Boolean }                                      \n});\nmodule.exports = mongoose.model('User',UserSchema);\n```\n定义好model之后，就可以往里面进行一些增删查改的操作了。\n\n## 3. model - 文档操作\n** 增加数据 **\n如果是Entity，使用save方法，如果是Model，使用create方法\n`Model.create(data, callback))`\n```javascript\nUser.create(data,function(err, doc) {\n      if (err) return console.log(err);\n      console.log(doc);\n  });\n```\n\n** 查询 **\n`model.find({}, callback)`; 参数1忽略,或为空对象则返回所有集合文档\n`model.find({},field,callback)`;  过滤查询,参数2: {'name':1, 'age':0} 查询文档的返回结果包含name , field的值中,1为包括，0为不包括\n`model.find({},null,{limit:20})`; 过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.\n`model.findOne({}, callback)`; 查询找到的第一个文档\n`model.findById('obj._i', callback)`; 查询找到的第一个文档,同上. 但是只接 `_id` 的值查询\n```javascript\n//find\nUser.find({},function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n//findOne\nUser.findOne({name: '张三'}, function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n//findByID 与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id //可以是字符串或 ObjectId 对象。\nUser.findById(id, function(err, data){\n    if (err) consoel.log(err);\n    console.log(data);\n});\n```\n\n\n\n** 更新 **\n`Model.update(conditions, data, [options], [callback])`\nconditions 更新条件\ndata 更新内容\noption 更新选项\n&ensp;&ensp;`safe (boolean)` 安全模式，默认选项，值为true\n&ensp;&ensp;`upsert (boolean`) 条件不匹配时是否创建新文档，默认值为false\n&ensp;&ensp;`multi (boolean)` 是否更新多个文件，默认值为false\n&ensp;&ensp;`strict (boolean)` 严格模式，只更新一条数据\n&ensp;&ensp;`overwrite (boolean)` 覆盖数据，默认为false\ncallback回调\n```javascript\nUser.update({name: '张三'}, {age: '6'}, {multi : true}, function(err, numberAffected, raw){\n    if (err) return console.log(err);\n});\n```\n\n** 删除 **\n`Model.remove(conditions,callback);`\n参数1:查询条件\n```javascript\nUser.remove({age: 6}, function(err){\n    if (err) console.log(err);\n})\n```\n\n## 4. Entity - 文档操作\n由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性\n创建\n```javascript\n//使用Entity来增加一条数据\nvar krouky = new PersonModel({name:'krouky'});\nkrouky.save(callback);\n//对比使用Model来增加一条数据\nvar MDragon = {name:'MDragon'};\nPersonModel.create(MDragon,callback);\n```\n\n\n## 5. 修改器和更新器\n\n** 更新修改器 **\n`$inc` 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1\n```javascript\nModel.update({'age':22}, {'$inc':{'age':1} }  ); // 执行后: age=23\n```\n`$set` 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.\n```javascript\nModel.update({'age':22}, {'$set':{'age':'haha'} }  ); // 执行后: age='haha'\n```\n`$unset` 同上取反,删除一个键\n```javascript\nModel.update({'age':22}, {'$unset':{'age':'haha'} }  ); //执行后: age键不存在`\n```\n\n** 数组修改器: **\n`$push`给一个键push一个数组成员,键不存在会创建\n```javascript\nModel.update({'age':22}, {'$push':{'array':10} } ); //执行后: 增加一个 array 键,类型为数组, 有一个成员 10`\n```\n`$addToSet` 向数组中添加一个元素,如果存在就不添加\n```javascript\nModel.update({'age':22}, {'$addToSet':{'array':10} } ); // 执行后: array中有10所以不会添加\n```\n`$each` 遍历数组, 和 $push 修改器配合可以插入多个值\n```javascript\nModel.update({'age':22}, {'$push':{'array':{'$each': [1,2,3,4,5]}} } ); //执行后: array : [10,1,2,3,4,5]\n```\n`$pop` 向数组中尾部删除一个元素\n```javascript\nModel.update({'age':22}, {'$pop':{'array':1} } ); //执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素\n```\n`$pull` 向数组中删除指定元素\n```javascript\nModel.update({'age':22}, {'$pull':{'array':10} } ); // 执行后: array : [1,2,3,4] 匹配到array中的10后将其删除\n```\n\n** 条件查询: **\n`$lt `小于\n`$lte` 小于等于\n`$gt` 大于\n`$gte` 大于等于\n`$ne` 不等于\n```javascript\nModel.find({'age':{ '$get':18 , '$lte':30 } } ); //查询 age 大于等于18并小于等于30的文档\n```\n\n** 或查询 OR: **\n`$in`  一个键对应多个值\n`$nin` 同上取反, 一个键不对应指定值\n`$or`  多个条件匹配, 可以嵌套 $in 使用\n`$not` 同上取反, 查询与特定模式不匹配的文档\n```javascript\nModel.find({'age':{ '$in':[20,21,22.'haha']} } ); //查询 age等于20或21或21或'haha'的文档\nModel.find({'$or' :  [ {'age':18} , {'name':'xueyou'} ] }); //查询 age等于18 或 name等于'xueyou' 的文档\n```\n\n** 类型查询: **\nnull 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  '$exists' 条件判定键值已经存在 \"$exists\" (表示是否存在的意思)\n```javascript\nModel.find('age' :  { '$in' : [null] , 'exists' : true  } ); // 查询 age值为null的文档\n```\n```javascript\nModel.find({name:{$exists:true}},function(error,docs){\n  //查询所有存在name属性的文档\n});\nModel.find({telephone:{$exists:false}},function(error,docs){\n  //查询所有不存在telephone属性的文档\n});\n```\n\n\n** 正则表达式: **\nMongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式\n```javascript\nfind( {'name' : /joe/i } );  //查询name为 joe 的文档, 并忽略大小写\nfind( {'name' : /joe?/i } ); //查询匹配各种大小写组合\n```\n\n** 查询数组: **\n`Model.find({'array':10} )`; 查询 array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到\n`Model.find({'array[5]':10} )`; 查询 array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到\n`$all` 匹配数组中多个元素\n`Model.find({'array':[5,10]} )`; 查询 匹配array数组中 既有5又有10的文档\n`$size` 匹配数组长度\n`Model.find({'array':{\"$size\" : 3} } )`; 查询 匹配array数组长度为3 的文档\n`$slice` 查询子集合返回\n`Model.find({'array':{\"$skice\" : 10} } )`; 查询 匹配array数组的前10个元素\n`Model.find({'array':{\"$skice\" : [5,10] } } )`; 查询 匹配array数组的第5个到第10个元素\n\n** where **\n用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回\n```javascript\n//where\n//查询数据类型是字符串时，可支持正则\nUser.where('age', '2').exec(function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n});\n\nUser\n    .where('age').gte(1).lte(10)\n    .where('name', '张三')\n    .exec(function(err, data){\n      if (err) console.log(err);\n      console.log(data);\n    });\n```\n\n\n** 游标: **\n`limit(3)` 限制返回结果的数量,\n`skip(3)` 跳过前3个文档,返回其余的\n`sort( {'username':1 , 'age':-1 } )` 排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序\n\n## 6.其他\n\n** 数量查询 **\n```javascript\n// //返回数量\nUser.count({age: 2}, function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n```\n\n** 分页查询 **\n```javascript\nvar User = require(\"./user.js\");\nfunction getByPager(){\n    var pageSize = 5;                   //一页多少条\n    var currentPage = 1;                //当前第几页\n    var sort = {'logindate':-1};        //排序（按登录时间倒序）\n    var condition = {};                 //条件\n    var skipnum = (currentPage - 1) * pageSize;   //跳过数\n    User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(function (err, res) {\n        if (err) {\n            console.log(\"Error:\" + err);\n        }\n        else {\n            console.log(\"Res:\" + res);\n        }\n    })\n}\ngetByPager();\n```\n","source":"_posts/mongoose的一些操作命令.md","raw":"---\ntitle: mongoose的一些操作命令\ndate: 2017-05-06 11:50\ncategories:\ntags:\n     - mongoose\n     - node\n---\n\n&ensp;&ensp;&ensp;&ensp;最近在用express+mongoose写一个网站，因为经常要用到mongoose的一些操作命令，经常去查还挺麻烦的，所以总结一篇mongoose的使用以及一些操作命令。mongoose里面有三个概念，schemal、model、entity。先来对其三者做个小小的总结概括。\n`Schema` ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力\n`Model` ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对\n`Entity` ： 由Model创建的实体，他的操作也会影响数据库\n<!-- more -->\n&ensp;&ensp;&ensp;&ensp;Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。\n&ensp;&ensp;&ensp;&ensp;你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。\n\n\n\n ## 1.Schema\nschema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；\n每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力.\n仅仅只是一段代码，无法通往数据库端, 仅仅只是数据库模型在程序片段中的一种表现\n\n定义Schema\n```javascript\nvar mongoose = require('./db.js'),\n\nvar UserSchema = new mongoose.Schema({          \n    username : { type: String },                    \n    userpwd: {type: String},                        \n    userage: {type: Number},                       \n    logindate : { type: Date}                      \n});\n```\n\n** Schema Types的内置类型 **\n\n* `String`\n* `Number`\n* `Boolean | Bool`\n* `Array`\n* `Buffer`\n* `Date`\n* `ObjectId | Oid`\n* `Mixed`\n\n## 2. Model模型\n\nModel模型，是经过Schema构造来的，是Schema的编译版本。一个model的实例直接映射为数据库中的一个文档。基于这种关系， 以后的增删改查（CURD）都要通过这个Model实现。\n\n下面我们来定义我们的model\n```javascript\nvar mongoose = require('./db.js');\nvar ObjectId = mongoose.Schema.ObjectId;\nvar UserSchema = new mongoose.Schema({          \n    name : { type: String },                                       \n    age: {type: Number},   \n    updated:{type:new Date},                  \n    binary:{ type:Buffer },\n    _id : { type:ObjectId },\n    mixed : { type: Mixed },    \n    isMerried :{ type : Boolean }                                      \n});\nmodule.exports = mongoose.model('User',UserSchema);\n```\n定义好model之后，就可以往里面进行一些增删查改的操作了。\n\n## 3. model - 文档操作\n** 增加数据 **\n如果是Entity，使用save方法，如果是Model，使用create方法\n`Model.create(data, callback))`\n```javascript\nUser.create(data,function(err, doc) {\n      if (err) return console.log(err);\n      console.log(doc);\n  });\n```\n\n** 查询 **\n`model.find({}, callback)`; 参数1忽略,或为空对象则返回所有集合文档\n`model.find({},field,callback)`;  过滤查询,参数2: {'name':1, 'age':0} 查询文档的返回结果包含name , field的值中,1为包括，0为不包括\n`model.find({},null,{limit:20})`; 过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.\n`model.findOne({}, callback)`; 查询找到的第一个文档\n`model.findById('obj._i', callback)`; 查询找到的第一个文档,同上. 但是只接 `_id` 的值查询\n```javascript\n//find\nUser.find({},function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n//findOne\nUser.findOne({name: '张三'}, function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n//findByID 与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id //可以是字符串或 ObjectId 对象。\nUser.findById(id, function(err, data){\n    if (err) consoel.log(err);\n    console.log(data);\n});\n```\n\n\n\n** 更新 **\n`Model.update(conditions, data, [options], [callback])`\nconditions 更新条件\ndata 更新内容\noption 更新选项\n&ensp;&ensp;`safe (boolean)` 安全模式，默认选项，值为true\n&ensp;&ensp;`upsert (boolean`) 条件不匹配时是否创建新文档，默认值为false\n&ensp;&ensp;`multi (boolean)` 是否更新多个文件，默认值为false\n&ensp;&ensp;`strict (boolean)` 严格模式，只更新一条数据\n&ensp;&ensp;`overwrite (boolean)` 覆盖数据，默认为false\ncallback回调\n```javascript\nUser.update({name: '张三'}, {age: '6'}, {multi : true}, function(err, numberAffected, raw){\n    if (err) return console.log(err);\n});\n```\n\n** 删除 **\n`Model.remove(conditions,callback);`\n参数1:查询条件\n```javascript\nUser.remove({age: 6}, function(err){\n    if (err) console.log(err);\n})\n```\n\n## 4. Entity - 文档操作\n由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性\n创建\n```javascript\n//使用Entity来增加一条数据\nvar krouky = new PersonModel({name:'krouky'});\nkrouky.save(callback);\n//对比使用Model来增加一条数据\nvar MDragon = {name:'MDragon'};\nPersonModel.create(MDragon,callback);\n```\n\n\n## 5. 修改器和更新器\n\n** 更新修改器 **\n`$inc` 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1\n```javascript\nModel.update({'age':22}, {'$inc':{'age':1} }  ); // 执行后: age=23\n```\n`$set` 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.\n```javascript\nModel.update({'age':22}, {'$set':{'age':'haha'} }  ); // 执行后: age='haha'\n```\n`$unset` 同上取反,删除一个键\n```javascript\nModel.update({'age':22}, {'$unset':{'age':'haha'} }  ); //执行后: age键不存在`\n```\n\n** 数组修改器: **\n`$push`给一个键push一个数组成员,键不存在会创建\n```javascript\nModel.update({'age':22}, {'$push':{'array':10} } ); //执行后: 增加一个 array 键,类型为数组, 有一个成员 10`\n```\n`$addToSet` 向数组中添加一个元素,如果存在就不添加\n```javascript\nModel.update({'age':22}, {'$addToSet':{'array':10} } ); // 执行后: array中有10所以不会添加\n```\n`$each` 遍历数组, 和 $push 修改器配合可以插入多个值\n```javascript\nModel.update({'age':22}, {'$push':{'array':{'$each': [1,2,3,4,5]}} } ); //执行后: array : [10,1,2,3,4,5]\n```\n`$pop` 向数组中尾部删除一个元素\n```javascript\nModel.update({'age':22}, {'$pop':{'array':1} } ); //执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素\n```\n`$pull` 向数组中删除指定元素\n```javascript\nModel.update({'age':22}, {'$pull':{'array':10} } ); // 执行后: array : [1,2,3,4] 匹配到array中的10后将其删除\n```\n\n** 条件查询: **\n`$lt `小于\n`$lte` 小于等于\n`$gt` 大于\n`$gte` 大于等于\n`$ne` 不等于\n```javascript\nModel.find({'age':{ '$get':18 , '$lte':30 } } ); //查询 age 大于等于18并小于等于30的文档\n```\n\n** 或查询 OR: **\n`$in`  一个键对应多个值\n`$nin` 同上取反, 一个键不对应指定值\n`$or`  多个条件匹配, 可以嵌套 $in 使用\n`$not` 同上取反, 查询与特定模式不匹配的文档\n```javascript\nModel.find({'age':{ '$in':[20,21,22.'haha']} } ); //查询 age等于20或21或21或'haha'的文档\nModel.find({'$or' :  [ {'age':18} , {'name':'xueyou'} ] }); //查询 age等于18 或 name等于'xueyou' 的文档\n```\n\n** 类型查询: **\nnull 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  '$exists' 条件判定键值已经存在 \"$exists\" (表示是否存在的意思)\n```javascript\nModel.find('age' :  { '$in' : [null] , 'exists' : true  } ); // 查询 age值为null的文档\n```\n```javascript\nModel.find({name:{$exists:true}},function(error,docs){\n  //查询所有存在name属性的文档\n});\nModel.find({telephone:{$exists:false}},function(error,docs){\n  //查询所有不存在telephone属性的文档\n});\n```\n\n\n** 正则表达式: **\nMongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式\n```javascript\nfind( {'name' : /joe/i } );  //查询name为 joe 的文档, 并忽略大小写\nfind( {'name' : /joe?/i } ); //查询匹配各种大小写组合\n```\n\n** 查询数组: **\n`Model.find({'array':10} )`; 查询 array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到\n`Model.find({'array[5]':10} )`; 查询 array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到\n`$all` 匹配数组中多个元素\n`Model.find({'array':[5,10]} )`; 查询 匹配array数组中 既有5又有10的文档\n`$size` 匹配数组长度\n`Model.find({'array':{\"$size\" : 3} } )`; 查询 匹配array数组长度为3 的文档\n`$slice` 查询子集合返回\n`Model.find({'array':{\"$skice\" : 10} } )`; 查询 匹配array数组的前10个元素\n`Model.find({'array':{\"$skice\" : [5,10] } } )`; 查询 匹配array数组的第5个到第10个元素\n\n** where **\n用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回\n```javascript\n//where\n//查询数据类型是字符串时，可支持正则\nUser.where('age', '2').exec(function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n});\n\nUser\n    .where('age').gte(1).lte(10)\n    .where('name', '张三')\n    .exec(function(err, data){\n      if (err) console.log(err);\n      console.log(data);\n    });\n```\n\n\n** 游标: **\n`limit(3)` 限制返回结果的数量,\n`skip(3)` 跳过前3个文档,返回其余的\n`sort( {'username':1 , 'age':-1 } )` 排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序\n\n## 6.其他\n\n** 数量查询 **\n```javascript\n// //返回数量\nUser.count({age: 2}, function(err, data){\n    if (err) console.log(err);\n    console.log(data);\n})\n```\n\n** 分页查询 **\n```javascript\nvar User = require(\"./user.js\");\nfunction getByPager(){\n    var pageSize = 5;                   //一页多少条\n    var currentPage = 1;                //当前第几页\n    var sort = {'logindate':-1};        //排序（按登录时间倒序）\n    var condition = {};                 //条件\n    var skipnum = (currentPage - 1) * pageSize;   //跳过数\n    User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(function (err, res) {\n        if (err) {\n            console.log(\"Error:\" + err);\n        }\n        else {\n            console.log(\"Res:\" + res);\n        }\n    })\n}\ngetByPager();\n```\n","slug":"mongoose的一些操作命令","published":1,"updated":"2017-05-07T10:14:17.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr6r000b9gsc416lrzo0","content":"<p>&ensp;&ensp;&ensp;&ensp;最近在用express+mongoose写一个网站，因为经常要用到mongoose的一些操作命令，经常去查还挺麻烦的，所以总结一篇mongoose的使用以及一些操作命令。mongoose里面有三个概念，schemal、model、entity。先来对其三者做个小小的总结概括。<br><code>Schema</code> ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力<br><code>Model</code> ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对<br><code>Entity</code> ： 由Model创建的实体，他的操作也会影响数据库<br><a id=\"more\"></a><br>&ensp;&ensp;&ensp;&ensp;Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。<br>&ensp;&ensp;&ensp;&ensp;你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。</p>\n<h2 id=\"1-Schema\"><a href=\"#1-Schema\" class=\"headerlink\" title=\"1.Schema\"></a>1.Schema</h2><p>schema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；<br>每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力.<br>仅仅只是一段代码，无法通往数据库端, 仅仅只是数据库模型在程序片段中的一种表现</p>\n<p>定义Schema<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'./db.js'</span>),</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;          </div><div class=\"line\">    <span class=\"attr\">username</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span> &#125;,                    </div><div class=\"line\">    <span class=\"attr\">userpwd</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">String</span>&#125;,                        </div><div class=\"line\">    <span class=\"attr\">userage</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>&#125;,                       </div><div class=\"line\">    <span class=\"attr\">logindate</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>&#125;                      </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> Schema Types的内置类型 </strong></p>\n<ul>\n<li><code>String</code></li>\n<li><code>Number</code></li>\n<li><code>Boolean | Bool</code></li>\n<li><code>Array</code></li>\n<li><code>Buffer</code></li>\n<li><code>Date</code></li>\n<li><code>ObjectId | Oid</code></li>\n<li><code>Mixed</code></li>\n</ul>\n<h2 id=\"2-Model模型\"><a href=\"#2-Model模型\" class=\"headerlink\" title=\"2. Model模型\"></a>2. Model模型</h2><p>Model模型，是经过Schema构造来的，是Schema的编译版本。一个model的实例直接映射为数据库中的一个文档。基于这种关系， 以后的增删改查（CURD）都要通过这个Model实现。</p>\n<p>下面我们来定义我们的model<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'./db.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ObjectId = mongoose.Schema.ObjectId;</div><div class=\"line\"><span class=\"keyword\">var</span> UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;          </div><div class=\"line\">    <span class=\"attr\">name</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span> &#125;,                                       </div><div class=\"line\">    <span class=\"attr\">age</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>&#125;,   </div><div class=\"line\">    <span class=\"attr\">updated</span>:&#123;<span class=\"attr\">type</span>:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>&#125;,                  </div><div class=\"line\">    <span class=\"attr\">binary</span>:&#123; <span class=\"attr\">type</span>:Buffer &#125;,</div><div class=\"line\">    <span class=\"attr\">_id</span> : &#123; <span class=\"attr\">type</span>:ObjectId &#125;,</div><div class=\"line\">    <span class=\"attr\">mixed</span> : &#123; <span class=\"attr\">type</span>: Mixed &#125;,    </div><div class=\"line\">    <span class=\"attr\">isMerried</span> :&#123; <span class=\"attr\">type</span> : <span class=\"built_in\">Boolean</span> &#125;                                      </div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = mongoose.model(<span class=\"string\">'User'</span>,UserSchema);</div></pre></td></tr></table></figure></p>\n<p>定义好model之后，就可以往里面进行一些增删查改的操作了。</p>\n<h2 id=\"3-model-文档操作\"><a href=\"#3-model-文档操作\" class=\"headerlink\" title=\"3. model - 文档操作\"></a>3. model - 文档操作</h2><p><strong> 增加数据 </strong><br>如果是Entity，使用save方法，如果是Model，使用create方法<br><code>Model.create(data, callback))</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.create(data,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, doc</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(doc);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 查询 </strong><br><code>model.find({}, callback)</code>; 参数1忽略,或为空对象则返回所有集合文档<br><code>model.find({},field,callback)</code>;  过滤查询,参数2: {‘name’:1, ‘age’:0} 查询文档的返回结果包含name , field的值中,1为包括，0为不包括<br><code>model.find({},null,{limit:20})</code>; 过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.<br><code>model.findOne({}, callback)</code>; 查询找到的第一个文档<br><code>model.findById(&#39;obj._i&#39;, callback)</code>; 查询找到的第一个文档,同上. 但是只接 <code>_id</code> 的值查询<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//find</span></div><div class=\"line\">User.find(&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//findOne</span></div><div class=\"line\">User.findOne(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'张三'</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//findByID 与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id //可以是字符串或 ObjectId 对象。</span></div><div class=\"line\">User.findById(id, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) consoel.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 更新 </strong><br><code>Model.update(conditions, data, [options], [callback])</code><br>conditions 更新条件<br>data 更新内容<br>option 更新选项<br>&ensp;&ensp;<code>safe (boolean)</code> 安全模式，默认选项，值为true<br>&ensp;&ensp;<code>upsert (boolean</code>) 条件不匹配时是否创建新文档，默认值为false<br>&ensp;&ensp;<code>multi (boolean)</code> 是否更新多个文件，默认值为false<br>&ensp;&ensp;<code>strict (boolean)</code> 严格模式，只更新一条数据<br>&ensp;&ensp;<code>overwrite (boolean)</code> 覆盖数据，默认为false<br>callback回调<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.update(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'张三'</span>&#125;, &#123;<span class=\"attr\">age</span>: <span class=\"string\">'6'</span>&#125;, &#123;<span class=\"attr\">multi</span> : <span class=\"literal\">true</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, numberAffected, raw</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 删除 </strong><br><code>Model.remove(conditions,callback);</code><br>参数1:查询条件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.remove(&#123;<span class=\"attr\">age</span>: <span class=\"number\">6</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-Entity-文档操作\"><a href=\"#4-Entity-文档操作\" class=\"headerlink\" title=\"4. Entity - 文档操作\"></a>4. Entity - 文档操作</h2><p>由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性<br>创建<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用Entity来增加一条数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> krouky = <span class=\"keyword\">new</span> PersonModel(&#123;<span class=\"attr\">name</span>:<span class=\"string\">'krouky'</span>&#125;);</div><div class=\"line\">krouky.save(callback);</div><div class=\"line\"><span class=\"comment\">//对比使用Model来增加一条数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> MDragon = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'MDragon'</span>&#125;;</div><div class=\"line\">PersonModel.create(MDragon,callback);</div></pre></td></tr></table></figure></p>\n<h2 id=\"5-修改器和更新器\"><a href=\"#5-修改器和更新器\" class=\"headerlink\" title=\"5. 修改器和更新器\"></a>5. 修改器和更新器</h2><p><strong> 更新修改器 </strong><br><code>$inc</code> 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$inc'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"number\">1</span>&#125; &#125;  ); <span class=\"comment\">// 执行后: age=23</span></div></pre></td></tr></table></figure></p>\n<p><code>$set</code> 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$set'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"string\">'haha'</span>&#125; &#125;  ); <span class=\"comment\">// 执行后: age='haha'</span></div></pre></td></tr></table></figure></p>\n<p><code>$unset</code> 同上取反,删除一个键<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$unset'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"string\">'haha'</span>&#125; &#125;  ); <span class=\"comment\">//执行后: age键不存在`</span></div></pre></td></tr></table></figure></p>\n<p><strong> 数组修改器: </strong><br><code>$push</code>给一个键push一个数组成员,键不存在会创建<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$push'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">//执行后: 增加一个 array 键,类型为数组, 有一个成员 10`</span></div></pre></td></tr></table></figure></p>\n<p><code>$addToSet</code> 向数组中添加一个元素,如果存在就不添加<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$addToSet'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">// 执行后: array中有10所以不会添加</span></div></pre></td></tr></table></figure></p>\n<p><code>$each</code> 遍历数组, 和 $push 修改器配合可以插入多个值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$push'</span>:&#123;<span class=\"string\">'array'</span>:&#123;<span class=\"string\">'$each'</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]&#125;&#125; &#125; ); <span class=\"comment\">//执行后: array : [10,1,2,3,4,5]</span></div></pre></td></tr></table></figure></p>\n<p><code>$pop</code> 向数组中尾部删除一个元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$pop'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">1</span>&#125; &#125; ); <span class=\"comment\">//执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素</span></div></pre></td></tr></table></figure></p>\n<p><code>$pull</code> 向数组中删除指定元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$pull'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">// 执行后: array : [1,2,3,4] 匹配到array中的10后将其删除</span></div></pre></td></tr></table></figure></p>\n<p><strong> 条件查询: </strong><br><code>$lt</code>小于<br><code>$lte</code> 小于等于<br><code>$gt</code> 大于<br><code>$gte</code> 大于等于<br><code>$ne</code> 不等于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"string\">'age'</span>:&#123; <span class=\"string\">'$get'</span>:<span class=\"number\">18</span> , <span class=\"string\">'$lte'</span>:<span class=\"number\">30</span> &#125; &#125; ); <span class=\"comment\">//查询 age 大于等于18并小于等于30的文档</span></div></pre></td></tr></table></figure></p>\n<p><strong> 或查询 OR: </strong><br><code>$in</code>  一个键对应多个值<br><code>$nin</code> 同上取反, 一个键不对应指定值<br><code>$or</code>  多个条件匹配, 可以嵌套 $in 使用<br><code>$not</code> 同上取反, 查询与特定模式不匹配的文档<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"string\">'age'</span>:&#123; <span class=\"string\">'$in'</span>:[<span class=\"number\">20</span>,<span class=\"number\">21</span>,<span class=\"number\">22.</span><span class=\"string\">'haha'</span>]&#125; &#125; ); <span class=\"comment\">//查询 age等于20或21或21或'haha'的文档</span></div><div class=\"line\">Model.find(&#123;<span class=\"string\">'$or'</span> :  [ &#123;<span class=\"string\">'age'</span>:<span class=\"number\">18</span>&#125; , &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'xueyou'</span>&#125; ] &#125;); <span class=\"comment\">//查询 age等于18 或 name等于'xueyou' 的文档</span></div></pre></td></tr></table></figure></p>\n<p><strong> 类型查询: </strong><br>null 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  ‘$exists’ 条件判定键值已经存在 “$exists” (表示是否存在的意思)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(<span class=\"string\">'age'</span> :  &#123; <span class=\"string\">'$in'</span> : [<span class=\"literal\">null</span>] , <span class=\"string\">'exists'</span> : <span class=\"literal\">true</span>  &#125; ); <span class=\"comment\">// 查询 age值为null的文档</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"attr\">name</span>:&#123;<span class=\"attr\">$exists</span>:<span class=\"literal\">true</span>&#125;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error,docs</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//查询所有存在name属性的文档</span></div><div class=\"line\">&#125;);</div><div class=\"line\">Model.find(&#123;<span class=\"attr\">telephone</span>:&#123;<span class=\"attr\">$exists</span>:<span class=\"literal\">false</span>&#125;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error,docs</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//查询所有不存在telephone属性的文档</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong> 正则表达式: </strong><br>MongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">find( &#123;<span class=\"string\">'name'</span> : <span class=\"regexp\">/joe/i</span> &#125; );  <span class=\"comment\">//查询name为 joe 的文档, 并忽略大小写</span></div><div class=\"line\">find( &#123;<span class=\"string\">'name'</span> : <span class=\"regexp\">/joe?/i</span> &#125; ); <span class=\"comment\">//查询匹配各种大小写组合</span></div></pre></td></tr></table></figure></p>\n<p><strong> 查询数组: </strong><br><code>Model.find({&#39;array&#39;:10} )</code>; 查询 array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到<br><code>Model.find({&#39;array[5]&#39;:10} )</code>; 查询 array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到<br><code>$all</code> 匹配数组中多个元素<br><code>Model.find({&#39;array&#39;:[5,10]} )</code>; 查询 匹配array数组中 既有5又有10的文档<br><code>$size</code> 匹配数组长度<br><code>Model.find({&#39;array&#39;:{&quot;$size&quot; : 3} } )</code>; 查询 匹配array数组长度为3 的文档<br><code>$slice</code> 查询子集合返回<br><code>Model.find({&#39;array&#39;:{&quot;$skice&quot; : 10} } )</code>; 查询 匹配array数组的前10个元素<br><code>Model.find({&#39;array&#39;:{&quot;$skice&quot; : [5,10] } } )</code>; 查询 匹配array数组的第5个到第10个元素</p>\n<p><strong> where </strong><br>用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//where</span></div><div class=\"line\"><span class=\"comment\">//查询数据类型是字符串时，可支持正则</span></div><div class=\"line\">User.where(<span class=\"string\">'age'</span>, <span class=\"string\">'2'</span>).exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">User</div><div class=\"line\">    .where(<span class=\"string\">'age'</span>).gte(<span class=\"number\">1</span>).lte(<span class=\"number\">10</span>)</div><div class=\"line\">    .where(<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>)</div><div class=\"line\">    .exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 游标: </strong><br><code>limit(3)</code> 限制返回结果的数量,<br><code>skip(3)</code> 跳过前3个文档,返回其余的<br><code>sort( {&#39;username&#39;:1 , &#39;age&#39;:-1 } )</code> 排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序</p>\n<h2 id=\"6-其他\"><a href=\"#6-其他\" class=\"headerlink\" title=\"6.其他\"></a>6.其他</h2><p><strong> 数量查询 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// //返回数量</span></div><div class=\"line\">User.count(&#123;<span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong> 分页查询 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"built_in\">require</span>(<span class=\"string\">\"./user.js\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getByPager</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pageSize = <span class=\"number\">5</span>;                   <span class=\"comment\">//一页多少条</span></div><div class=\"line\">    <span class=\"keyword\">var</span> currentPage = <span class=\"number\">1</span>;                <span class=\"comment\">//当前第几页</span></div><div class=\"line\">    <span class=\"keyword\">var</span> sort = &#123;<span class=\"string\">'logindate'</span>:<span class=\"number\">-1</span>&#125;;        <span class=\"comment\">//排序（按登录时间倒序）</span></div><div class=\"line\">    <span class=\"keyword\">var</span> condition = &#123;&#125;;                 <span class=\"comment\">//条件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> skipnum = (currentPage - <span class=\"number\">1</span>) * pageSize;   <span class=\"comment\">//跳过数</span></div><div class=\"line\">    User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Error:\"</span> + err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Res:\"</span> + res);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">getByPager();</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;&ensp;&ensp;最近在用express+mongoose写一个网站，因为经常要用到mongoose的一些操作命令，经常去查还挺麻烦的，所以总结一篇mongoose的使用以及一些操作命令。mongoose里面有三个概念，schemal、model、entity。先来对其三者做个小小的总结概括。<br><code>Schema</code> ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力<br><code>Model</code> ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对<br><code>Entity</code> ： 由Model创建的实体，他的操作也会影响数据库<br>","more":"<br>&ensp;&ensp;&ensp;&ensp;Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。<br>&ensp;&ensp;&ensp;&ensp;你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。</p>\n<h2 id=\"1-Schema\"><a href=\"#1-Schema\" class=\"headerlink\" title=\"1.Schema\"></a>1.Schema</h2><p>schema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；<br>每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力.<br>仅仅只是一段代码，无法通往数据库端, 仅仅只是数据库模型在程序片段中的一种表现</p>\n<p>定义Schema<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'./db.js'</span>),</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;          </div><div class=\"line\">    <span class=\"attr\">username</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span> &#125;,                    </div><div class=\"line\">    <span class=\"attr\">userpwd</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">String</span>&#125;,                        </div><div class=\"line\">    <span class=\"attr\">userage</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>&#125;,                       </div><div class=\"line\">    <span class=\"attr\">logindate</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>&#125;                      </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> Schema Types的内置类型 </strong></p>\n<ul>\n<li><code>String</code></li>\n<li><code>Number</code></li>\n<li><code>Boolean | Bool</code></li>\n<li><code>Array</code></li>\n<li><code>Buffer</code></li>\n<li><code>Date</code></li>\n<li><code>ObjectId | Oid</code></li>\n<li><code>Mixed</code></li>\n</ul>\n<h2 id=\"2-Model模型\"><a href=\"#2-Model模型\" class=\"headerlink\" title=\"2. Model模型\"></a>2. Model模型</h2><p>Model模型，是经过Schema构造来的，是Schema的编译版本。一个model的实例直接映射为数据库中的一个文档。基于这种关系， 以后的增删改查（CURD）都要通过这个Model实现。</p>\n<p>下面我们来定义我们的model<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'./db.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ObjectId = mongoose.Schema.ObjectId;</div><div class=\"line\"><span class=\"keyword\">var</span> UserSchema = <span class=\"keyword\">new</span> mongoose.Schema(&#123;          </div><div class=\"line\">    <span class=\"attr\">name</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">String</span> &#125;,                                       </div><div class=\"line\">    <span class=\"attr\">age</span>: &#123;<span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>&#125;,   </div><div class=\"line\">    <span class=\"attr\">updated</span>:&#123;<span class=\"attr\">type</span>:<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>&#125;,                  </div><div class=\"line\">    <span class=\"attr\">binary</span>:&#123; <span class=\"attr\">type</span>:Buffer &#125;,</div><div class=\"line\">    <span class=\"attr\">_id</span> : &#123; <span class=\"attr\">type</span>:ObjectId &#125;,</div><div class=\"line\">    <span class=\"attr\">mixed</span> : &#123; <span class=\"attr\">type</span>: Mixed &#125;,    </div><div class=\"line\">    <span class=\"attr\">isMerried</span> :&#123; <span class=\"attr\">type</span> : <span class=\"built_in\">Boolean</span> &#125;                                      </div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = mongoose.model(<span class=\"string\">'User'</span>,UserSchema);</div></pre></td></tr></table></figure></p>\n<p>定义好model之后，就可以往里面进行一些增删查改的操作了。</p>\n<h2 id=\"3-model-文档操作\"><a href=\"#3-model-文档操作\" class=\"headerlink\" title=\"3. model - 文档操作\"></a>3. model - 文档操作</h2><p><strong> 增加数据 </strong><br>如果是Entity，使用save方法，如果是Model，使用create方法<br><code>Model.create(data, callback))</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.create(data,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, doc</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(doc);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 查询 </strong><br><code>model.find({}, callback)</code>; 参数1忽略,或为空对象则返回所有集合文档<br><code>model.find({},field,callback)</code>;  过滤查询,参数2: {‘name’:1, ‘age’:0} 查询文档的返回结果包含name , field的值中,1为包括，0为不包括<br><code>model.find({},null,{limit:20})</code>; 过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.<br><code>model.findOne({}, callback)</code>; 查询找到的第一个文档<br><code>model.findById(&#39;obj._i&#39;, callback)</code>; 查询找到的第一个文档,同上. 但是只接 <code>_id</code> 的值查询<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//find</span></div><div class=\"line\">User.find(&#123;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//findOne</span></div><div class=\"line\">User.findOne(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'张三'</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//findByID 与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id //可以是字符串或 ObjectId 对象。</span></div><div class=\"line\">User.findById(id, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) consoel.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 更新 </strong><br><code>Model.update(conditions, data, [options], [callback])</code><br>conditions 更新条件<br>data 更新内容<br>option 更新选项<br>&ensp;&ensp;<code>safe (boolean)</code> 安全模式，默认选项，值为true<br>&ensp;&ensp;<code>upsert (boolean</code>) 条件不匹配时是否创建新文档，默认值为false<br>&ensp;&ensp;<code>multi (boolean)</code> 是否更新多个文件，默认值为false<br>&ensp;&ensp;<code>strict (boolean)</code> 严格模式，只更新一条数据<br>&ensp;&ensp;<code>overwrite (boolean)</code> 覆盖数据，默认为false<br>callback回调<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.update(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'张三'</span>&#125;, &#123;<span class=\"attr\">age</span>: <span class=\"string\">'6'</span>&#125;, &#123;<span class=\"attr\">multi</span> : <span class=\"literal\">true</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, numberAffected, raw</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 删除 </strong><br><code>Model.remove(conditions,callback);</code><br>参数1:查询条件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">User.remove(&#123;<span class=\"attr\">age</span>: <span class=\"number\">6</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-Entity-文档操作\"><a href=\"#4-Entity-文档操作\" class=\"headerlink\" title=\"4. Entity - 文档操作\"></a>4. Entity - 文档操作</h2><p>由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性<br>创建<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用Entity来增加一条数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> krouky = <span class=\"keyword\">new</span> PersonModel(&#123;<span class=\"attr\">name</span>:<span class=\"string\">'krouky'</span>&#125;);</div><div class=\"line\">krouky.save(callback);</div><div class=\"line\"><span class=\"comment\">//对比使用Model来增加一条数据</span></div><div class=\"line\"><span class=\"keyword\">var</span> MDragon = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'MDragon'</span>&#125;;</div><div class=\"line\">PersonModel.create(MDragon,callback);</div></pre></td></tr></table></figure></p>\n<h2 id=\"5-修改器和更新器\"><a href=\"#5-修改器和更新器\" class=\"headerlink\" title=\"5. 修改器和更新器\"></a>5. 修改器和更新器</h2><p><strong> 更新修改器 </strong><br><code>$inc</code> 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$inc'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"number\">1</span>&#125; &#125;  ); <span class=\"comment\">// 执行后: age=23</span></div></pre></td></tr></table></figure></p>\n<p><code>$set</code> 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$set'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"string\">'haha'</span>&#125; &#125;  ); <span class=\"comment\">// 执行后: age='haha'</span></div></pre></td></tr></table></figure></p>\n<p><code>$unset</code> 同上取反,删除一个键<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$unset'</span>:&#123;<span class=\"string\">'age'</span>:<span class=\"string\">'haha'</span>&#125; &#125;  ); <span class=\"comment\">//执行后: age键不存在`</span></div></pre></td></tr></table></figure></p>\n<p><strong> 数组修改器: </strong><br><code>$push</code>给一个键push一个数组成员,键不存在会创建<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$push'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">//执行后: 增加一个 array 键,类型为数组, 有一个成员 10`</span></div></pre></td></tr></table></figure></p>\n<p><code>$addToSet</code> 向数组中添加一个元素,如果存在就不添加<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$addToSet'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">// 执行后: array中有10所以不会添加</span></div></pre></td></tr></table></figure></p>\n<p><code>$each</code> 遍历数组, 和 $push 修改器配合可以插入多个值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$push'</span>:&#123;<span class=\"string\">'array'</span>:&#123;<span class=\"string\">'$each'</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]&#125;&#125; &#125; ); <span class=\"comment\">//执行后: array : [10,1,2,3,4,5]</span></div></pre></td></tr></table></figure></p>\n<p><code>$pop</code> 向数组中尾部删除一个元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$pop'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">1</span>&#125; &#125; ); <span class=\"comment\">//执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素</span></div></pre></td></tr></table></figure></p>\n<p><code>$pull</code> 向数组中删除指定元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.update(&#123;<span class=\"string\">'age'</span>:<span class=\"number\">22</span>&#125;, &#123;<span class=\"string\">'$pull'</span>:&#123;<span class=\"string\">'array'</span>:<span class=\"number\">10</span>&#125; &#125; ); <span class=\"comment\">// 执行后: array : [1,2,3,4] 匹配到array中的10后将其删除</span></div></pre></td></tr></table></figure></p>\n<p><strong> 条件查询: </strong><br><code>$lt</code>小于<br><code>$lte</code> 小于等于<br><code>$gt</code> 大于<br><code>$gte</code> 大于等于<br><code>$ne</code> 不等于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"string\">'age'</span>:&#123; <span class=\"string\">'$get'</span>:<span class=\"number\">18</span> , <span class=\"string\">'$lte'</span>:<span class=\"number\">30</span> &#125; &#125; ); <span class=\"comment\">//查询 age 大于等于18并小于等于30的文档</span></div></pre></td></tr></table></figure></p>\n<p><strong> 或查询 OR: </strong><br><code>$in</code>  一个键对应多个值<br><code>$nin</code> 同上取反, 一个键不对应指定值<br><code>$or</code>  多个条件匹配, 可以嵌套 $in 使用<br><code>$not</code> 同上取反, 查询与特定模式不匹配的文档<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"string\">'age'</span>:&#123; <span class=\"string\">'$in'</span>:[<span class=\"number\">20</span>,<span class=\"number\">21</span>,<span class=\"number\">22.</span><span class=\"string\">'haha'</span>]&#125; &#125; ); <span class=\"comment\">//查询 age等于20或21或21或'haha'的文档</span></div><div class=\"line\">Model.find(&#123;<span class=\"string\">'$or'</span> :  [ &#123;<span class=\"string\">'age'</span>:<span class=\"number\">18</span>&#125; , &#123;<span class=\"string\">'name'</span>:<span class=\"string\">'xueyou'</span>&#125; ] &#125;); <span class=\"comment\">//查询 age等于18 或 name等于'xueyou' 的文档</span></div></pre></td></tr></table></figure></p>\n<p><strong> 类型查询: </strong><br>null 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  ‘$exists’ 条件判定键值已经存在 “$exists” (表示是否存在的意思)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(<span class=\"string\">'age'</span> :  &#123; <span class=\"string\">'$in'</span> : [<span class=\"literal\">null</span>] , <span class=\"string\">'exists'</span> : <span class=\"literal\">true</span>  &#125; ); <span class=\"comment\">// 查询 age值为null的文档</span></div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Model.find(&#123;<span class=\"attr\">name</span>:&#123;<span class=\"attr\">$exists</span>:<span class=\"literal\">true</span>&#125;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error,docs</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//查询所有存在name属性的文档</span></div><div class=\"line\">&#125;);</div><div class=\"line\">Model.find(&#123;<span class=\"attr\">telephone</span>:&#123;<span class=\"attr\">$exists</span>:<span class=\"literal\">false</span>&#125;&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error,docs</span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//查询所有不存在telephone属性的文档</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong> 正则表达式: </strong><br>MongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">find( &#123;<span class=\"string\">'name'</span> : <span class=\"regexp\">/joe/i</span> &#125; );  <span class=\"comment\">//查询name为 joe 的文档, 并忽略大小写</span></div><div class=\"line\">find( &#123;<span class=\"string\">'name'</span> : <span class=\"regexp\">/joe?/i</span> &#125; ); <span class=\"comment\">//查询匹配各种大小写组合</span></div></pre></td></tr></table></figure></p>\n<p><strong> 查询数组: </strong><br><code>Model.find({&#39;array&#39;:10} )</code>; 查询 array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到<br><code>Model.find({&#39;array[5]&#39;:10} )</code>; 查询 array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到<br><code>$all</code> 匹配数组中多个元素<br><code>Model.find({&#39;array&#39;:[5,10]} )</code>; 查询 匹配array数组中 既有5又有10的文档<br><code>$size</code> 匹配数组长度<br><code>Model.find({&#39;array&#39;:{&quot;$size&quot; : 3} } )</code>; 查询 匹配array数组长度为3 的文档<br><code>$slice</code> 查询子集合返回<br><code>Model.find({&#39;array&#39;:{&quot;$skice&quot; : 10} } )</code>; 查询 匹配array数组的前10个元素<br><code>Model.find({&#39;array&#39;:{&quot;$skice&quot; : [5,10] } } )</code>; 查询 匹配array数组的第5个到第10个元素</p>\n<p><strong> where </strong><br>用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//where</span></div><div class=\"line\"><span class=\"comment\">//查询数据类型是字符串时，可支持正则</span></div><div class=\"line\">User.where(<span class=\"string\">'age'</span>, <span class=\"string\">'2'</span>).exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">User</div><div class=\"line\">    .where(<span class=\"string\">'age'</span>).gte(<span class=\"number\">1</span>).lte(<span class=\"number\">10</span>)</div><div class=\"line\">    .where(<span class=\"string\">'name'</span>, <span class=\"string\">'张三'</span>)</div><div class=\"line\">    .exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p><strong> 游标: </strong><br><code>limit(3)</code> 限制返回结果的数量,<br><code>skip(3)</code> 跳过前3个文档,返回其余的<br><code>sort( {&#39;username&#39;:1 , &#39;age&#39;:-1 } )</code> 排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序</p>\n<h2 id=\"6-其他\"><a href=\"#6-其他\" class=\"headerlink\" title=\"6.其他\"></a>6.其他</h2><p><strong> 数量查询 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// //返回数量</span></div><div class=\"line\">User.count(&#123;<span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"built_in\">console</span>.log(err);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong> 分页查询 </strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> User = <span class=\"built_in\">require</span>(<span class=\"string\">\"./user.js\"</span>);</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getByPager</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> pageSize = <span class=\"number\">5</span>;                   <span class=\"comment\">//一页多少条</span></div><div class=\"line\">    <span class=\"keyword\">var</span> currentPage = <span class=\"number\">1</span>;                <span class=\"comment\">//当前第几页</span></div><div class=\"line\">    <span class=\"keyword\">var</span> sort = &#123;<span class=\"string\">'logindate'</span>:<span class=\"number\">-1</span>&#125;;        <span class=\"comment\">//排序（按登录时间倒序）</span></div><div class=\"line\">    <span class=\"keyword\">var</span> condition = &#123;&#125;;                 <span class=\"comment\">//条件</span></div><div class=\"line\">    <span class=\"keyword\">var</span> skipnum = (currentPage - <span class=\"number\">1</span>) * pageSize;   <span class=\"comment\">//跳过数</span></div><div class=\"line\">    User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Error:\"</span> + err);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Res:\"</span> + res);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">getByPager();</div></pre></td></tr></table></figure></p>"},{"title":"hexo+github搭建自己的博客","date":"2017-04-08T07:08:32.000Z","_content":"\n之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。\n\n<!--more-->\n## 前期准备工作\n1. 安装hexo `npm install -g hexo`\n2. 创建一个文件夹，如：myBog，cd到myBog里执行`hexo init`命令\n3. 执行`hexo generate` （hexo g  也可以）  \n4. 执行`hexo server `   \n\n## hexo写博客的步骤\n\n### 新建一篇博客:\n\n* 方法1：\t\n```\nhexo new \"文章标题\"\n\n```\n* 方法2：在本地博客文件夹`source->_post`文件夹下看到我们新建的markdown文件\n\n两者的效果是一样的\n\n\n### 进行本地发布\n1. 执行命令 `hexo server`\n2. 浏览器打开：http://localhost:4000/\n\n### 部署到线上，执行三个命令\n1. `hexo clean`\n2. `hexo generate` 也可以 `hexo g`\n3. `hexo deploy`\n或者直接执行 hexo c && hexo g && hexo d\n\n## 一些常用命令\n`hexo new \"postName\"` #新建文章\n`hexo new page \"pageName\"` #新建页面\n`hexo generate` #生成静态页面至public目录\n`hexo server` #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n`hexo deploy` #将.deploy目录部署到GitHub\n`hexo help`  #查看帮助\n`hexo version`  #查看Hexo的版本\n\n## 小tips\n1. 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？ \n答：在文章中加一个 `<!--more-->` ， `<!--more-->` 后面的内容就不会显示出来了。\n\n2. 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 . \n答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。\n\n## 如何更换主题\n分为以下个步骤：\n1. 选择主题:哪里选呢，可以在这里[官方主题](https://hexo.io/themes/)\n2. 安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 `themes/yilia`\n3. 打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 `yilia`(你要安装的主题的文件夹名字) 。\n4. 验证主题是否启用: 运行 `hexo s --debug` ，并访问 `http://localhost:4000` ，确保站点正确运行。\n5. 部署和发布到文章的步骤一样\n\n## 头像设置\n在主题文件夹下的`_config.yml`中：`avatar: https://avatars1.githubusercontent.com/u/32269?v=3&s=460`.比如我的是`themes/yilia/_config.yml`\n由于我用的是yilia主题，或者直接修改`layout/_partial/left-col.ejs`的第六行和第八行为：\n```html\n <img src=\"<%=theme.avatar%>\" class=\"js-avatar show\">\n <img src=\"<%=theme.avatar%>\" class=\"js-avatar show\" style=\"width: 100%;height: 100%;opacity: 1;\">\n```\n## 添加阅读量\n计划使用 `Lean Cloud` 可以参考 [这里](http://crescentmoon.info/2014/12/11/popular-widget/#ds-thread)\n\n## 添加评论模块\n可以参考这篇文章：[评论模块](http://moxfive.xyz/2016/01/02/hexo-comments/?utm_source=tuicool&utm_medium=referral)\n本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄","source":"_posts/hexo+github搭建自己的博客.md","raw":"---\ntitle: hexo+github搭建自己的博客\ndate: 2017-04-8 15:08:32\ncategories:\ntags:\n    - hexo\n    - github\n---\n\n之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。\n\n<!--more-->\n## 前期准备工作\n1. 安装hexo `npm install -g hexo`\n2. 创建一个文件夹，如：myBog，cd到myBog里执行`hexo init`命令\n3. 执行`hexo generate` （hexo g  也可以）  \n4. 执行`hexo server `   \n\n## hexo写博客的步骤\n\n### 新建一篇博客:\n\n* 方法1：\t\n```\nhexo new \"文章标题\"\n\n```\n* 方法2：在本地博客文件夹`source->_post`文件夹下看到我们新建的markdown文件\n\n两者的效果是一样的\n\n\n### 进行本地发布\n1. 执行命令 `hexo server`\n2. 浏览器打开：http://localhost:4000/\n\n### 部署到线上，执行三个命令\n1. `hexo clean`\n2. `hexo generate` 也可以 `hexo g`\n3. `hexo deploy`\n或者直接执行 hexo c && hexo g && hexo d\n\n## 一些常用命令\n`hexo new \"postName\"` #新建文章\n`hexo new page \"pageName\"` #新建页面\n`hexo generate` #生成静态页面至public目录\n`hexo server` #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n`hexo deploy` #将.deploy目录部署到GitHub\n`hexo help`  #查看帮助\n`hexo version`  #查看Hexo的版本\n\n## 小tips\n1. 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？ \n答：在文章中加一个 `<!--more-->` ， `<!--more-->` 后面的内容就不会显示出来了。\n\n2. 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 . \n答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。\n\n## 如何更换主题\n分为以下个步骤：\n1. 选择主题:哪里选呢，可以在这里[官方主题](https://hexo.io/themes/)\n2. 安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 `themes/yilia`\n3. 打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 `yilia`(你要安装的主题的文件夹名字) 。\n4. 验证主题是否启用: 运行 `hexo s --debug` ，并访问 `http://localhost:4000` ，确保站点正确运行。\n5. 部署和发布到文章的步骤一样\n\n## 头像设置\n在主题文件夹下的`_config.yml`中：`avatar: https://avatars1.githubusercontent.com/u/32269?v=3&s=460`.比如我的是`themes/yilia/_config.yml`\n由于我用的是yilia主题，或者直接修改`layout/_partial/left-col.ejs`的第六行和第八行为：\n```html\n <img src=\"<%=theme.avatar%>\" class=\"js-avatar show\">\n <img src=\"<%=theme.avatar%>\" class=\"js-avatar show\" style=\"width: 100%;height: 100%;opacity: 1;\">\n```\n## 添加阅读量\n计划使用 `Lean Cloud` 可以参考 [这里](http://crescentmoon.info/2014/12/11/popular-widget/#ds-thread)\n\n## 添加评论模块\n可以参考这篇文章：[评论模块](http://moxfive.xyz/2016/01/02/hexo-comments/?utm_source=tuicool&utm_medium=referral)\n本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄","slug":"hexo+github搭建自己的博客","published":1,"updated":"2017-04-09T15:52:57.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr6z000d9gscacxtneb2","content":"<p>之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。</p>\n<a id=\"more\"></a>\n<h2 id=\"前期准备工作\"><a href=\"#前期准备工作\" class=\"headerlink\" title=\"前期准备工作\"></a>前期准备工作</h2><ol>\n<li>安装hexo <code>npm install -g hexo</code></li>\n<li>创建一个文件夹，如：myBog，cd到myBog里执行<code>hexo init</code>命令</li>\n<li>执行<code>hexo generate</code> （hexo g  也可以）  </li>\n<li>执行<code>hexo server</code>   </li>\n</ol>\n<h2 id=\"hexo写博客的步骤\"><a href=\"#hexo写博客的步骤\" class=\"headerlink\" title=\"hexo写博客的步骤\"></a>hexo写博客的步骤</h2><h3 id=\"新建一篇博客\"><a href=\"#新建一篇博客\" class=\"headerlink\" title=\"新建一篇博客:\"></a>新建一篇博客:</h3><ul>\n<li><p>方法1：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;文章标题&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法2：在本地博客文件夹<code>source-&gt;_post</code>文件夹下看到我们新建的markdown文件</p>\n</li>\n</ul>\n<p>两者的效果是一样的</p>\n<h3 id=\"进行本地发布\"><a href=\"#进行本地发布\" class=\"headerlink\" title=\"进行本地发布\"></a>进行本地发布</h3><ol>\n<li>执行命令 <code>hexo server</code></li>\n<li>浏览器打开：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000/</a></li>\n</ol>\n<h3 id=\"部署到线上，执行三个命令\"><a href=\"#部署到线上，执行三个命令\" class=\"headerlink\" title=\"部署到线上，执行三个命令\"></a>部署到线上，执行三个命令</h3><ol>\n<li><code>hexo clean</code></li>\n<li><code>hexo generate</code> 也可以 <code>hexo g</code></li>\n<li><code>hexo deploy</code><br>或者直接执行 hexo c &amp;&amp; hexo g &amp;&amp; hexo d</li>\n</ol>\n<h2 id=\"一些常用命令\"><a href=\"#一些常用命令\" class=\"headerlink\" title=\"一些常用命令\"></a>一些常用命令</h2><p><code>hexo new &quot;postName&quot;</code> #新建文章<br><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #将.deploy目录部署到GitHub<br><code>hexo help</code>  #查看帮助<br><code>hexo version</code>  #查看Hexo的版本</p>\n<h2 id=\"小tips\"><a href=\"#小tips\" class=\"headerlink\" title=\"小tips\"></a>小tips</h2><ol>\n<li><p>问：如何让文章想只显示一部分和一个 阅读全文 的按钮？<br>答：在文章中加一个 <code>&lt;!--more--&gt;</code> ， <code>&lt;!--more--&gt;</code> 后面的内容就不会显示出来了。</p>\n</li>\n<li><p>问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .<br>答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。</p>\n</li>\n</ol>\n<h2 id=\"如何更换主题\"><a href=\"#如何更换主题\" class=\"headerlink\" title=\"如何更换主题\"></a>如何更换主题</h2><p>分为以下个步骤：</p>\n<ol>\n<li>选择主题:哪里选呢，可以在这里<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">官方主题</a></li>\n<li>安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 <code>themes/yilia</code></li>\n<li>打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 <code>yilia</code>(你要安装的主题的文件夹名字) 。</li>\n<li>验证主题是否启用: 运行 <code>hexo s --debug</code> ，并访问 <code>http://localhost:4000</code> ，确保站点正确运行。</li>\n<li>部署和发布到文章的步骤一样</li>\n</ol>\n<h2 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h2><p>在主题文件夹下的<code>_config.yml</code>中：<code>avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</code>.比如我的是<code>themes/yilia/_config.yml</code><br>由于我用的是yilia主题，或者直接修改<code>layout/_partial/left-col.ejs</code>的第六行和第八行为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=theme.avatar%&gt;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"js-avatar show\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=theme.avatar%&gt;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"js-avatar show\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100%;height: 100%;opacity: 1;\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"添加阅读量\"><a href=\"#添加阅读量\" class=\"headerlink\" title=\"添加阅读量\"></a>添加阅读量</h2><p>计划使用 <code>Lean Cloud</code> 可以参考 <a href=\"http://crescentmoon.info/2014/12/11/popular-widget/#ds-thread\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h2 id=\"添加评论模块\"><a href=\"#添加评论模块\" class=\"headerlink\" title=\"添加评论模块\"></a>添加评论模块</h2><p>可以参考这篇文章：<a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/?utm_source=tuicool&amp;utm_medium=referral\" target=\"_blank\" rel=\"external\">评论模块</a><br>本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄</p>\n","site":{"data":{}},"excerpt":"<p>之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。</p>","more":"<h2 id=\"前期准备工作\"><a href=\"#前期准备工作\" class=\"headerlink\" title=\"前期准备工作\"></a>前期准备工作</h2><ol>\n<li>安装hexo <code>npm install -g hexo</code></li>\n<li>创建一个文件夹，如：myBog，cd到myBog里执行<code>hexo init</code>命令</li>\n<li>执行<code>hexo generate</code> （hexo g  也可以）  </li>\n<li>执行<code>hexo server</code>   </li>\n</ol>\n<h2 id=\"hexo写博客的步骤\"><a href=\"#hexo写博客的步骤\" class=\"headerlink\" title=\"hexo写博客的步骤\"></a>hexo写博客的步骤</h2><h3 id=\"新建一篇博客\"><a href=\"#新建一篇博客\" class=\"headerlink\" title=\"新建一篇博客:\"></a>新建一篇博客:</h3><ul>\n<li><p>方法1：    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;文章标题&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>方法2：在本地博客文件夹<code>source-&gt;_post</code>文件夹下看到我们新建的markdown文件</p>\n</li>\n</ul>\n<p>两者的效果是一样的</p>\n<h3 id=\"进行本地发布\"><a href=\"#进行本地发布\" class=\"headerlink\" title=\"进行本地发布\"></a>进行本地发布</h3><ol>\n<li>执行命令 <code>hexo server</code></li>\n<li>浏览器打开：<a href=\"http://localhost:4000/\">http://localhost:4000/</a></li>\n</ol>\n<h3 id=\"部署到线上，执行三个命令\"><a href=\"#部署到线上，执行三个命令\" class=\"headerlink\" title=\"部署到线上，执行三个命令\"></a>部署到线上，执行三个命令</h3><ol>\n<li><code>hexo clean</code></li>\n<li><code>hexo generate</code> 也可以 <code>hexo g</code></li>\n<li><code>hexo deploy</code><br>或者直接执行 hexo c &amp;&amp; hexo g &amp;&amp; hexo d</li>\n</ol>\n<h2 id=\"一些常用命令\"><a href=\"#一些常用命令\" class=\"headerlink\" title=\"一些常用命令\"></a>一些常用命令</h2><p><code>hexo new &quot;postName&quot;</code> #新建文章<br><code>hexo new page &quot;pageName&quot;</code> #新建页面<br><code>hexo generate</code> #生成静态页面至public目录<br><code>hexo server</code> #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br><code>hexo deploy</code> #将.deploy目录部署到GitHub<br><code>hexo help</code>  #查看帮助<br><code>hexo version</code>  #查看Hexo的版本</p>\n<h2 id=\"小tips\"><a href=\"#小tips\" class=\"headerlink\" title=\"小tips\"></a>小tips</h2><ol>\n<li><p>问：如何让文章想只显示一部分和一个 阅读全文 的按钮？<br>答：在文章中加一个 <code>&lt;!--more--&gt;</code> ， <code>&lt;!--more--&gt;</code> 后面的内容就不会显示出来了。</p>\n</li>\n<li><p>问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .<br>答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。</p>\n</li>\n</ol>\n<h2 id=\"如何更换主题\"><a href=\"#如何更换主题\" class=\"headerlink\" title=\"如何更换主题\"></a>如何更换主题</h2><p>分为以下个步骤：</p>\n<ol>\n<li>选择主题:哪里选呢，可以在这里<a href=\"https://hexo.io/themes/\">官方主题</a></li>\n<li>安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 <code>themes/yilia</code></li>\n<li>打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 <code>yilia</code>(你要安装的主题的文件夹名字) 。</li>\n<li>验证主题是否启用: 运行 <code>hexo s --debug</code> ，并访问 <code>http://localhost:4000</code> ，确保站点正确运行。</li>\n<li>部署和发布到文章的步骤一样</li>\n</ol>\n<h2 id=\"头像设置\"><a href=\"#头像设置\" class=\"headerlink\" title=\"头像设置\"></a>头像设置</h2><p>在主题文件夹下的<code>_config.yml</code>中：<code>avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460</code>.比如我的是<code>themes/yilia/_config.yml</code><br>由于我用的是yilia主题，或者直接修改<code>layout/_partial/left-col.ejs</code>的第六行和第八行为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=theme.avatar%&gt;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"js-avatar show\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&lt;%=theme.avatar%&gt;\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"js-avatar show\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 100%;height: 100%;opacity: 1;\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"添加阅读量\"><a href=\"#添加阅读量\" class=\"headerlink\" title=\"添加阅读量\"></a>添加阅读量</h2><p>计划使用 <code>Lean Cloud</code> 可以参考 <a href=\"http://crescentmoon.info/2014/12/11/popular-widget/#ds-thread\">这里</a></p>\n<h2 id=\"添加评论模块\"><a href=\"#添加评论模块\" class=\"headerlink\" title=\"添加评论模块\"></a>添加评论模块</h2><p>可以参考这篇文章：<a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/?utm_source=tuicool&amp;utm_medium=referral\">评论模块</a><br>本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄</p>"},{"title":"手写一个router","date":"2017-06-18T15:05:00.000Z","_content":"\n>\t最近在玩vue,之前玩的react等，都有涉及到router的概念，router的入门不难，本着好奇的心态，想自己用js写一个router，纯属娱乐，应该不可用于实际项目\n\n<!--more-->\n\n## 前期知识准备\n1. HTML5提供了一个新的API `History `\nHistory: 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录。\n\n2. window中有个`hashchange`事件，当 url 的 hash 发生变化时，会触发该事件\n\n## 先来个简单版本\n我们的ruoter先来个简单点的，暂时不用H5的新api，而是通过url中的hashg改变，触发hashchange事件来执行。\n\n思路：\n1. 首先我们需要一个容器来存储我们更新url时的回调函数。\n2. 当执行当前url对应的回调函数时，我们需要更新我们的页面\n3. 我们需要监听url中hash的改变\n\n根据我们上面的思路，我们可以构思出下面的代码\n```javascript\nfunction Router() {\n\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\tthis.currentUrl = ''; //当前路由\n}\n// 注册路由路径和存储回调函数\nRouter.prototype.route = function(path,callback) {\n\tthis.routers[path] = callback || function() {}\n}\n// 更新页面，其实就是执行注册的回调函数\nRouter.prototype.refresh = function() {\n\tthis.currentUrl = location.hash.slice(1) || '/';\n\tthis.routers[this.currentUrl]();\n}\nRouter.prototype.init = function() {\n\twindow.addEventListener('load',this.refresh.bind(this),false);\n\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n}\n\nwindow.Router = new Router();\nwindow.Router.init();\n```\n经过上面的代买，我们搭建起了一个简单的路由，接下来我们来实战一下\n```html\n<ul> \n    <li><a href=\"#/\">index</a></li> \n    <li><a href=\"#/page1\">page1</a></li> \n    <li><a href=\"#/page2\">page2</a></li> \n</ul> \n<p class=\"text\"></p>\n\n<script>\nvar text = document.querySelector('.text');\nRouter.route('/', function() {\n\ttext.innerHTML = '这里是首页';\n});\nRouter.route('/page1', function() {\n    text.innerHTML = '这里是page1';\n});\nRouter.route('/page2', function() {\n    text.innerHTML = '这里是page2';\n});\n</script>\n```\n这样，我们点击不同路由，显示不同路由对应的文字 ,点击查看<a href=\"/demo/router1.html\" target=\"_blank\">demo</a>\n\n## 再来个复杂版本\n通过上面的代码，我们完成了一个简单的js Router,接下来我们再来一个稍微高级一点的版本，真正实现一个router库\n我们封装一下我们的代码，\n\n```javascript\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\nvar Router = {\n\t\n    /**\n     * 注册的所有路由对象\n     */\n    hashList: {},\n\t\n\t/**\n\t * 当前路由\n\t */\n    index: null,\n   \n\n    /**\n     * Add router\n     * 注册路由对象\n\t**/\n    add: function (path,callback) {\n    \t\n        this.hashList[path] = callback;\n    },\n    \n    /**\n     * 跳转到指定路由\n     */\n    go: function(path) {\n    \t\n    \twindow.location.hash = '#' + path;\n    },\n    \n    /**\n     * 删除路由\n     */\n    remove: function(path) {\t \n    \t\n        delete this.hashList[path];\n    },\n    /**\n     * 重新加载页面\n     */\n    reload:function() {\n    \tvar self = this;\n        var hash = window.location.hash.replace('#', '');\n        var addr = hash.split('/')[0];\n        var cb =   self.getCb(addr, self.hashList);\n        if(cb != false) {\n            var arr = hash.split('/');\n            arr.shift();\n            cb.apply(self, arr);\n        } else {\n            self.index && self.go(self.index);\n        }\n    },\n\n \t/**\n     * 设置主页地址\n     * @param index: 主页地址\n     */\n    setIndex: function(index) {\n        this.index = index;\n    },\n    \n     /**\n     * 获取callback\n     * @return false or callback\n     */\n    getCb: function(addr, hashList) {\n        for(var key in hashList) {\n            if(key == addr) {\n                return hashList[key]\n            }\n        }\n        return false;\n    },\n    \n    /**\n     * 初始化路由\n     */\n    init: function (options) {\n    \tvar self = this;\n    \twindow.onhashchange = function() {\n            self.reload();\n        };\n    },\n    start: function() {\n    \tthis.reload();\n    }\n};\n\nreturn Router;\n    \n}));\n```\n使用方法：\n```html\n<a href=\"#index\">首页</a>\n<a href=\"#detail/1654499\">详情页</a>\n<script>\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n</script>\n```\n这里查看<a href=\"/demo/router2.html\" target=\"_blank\">demo</a>\n\n\n&ensp;&ensp;&ensp;这样，我们的简单的路由器就完成了，后面我们将HTML5的history API搞进来，弄成一个即可用hash，也可以用history的版本\n\n","source":"_posts/手写一个router.md","raw":"---\ntitle: 手写一个router\ndate: 2017-06-18 23:05\ncategories:\ntags: [router,js]\n---\n\n>\t最近在玩vue,之前玩的react等，都有涉及到router的概念，router的入门不难，本着好奇的心态，想自己用js写一个router，纯属娱乐，应该不可用于实际项目\n\n<!--more-->\n\n## 前期知识准备\n1. HTML5提供了一个新的API `History `\nHistory: 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录。\n\n2. window中有个`hashchange`事件，当 url 的 hash 发生变化时，会触发该事件\n\n## 先来个简单版本\n我们的ruoter先来个简单点的，暂时不用H5的新api，而是通过url中的hashg改变，触发hashchange事件来执行。\n\n思路：\n1. 首先我们需要一个容器来存储我们更新url时的回调函数。\n2. 当执行当前url对应的回调函数时，我们需要更新我们的页面\n3. 我们需要监听url中hash的改变\n\n根据我们上面的思路，我们可以构思出下面的代码\n```javascript\nfunction Router() {\n\tthis.routers = {};    //存储路由回调函数,以传入的路径为key,callback为value\n\tthis.currentUrl = ''; //当前路由\n}\n// 注册路由路径和存储回调函数\nRouter.prototype.route = function(path,callback) {\n\tthis.routers[path] = callback || function() {}\n}\n// 更新页面，其实就是执行注册的回调函数\nRouter.prototype.refresh = function() {\n\tthis.currentUrl = location.hash.slice(1) || '/';\n\tthis.routers[this.currentUrl]();\n}\nRouter.prototype.init = function() {\n\twindow.addEventListener('load',this.refresh.bind(this),false);\n\twindow.addEventListener('hashchange',this.refresh.bind(this),false);\n}\n\nwindow.Router = new Router();\nwindow.Router.init();\n```\n经过上面的代买，我们搭建起了一个简单的路由，接下来我们来实战一下\n```html\n<ul> \n    <li><a href=\"#/\">index</a></li> \n    <li><a href=\"#/page1\">page1</a></li> \n    <li><a href=\"#/page2\">page2</a></li> \n</ul> \n<p class=\"text\"></p>\n\n<script>\nvar text = document.querySelector('.text');\nRouter.route('/', function() {\n\ttext.innerHTML = '这里是首页';\n});\nRouter.route('/page1', function() {\n    text.innerHTML = '这里是page1';\n});\nRouter.route('/page2', function() {\n    text.innerHTML = '这里是page2';\n});\n</script>\n```\n这样，我们点击不同路由，显示不同路由对应的文字 ,点击查看<a href=\"/demo/router1.html\" target=\"_blank\">demo</a>\n\n## 再来个复杂版本\n通过上面的代码，我们完成了一个简单的js Router,接下来我们再来一个稍微高级一点的版本，真正实现一个router库\n我们封装一下我们的代码，\n\n```javascript\n;(function (global, factory) {\n\n    if (typeof define === 'function' && (define.amd || define.cmd)) {\n        //AMD/CMD\n        define(function (global) {\n            return factory(global);\n        });\n    } else if (typeof module === 'object' && typeof module.exports === 'object') {\n        //CommonJS\n        module.exports = factory(global);\n    } else {\n        //Browser\n        global.Router = factory(global);\n    }\n\n}(typeof window !== 'undefined' ? window : this, function (window) {\n\nvar Router = {\n\t\n    /**\n     * 注册的所有路由对象\n     */\n    hashList: {},\n\t\n\t/**\n\t * 当前路由\n\t */\n    index: null,\n   \n\n    /**\n     * Add router\n     * 注册路由对象\n\t**/\n    add: function (path,callback) {\n    \t\n        this.hashList[path] = callback;\n    },\n    \n    /**\n     * 跳转到指定路由\n     */\n    go: function(path) {\n    \t\n    \twindow.location.hash = '#' + path;\n    },\n    \n    /**\n     * 删除路由\n     */\n    remove: function(path) {\t \n    \t\n        delete this.hashList[path];\n    },\n    /**\n     * 重新加载页面\n     */\n    reload:function() {\n    \tvar self = this;\n        var hash = window.location.hash.replace('#', '');\n        var addr = hash.split('/')[0];\n        var cb =   self.getCb(addr, self.hashList);\n        if(cb != false) {\n            var arr = hash.split('/');\n            arr.shift();\n            cb.apply(self, arr);\n        } else {\n            self.index && self.go(self.index);\n        }\n    },\n\n \t/**\n     * 设置主页地址\n     * @param index: 主页地址\n     */\n    setIndex: function(index) {\n        this.index = index;\n    },\n    \n     /**\n     * 获取callback\n     * @return false or callback\n     */\n    getCb: function(addr, hashList) {\n        for(var key in hashList) {\n            if(key == addr) {\n                return hashList[key]\n            }\n        }\n        return false;\n    },\n    \n    /**\n     * 初始化路由\n     */\n    init: function (options) {\n    \tvar self = this;\n    \twindow.onhashchange = function() {\n            self.reload();\n        };\n    },\n    start: function() {\n    \tthis.reload();\n    }\n};\n\nreturn Router;\n    \n}));\n```\n使用方法：\n```html\n<a href=\"#index\">首页</a>\n<a href=\"#detail/1654499\">详情页</a>\n<script>\nRouter.init();\nRouter.add('index', function() {\n    alert('这里是首页的内容');\n    });\n \n    Router.add('detail', function(id) {\n    alert('这里是详情页，id为'+id);\n});\nRouter.setIndex('index'); //设置首页\nRouter.start();\n</script>\n```\n这里查看<a href=\"/demo/router2.html\" target=\"_blank\">demo</a>\n\n\n&ensp;&ensp;&ensp;这样，我们的简单的路由器就完成了，后面我们将HTML5的history API搞进来，弄成一个即可用hash，也可以用history的版本\n\n","slug":"手写一个router","published":1,"updated":"2017-06-25T02:46:22.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr77000f9gscu2nvdll9","content":"<blockquote>\n<p>   最近在玩vue,之前玩的react等，都有涉及到router的概念，router的入门不难，本着好奇的心态，想自己用js写一个router，纯属娱乐，应该不可用于实际项目</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"前期知识准备\"><a href=\"#前期知识准备\" class=\"headerlink\" title=\"前期知识准备\"></a>前期知识准备</h2><ol>\n<li><p>HTML5提供了一个新的API <code>History</code><br>History: 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录。</p>\n</li>\n<li><p>window中有个<code>hashchange</code>事件，当 url 的 hash 发生变化时，会触发该事件</p>\n</li>\n</ol>\n<h2 id=\"先来个简单版本\"><a href=\"#先来个简单版本\" class=\"headerlink\" title=\"先来个简单版本\"></a>先来个简单版本</h2><p>我们的ruoter先来个简单点的，暂时不用H5的新api，而是通过url中的hashg改变，触发hashchange事件来执行。</p>\n<p>思路：</p>\n<ol>\n<li>首先我们需要一个容器来存储我们更新url时的回调函数。</li>\n<li>当执行当前url对应的回调函数时，我们需要更新我们的页面</li>\n<li>我们需要监听url中hash的改变</li>\n</ol>\n<p>根据我们上面的思路，我们可以构思出下面的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Router</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers = &#123;&#125;;    <span class=\"comment\">//存储路由回调函数,以传入的路径为key,callback为value</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>; <span class=\"comment\">//当前路由</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 注册路由路径和存储回调函数</span></div><div class=\"line\">Router.prototype.route = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path,callback</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 更新页面，其实就是执行注册的回调函数</span></div><div class=\"line\">Router.prototype.refresh = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers[<span class=\"keyword\">this</span>.currentUrl]();</div><div class=\"line\">&#125;</div><div class=\"line\">Router.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>,<span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>),<span class=\"literal\">false</span>);</div><div class=\"line\">\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>,<span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>),<span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.Router = <span class=\"keyword\">new</span> Router();</div><div class=\"line\"><span class=\"built_in\">window</span>.Router.init();</div></pre></td></tr></table></figure></p>\n<p>经过上面的代买，我们搭建起了一个简单的路由，接下来我们来实战一下<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/\"</span>&gt;</span>index<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/page1\"</span>&gt;</span>page1<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/page2\"</span>&gt;</span>page2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.text'</span>);</div><div class=\"line\">Router.route(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\ttext.innerHTML = <span class=\"string\">'这里是首页'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.route(<span class=\"string\">'/page1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    text.innerHTML = <span class=\"string\">'这里是page1'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.route(<span class=\"string\">'/page2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    text.innerHTML = <span class=\"string\">'这里是page2'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这样，我们点击不同路由，显示不同路由对应的文字 ,点击查看<a href=\"/demo/router1.html\" target=\"_blank\">demo</a></p>\n<h2 id=\"再来个复杂版本\"><a href=\"#再来个复杂版本\" class=\"headerlink\" title=\"再来个复杂版本\"></a>再来个复杂版本</h2><p>通过上面的代码，我们完成了一个简单的js Router,接下来我们再来一个稍微高级一点的版本，真正实现一个router库<br>我们封装一下我们的代码，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global, factory</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span> &amp;&amp; (define.amd || define.cmd)) &#123;</div><div class=\"line\">        <span class=\"comment\">//AMD/CMD</span></div><div class=\"line\">        define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> factory(global);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span>.exports === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//CommonJS</span></div><div class=\"line\">        <span class=\"built_in\">module</span>.exports = factory(global);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//Browser</span></div><div class=\"line\">        global.Router = factory(global);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">window</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Router = &#123;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 注册的所有路由对象</div><div class=\"line\">     */</div><div class=\"line\">    hashList: &#123;&#125;,</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">\t * 当前路由</div><div class=\"line\">\t */</div><div class=\"line\">    index: <span class=\"literal\">null</span>,</div><div class=\"line\">   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * Add router</div><div class=\"line\">     * 注册路由对象</div><div class=\"line\">\t**/</div><div class=\"line\">    add: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">path,callback</span>) </span>&#123;</div><div class=\"line\">    \t</div><div class=\"line\">        <span class=\"keyword\">this</span>.hashList[path] = callback;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 跳转到指定路由</div><div class=\"line\">     */</div><div class=\"line\">    go: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">    \t</div><div class=\"line\">    \t<span class=\"built_in\">window</span>.location.hash = <span class=\"string\">'#'</span> + path;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 删除路由</div><div class=\"line\">     */</div><div class=\"line\">    remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;\t </div><div class=\"line\">    \t</div><div class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.hashList[path];</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 重新加载页面</div><div class=\"line\">     */</div><div class=\"line\">    reload:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash.replace(<span class=\"string\">'#'</span>, <span class=\"string\">''</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> addr = hash.split(<span class=\"string\">'/'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> cb =   self.getCb(addr, self.hashList);</div><div class=\"line\">        <span class=\"keyword\">if</span>(cb != <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> arr = hash.split(<span class=\"string\">'/'</span>);</div><div class=\"line\">            arr.shift();</div><div class=\"line\">            cb.apply(self, arr);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            self.index &amp;&amp; self.go(self.index);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\"> \t<span class=\"comment\">/**</span></div><div class=\"line\">     * 设置主页地址</div><div class=\"line\">     * @param index: 主页地址</div><div class=\"line\">     */</div><div class=\"line\">    setIndex: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"comment\">/**</span></div><div class=\"line\">     * 获取callback</div><div class=\"line\">     * @return false or callback</div><div class=\"line\">     */</div><div class=\"line\">    getCb: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">addr, hashList</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> hashList) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key == addr) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> hashList[key]</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * 初始化路由</div><div class=\"line\">     */</div><div class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">    \t<span class=\"built_in\">window</span>.onhashchange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            self.reload();</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">start</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">this</span>.reload();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">return</span> Router;</div><div class=\"line\">    </div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<p>使用方法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#index\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#detail/1654499\"</span>&gt;</span>详情页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">Router.init();</div><div class=\"line\">Router.add(<span class=\"string\">'index'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'这里是首页的内容'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"> </div><div class=\"line\">    Router.add(<span class=\"string\">'detail'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'这里是详情页，id为'</span>+id);</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.setIndex(<span class=\"string\">'index'</span>); <span class=\"comment\">//设置首页</span></div><div class=\"line\">Router.start();</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里查看<a href=\"/demo/router2.html\" target=\"_blank\">demo</a></p>\n<p>&ensp;&ensp;&ensp;这样，我们的简单的路由器就完成了，后面我们将HTML5的history API搞进来，弄成一个即可用hash，也可以用history的版本</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>   最近在玩vue,之前玩的react等，都有涉及到router的概念，router的入门不难，本着好奇的心态，想自己用js写一个router，纯属娱乐，应该不可用于实际项目</p>\n</blockquote>","more":"<h2 id=\"前期知识准备\"><a href=\"#前期知识准备\" class=\"headerlink\" title=\"前期知识准备\"></a>前期知识准备</h2><ol>\n<li><p>HTML5提供了一个新的API <code>History</code><br>History: 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录。</p>\n</li>\n<li><p>window中有个<code>hashchange</code>事件，当 url 的 hash 发生变化时，会触发该事件</p>\n</li>\n</ol>\n<h2 id=\"先来个简单版本\"><a href=\"#先来个简单版本\" class=\"headerlink\" title=\"先来个简单版本\"></a>先来个简单版本</h2><p>我们的ruoter先来个简单点的，暂时不用H5的新api，而是通过url中的hashg改变，触发hashchange事件来执行。</p>\n<p>思路：</p>\n<ol>\n<li>首先我们需要一个容器来存储我们更新url时的回调函数。</li>\n<li>当执行当前url对应的回调函数时，我们需要更新我们的页面</li>\n<li>我们需要监听url中hash的改变</li>\n</ol>\n<p>根据我们上面的思路，我们可以构思出下面的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Router</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers = &#123;&#125;;    <span class=\"comment\">//存储路由回调函数,以传入的路径为key,callback为value</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>; <span class=\"comment\">//当前路由</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 注册路由路径和存储回调函数</span></div><div class=\"line\">Router.prototype.route = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path,callback</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 更新页面，其实就是执行注册的回调函数</span></div><div class=\"line\">Router.prototype.refresh = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.currentUrl = location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.routers[<span class=\"keyword\">this</span>.currentUrl]();</div><div class=\"line\">&#125;</div><div class=\"line\">Router.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>,<span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>),<span class=\"literal\">false</span>);</div><div class=\"line\">\t<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>,<span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>),<span class=\"literal\">false</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">window</span>.Router = <span class=\"keyword\">new</span> Router();</div><div class=\"line\"><span class=\"built_in\">window</span>.Router.init();</div></pre></td></tr></table></figure></p>\n<p>经过上面的代买，我们搭建起了一个简单的路由，接下来我们来实战一下<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/\"</span>&gt;</span>index<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/page1\"</span>&gt;</span>page1<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#/page2\"</span>&gt;</span>page2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.text'</span>);</div><div class=\"line\">Router.route(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\ttext.innerHTML = <span class=\"string\">'这里是首页'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.route(<span class=\"string\">'/page1'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    text.innerHTML = <span class=\"string\">'这里是page1'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.route(<span class=\"string\">'/page2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    text.innerHTML = <span class=\"string\">'这里是page2'</span>;</div><div class=\"line\">&#125;);</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这样，我们点击不同路由，显示不同路由对应的文字 ,点击查看<a href=\"/demo/router1.html\" target=\"_blank\">demo</a></p>\n<h2 id=\"再来个复杂版本\"><a href=\"#再来个复杂版本\" class=\"headerlink\" title=\"再来个复杂版本\"></a>再来个复杂版本</h2><p>通过上面的代码，我们完成了一个简单的js Router,接下来我们再来一个稍微高级一点的版本，真正实现一个router库<br>我们封装一下我们的代码，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\">;(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global, factory</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span> &amp;&amp; (define.amd || define.cmd)) &#123;</div><div class=\"line\">        <span class=\"comment\">//AMD/CMD</span></div><div class=\"line\">        define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">global</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> factory(global);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span>.exports === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">//CommonJS</span></div><div class=\"line\">        <span class=\"built_in\">module</span>.exports = factory(global);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//Browser</span></div><div class=\"line\">        global.Router = factory(global);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;(<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span> ? <span class=\"built_in\">window</span> : <span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">window</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Router = &#123;</div><div class=\"line\">\t</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 注册的所有路由对象</div><div class=\"line\">     */</span></div><div class=\"line\">    hashList: &#123;&#125;,</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">\t * 当前路由</div><div class=\"line\">\t */</span></div><div class=\"line\">    index: <span class=\"literal\">null</span>,</div><div class=\"line\">   </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * Add router</div><div class=\"line\">     * 注册路由对象</div><div class=\"line\">\t**/</span></div><div class=\"line\">    add: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">path,callback</span>) </span>&#123;</div><div class=\"line\">    \t</div><div class=\"line\">        <span class=\"keyword\">this</span>.hashList[path] = callback;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 跳转到指定路由</div><div class=\"line\">     */</span></div><div class=\"line\">    go: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</div><div class=\"line\">    \t</div><div class=\"line\">    \t<span class=\"built_in\">window</span>.location.hash = <span class=\"string\">'#'</span> + path;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 删除路由</div><div class=\"line\">     */</span></div><div class=\"line\">    remove: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;\t </div><div class=\"line\">    \t</div><div class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>.hashList[path];</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 重新加载页面</div><div class=\"line\">     */</span></div><div class=\"line\">    reload:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> hash = <span class=\"built_in\">window</span>.location.hash.replace(<span class=\"string\">'#'</span>, <span class=\"string\">''</span>);</div><div class=\"line\">        <span class=\"keyword\">var</span> addr = hash.split(<span class=\"string\">'/'</span>)[<span class=\"number\">0</span>];</div><div class=\"line\">        <span class=\"keyword\">var</span> cb =   self.getCb(addr, self.hashList);</div><div class=\"line\">        <span class=\"keyword\">if</span>(cb != <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> arr = hash.split(<span class=\"string\">'/'</span>);</div><div class=\"line\">            arr.shift();</div><div class=\"line\">            cb.apply(self, arr);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            self.index &amp;&amp; self.go(self.index);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\"> \t<span class=\"comment\">/**</div><div class=\"line\">     * 设置主页地址</div><div class=\"line\">     * @param index: 主页地址</div><div class=\"line\">     */</span></div><div class=\"line\">    setIndex: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.index = index;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">     <span class=\"comment\">/**</div><div class=\"line\">     * 获取callback</div><div class=\"line\">     * @return false or callback</div><div class=\"line\">     */</span></div><div class=\"line\">    getCb: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">addr, hashList</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> hashList) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(key == addr) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> hashList[key]</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</div><div class=\"line\">     * 初始化路由</div><div class=\"line\">     */</span></div><div class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">options</span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">    \t<span class=\"built_in\">window</span>.onhashchange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            self.reload();</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">start</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    \t<span class=\"keyword\">this</span>.reload();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">return</span> Router;</div><div class=\"line\">    </div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<p>使用方法：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#index\"</span>&gt;</span>首页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#detail/1654499\"</span>&gt;</span>详情页<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">Router.init();</div><div class=\"line\">Router.add(<span class=\"string\">'index'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'这里是首页的内容'</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\"> </div><div class=\"line\">    Router.add(<span class=\"string\">'detail'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">    alert(<span class=\"string\">'这里是详情页，id为'</span>+id);</div><div class=\"line\">&#125;);</div><div class=\"line\">Router.setIndex(<span class=\"string\">'index'</span>); <span class=\"comment\">//设置首页</span></div><div class=\"line\">Router.start();</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>这里查看<a href=\"/demo/router2.html\" target=\"_blank\">demo</a></p>\n<p>&ensp;&ensp;&ensp;这样，我们的简单的路由器就完成了，后面我们将HTML5的history API搞进来，弄成一个即可用hash，也可以用history的版本</p>"},{"title":"老生常谈-从输入url到页面展示到底发生了什么","date":"2017-03-22T12:07:00.000Z","_content":"\n> &ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。\n &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。\n\n<!--more-->\n\n总的过程大概如下:\n\n## 1、输入地址\n\n &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。\n\n\n## 2、浏览器查找域名的 IP 地址　　\n&ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。\n&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。\n&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。\n&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。\n&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。\n&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。\n下面这张图很完美的解释了这一过程：\n\n![图片](http://www.maixj.net/wp-content/uploads/2015/10/dns.jpg?_=6547807)\n\n **----知识扩展---- **\n\n**1)什么是DNS？**\n　　DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。\n　　通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。\n\n**2)DNS查询的两种方式：递归查询和迭代查询**\n\n1、递归解析\n    当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。\n![图](http://s16.sinaimg.cn/mw690/4078ccd6hcdcf48aab7af&690?_=6547807)\n    \n2、迭代解析\n　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。\n![](http://s12.sinaimg.cn/mw690/4078ccd6h7afb21339ebb&690?_=6547807)\n\n**3)DNS域名称空间的组织方式**\n\n 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例\n![](http://img1.51cto.com/attachment/201203/171409287.jpg?_=6547807)\n\n**4)DNS负载均衡**\n　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n　　\n\n## 3、浏览器向 web 服务器发送一个 HTTP 请求\n　　拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。\n　　\nTCP连接如图所示:\n![](http://img.bitscn.com/upimg/allimg/c160831/14H61600J21Z-2N62.jpg?_=6547807)\n\n　　建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。\n　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：\n- 请求方法URI协议/版本\n- 请求头(Request Header)\n- 请求正文：\n\n下面是一个完整的HTTP请求例子：\n```bash\nGET/sample.jspHTTP/1.1\nAccept:image/gif.image/jpeg,*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)\nAccept-Encoding:gzip,deflate\n\nusername=jinqiao&password=1234\n```\n 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n\n（1）请求的第一行是“方法URL议/版本”：`GET/sample.jsp HTTP/1.1`\n（2）请求头(Request Header)\n　　 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。\n```bash\nAccept:image/gif.image/jpeg.*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)\nAccept-Encoding:gzip,deflate.\n```\n（3）请求正文\n    请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：\n\n`username=jinqiao&password=1234`\n \n**---- 知识扩展----**\n\n**1）TCP三次握手**\n- 第一次握手：客户端A将标志位SYN置为1,随机产生一个值为`seq=J`（J的取值范围为=1234567）的数据包到服务器，客户端A进入`SYN_SENT`状态，等待服务端B确认；\n- 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个值`seq=K`，并将该数据包发送给客户端A以确认连接请求，服务端B进入`SYN_RCVD`状态。\n- 第三次握手：客户端A收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务端B，服务端B检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入`ESTABLISHED`状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。\n\n如图所示：\n![](http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png?_=6547807)\n\n**2）为什需要三次握手？**\n&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”\n&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。\n\n**3）TCP四次挥手**\n- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。\n- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n\n![](http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png?_=6547807)\n\n**4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**\n　　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n\n\n\n## 4、服务器的永久重定向响应\n 　　服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问`http://www.google.com/` 而非`http://google.com/`。\n　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像`http://www.yy.com/`和`http://yy.com/`，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。\n\n**----扩展知识----**\n\n**1）301和302的区别。**\n　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。\n　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；\n　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301\n\n**2）重定向原因：**\n（1）网站调整（如改变网页目录结构）；\n（2）网页被移到一个新地址；\n（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。\n        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。\n\n**3）什么时候进行301或者302跳转呢？**\n&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。\n清晰明确而言：使用301跳转的大概场景如下：\n- 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。\n- 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n- 空间服务器不稳定，换空间的时候。\n\n \n## 5、浏览器跟踪重定向地址\n\n   现在浏览器知道了 `\"http://www.google.com/\"`才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的\n\n\n## 6、服务器处理请求\n　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？\n　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。\n　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n如图所示：\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1489904964343&di=c6043cd72bb60f4e129589b6a8f79299&imgtype=0&src=http%3A%2F%2Fhi.csdn.net%2Fattachment%2F201110%2F10%2F0_1318255239Hxxe.gif)\n\n   通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。\n   \n**----扩展阅读----**\n\n**1）什么是反向代理？**\n&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。\n![](http://www.2cto.com/uploadfile/Collfiles/20150518/201505180932502.jpg?_=6547807)\n\n\n## 7、服务器返回一个 HTTP 响应　\n　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。\nHTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：\n- 状态行\n- 响应头(Response Header)\n- 响应正文\n```html\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞http＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n**状态行：**\n   状态行由`协议版本`、数字形式的`状态代码`、及相应的`状态描述`，各元素之间以空格分隔。\n格式:   ` HTTP-Version Status-Code Reason-Phrase CRLF`\n例如:   ` HTTP/1.1 200 OK \\r\\n`\n| -协议版本：是用http1.0还是其他版本\n| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok\n| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下\n\n`1xx：`信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。\n *  100 Continue\n * 101 Switching Protocols\n \n`2xx：`成功状态码，表示服务器已成功接收到请求并进行处理。\n * 200 OK 表示客户端请求成功\n * 204 No Content 成功，但不返回任何实体的主体部分\n * 206 Partial Content 成功执行了一个范围（Range）请求\n\n`3xx：` 重定向状态码，表示服务器要求客户端重定向。\n * 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL\n * 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源\n * 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源\n * 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存\n * 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现\n    \n` 4xx：`客户端错误状态码，表示客户端的请求有非法内容。\n * 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解\n * 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用\n * 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因\n * 404 Not Found 请求的资源不存在，例如，输入了错误的URL\n\n`5xx`：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。\n * 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求\n * 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常\n\n**响应头：**\n　　响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号\":\"分隔，典型的响应头有：\n![](http://images2015.cnblogs.com/blog/776370/201703/776370-20170322193336611-2098719977.png)\n　　\n**响应正文**\n包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：\n![](http://images2015.cnblogs.com/blog/776370/201703/776370-20170319190828323-2078498869.png)\n\n\n## 8、浏览器显示 HTML\n\n　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：\n\n解析html以`构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树`\n![](https://segmentfault.com/img/bVCZ1H?w=694&h=340&_=6547807)\n\n　　浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。\n　　解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。\n　　DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。\n　　页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。\n![](https://segmentfault.com/img/bVC1uE?w=734&h=689&_=6547807)\n　　当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。\n　　JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。\n　　JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里\n　　\n\n## 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\n　　其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：\n图片：`http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif`\nCSS式样表：`http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css`\nJavaScript 文件：`http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js`\n\n这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等...\n不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中\n\n\n -------------------------------------------------分割线-----------------------------------------------------\n\n\n　　至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。\n　　如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。\n　　当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。\n\n \n参考文献：\nhttps://segmentfault.com/a/1190000006879700  \nhttp://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/\nhttp://zrj.me/archives/589  \n\n \n\n\n\n\n\n","source":"_posts/老生常谈-从输入url到页面展示到底发生了什么.md","raw":"---\ntitle: 老生常谈-从输入url到页面展示到底发生了什么\ndate: 2017-03-22 20:07\ncategories:\ntags:\n     - 博客园迁移\n---\n\n> &ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。\n &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。\n\n<!--more-->\n\n总的过程大概如下:\n\n## 1、输入地址\n\n &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。\n\n\n## 2、浏览器查找域名的 IP 地址　　\n&ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。\n&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。\n&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。\n&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。\n&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。\n&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。\n下面这张图很完美的解释了这一过程：\n\n![图片](http://www.maixj.net/wp-content/uploads/2015/10/dns.jpg?_=6547807)\n\n **----知识扩展---- **\n\n**1)什么是DNS？**\n　　DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。\n　　通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。\n\n**2)DNS查询的两种方式：递归查询和迭代查询**\n\n1、递归解析\n    当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。\n![图](http://s16.sinaimg.cn/mw690/4078ccd6hcdcf48aab7af&690?_=6547807)\n    \n2、迭代解析\n　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。\n![](http://s12.sinaimg.cn/mw690/4078ccd6h7afb21339ebb&690?_=6547807)\n\n**3)DNS域名称空间的组织方式**\n\n 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例\n![](http://img1.51cto.com/attachment/201203/171409287.jpg?_=6547807)\n\n**4)DNS负载均衡**\n　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n　　\n\n## 3、浏览器向 web 服务器发送一个 HTTP 请求\n　　拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。\n　　\nTCP连接如图所示:\n![](http://img.bitscn.com/upimg/allimg/c160831/14H61600J21Z-2N62.jpg?_=6547807)\n\n　　建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。\n　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：\n- 请求方法URI协议/版本\n- 请求头(Request Header)\n- 请求正文：\n\n下面是一个完整的HTTP请求例子：\n```bash\nGET/sample.jspHTTP/1.1\nAccept:image/gif.image/jpeg,*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)\nAccept-Encoding:gzip,deflate\n\nusername=jinqiao&password=1234\n```\n 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。\n\n（1）请求的第一行是“方法URL议/版本”：`GET/sample.jsp HTTP/1.1`\n（2）请求头(Request Header)\n　　 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。\n```bash\nAccept:image/gif.image/jpeg.*/*\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)\nAccept-Encoding:gzip,deflate.\n```\n（3）请求正文\n    请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：\n\n`username=jinqiao&password=1234`\n \n**---- 知识扩展----**\n\n**1）TCP三次握手**\n- 第一次握手：客户端A将标志位SYN置为1,随机产生一个值为`seq=J`（J的取值范围为=1234567）的数据包到服务器，客户端A进入`SYN_SENT`状态，等待服务端B确认；\n- 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个值`seq=K`，并将该数据包发送给客户端A以确认连接请求，服务端B进入`SYN_RCVD`状态。\n- 第三次握手：客户端A收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务端B，服务端B检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入`ESTABLISHED`状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。\n\n如图所示：\n![](http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png?_=6547807)\n\n**2）为什需要三次握手？**\n&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”\n&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。\n\n**3）TCP四次挥手**\n- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。\n- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n\n![](http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png?_=6547807)\n\n**4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**\n　　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n\n\n\n## 4、服务器的永久重定向响应\n 　　服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问`http://www.google.com/` 而非`http://google.com/`。\n　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像`http://www.yy.com/`和`http://yy.com/`，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。\n\n**----扩展知识----**\n\n**1）301和302的区别。**\n　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。\n　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；\n　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301\n\n**2）重定向原因：**\n（1）网站调整（如改变网页目录结构）；\n（2）网页被移到一个新地址；\n（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。\n        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。\n\n**3）什么时候进行301或者302跳转呢？**\n&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。\n清晰明确而言：使用301跳转的大概场景如下：\n- 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。\n- 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。\n- 空间服务器不稳定，换空间的时候。\n\n \n## 5、浏览器跟踪重定向地址\n\n   现在浏览器知道了 `\"http://www.google.com/\"`才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的\n\n\n## 6、服务器处理请求\n　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？\n　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。\n　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。\n\n如图所示：\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1489904964343&di=c6043cd72bb60f4e129589b6a8f79299&imgtype=0&src=http%3A%2F%2Fhi.csdn.net%2Fattachment%2F201110%2F10%2F0_1318255239Hxxe.gif)\n\n   通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。\n   \n**----扩展阅读----**\n\n**1）什么是反向代理？**\n&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。\n![](http://www.2cto.com/uploadfile/Collfiles/20150518/201505180932502.jpg?_=6547807)\n\n\n## 7、服务器返回一个 HTTP 响应　\n　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。\nHTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：\n- 状态行\n- 响应头(Response Header)\n- 响应正文\n```html\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞http＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n**状态行：**\n   状态行由`协议版本`、数字形式的`状态代码`、及相应的`状态描述`，各元素之间以空格分隔。\n格式:   ` HTTP-Version Status-Code Reason-Phrase CRLF`\n例如:   ` HTTP/1.1 200 OK \\r\\n`\n| -协议版本：是用http1.0还是其他版本\n| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok\n| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下\n\n`1xx：`信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。\n *  100 Continue\n * 101 Switching Protocols\n \n`2xx：`成功状态码，表示服务器已成功接收到请求并进行处理。\n * 200 OK 表示客户端请求成功\n * 204 No Content 成功，但不返回任何实体的主体部分\n * 206 Partial Content 成功执行了一个范围（Range）请求\n\n`3xx：` 重定向状态码，表示服务器要求客户端重定向。\n * 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL\n * 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源\n * 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源\n * 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存\n * 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现\n    \n` 4xx：`客户端错误状态码，表示客户端的请求有非法内容。\n * 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解\n * 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用\n * 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因\n * 404 Not Found 请求的资源不存在，例如，输入了错误的URL\n\n`5xx`：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。\n * 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求\n * 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常\n\n**响应头：**\n　　响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号\":\"分隔，典型的响应头有：\n![](http://images2015.cnblogs.com/blog/776370/201703/776370-20170322193336611-2098719977.png)\n　　\n**响应正文**\n包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：\n![](http://images2015.cnblogs.com/blog/776370/201703/776370-20170319190828323-2078498869.png)\n\n\n## 8、浏览器显示 HTML\n\n　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：\n\n解析html以`构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树`\n![](https://segmentfault.com/img/bVCZ1H?w=694&h=340&_=6547807)\n\n　　浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。\n　　解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。\n　　DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。\n　　页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。\n![](https://segmentfault.com/img/bVC1uE?w=734&h=689&_=6547807)\n　　当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。\n　　JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。\n　　JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里\n　　\n\n## 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\n　　其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：\n图片：`http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif`\nCSS式样表：`http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css`\nJavaScript 文件：`http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js`\n\n这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等...\n不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中\n\n\n -------------------------------------------------分割线-----------------------------------------------------\n\n\n　　至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。\n　　如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。\n　　当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。\n\n \n参考文献：\nhttps://segmentfault.com/a/1190000006879700  \nhttp://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/\nhttp://zrj.me/archives/589  \n\n \n\n\n\n\n\n","slug":"老生常谈-从输入url到页面展示到底发生了什么","published":1,"updated":"2017-04-09T15:49:54.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr7f000i9gscsogyfmmq","content":"<blockquote>\n<p>&ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。<br> &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>总的过程大概如下:</p>\n<h2 id=\"1、输入地址\"><a href=\"#1、输入地址\" class=\"headerlink\" title=\"1、输入地址\"></a>1、输入地址</h2><p> &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n<h2 id=\"2、浏览器查找域名的-IP-地址\"><a href=\"#2、浏览器查找域名的-IP-地址\" class=\"headerlink\" title=\"2、浏览器查找域名的 IP 地址　　\"></a>2、浏览器查找域名的 IP 地址　　</h2><p>&ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。<br>&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。<br>&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。<br>&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。<br>&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。<br>&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。<br>下面这张图很完美的解释了这一过程：</p>\n<p><img src=\"http://www.maixj.net/wp-content/uploads/2015/10/dns.jpg?_=6547807\" alt=\"图片\"></p>\n<p> <strong>—-知识扩展—- </strong></p>\n<p><strong>1)什么是DNS？</strong><br>　　DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>　　通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</p>\n<p><strong>2)DNS查询的两种方式：递归查询和迭代查询</strong></p>\n<p>1、递归解析<br>    当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img src=\"http://s16.sinaimg.cn/mw690/4078ccd6hcdcf48aab7af&amp;690?_=6547807\" alt=\"图\"></p>\n<p>2、迭代解析<br>　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<br><img src=\"http://s12.sinaimg.cn/mw690/4078ccd6h7afb21339ebb&amp;690?_=6547807\" alt=\"\"></p>\n<p><strong>3)DNS域名称空间的组织方式</strong></p>\n<p> 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例<br><img src=\"http://img1.51cto.com/attachment/201203/171409287.jpg?_=6547807\" alt=\"\"></p>\n<p><strong>4)DNS负载均衡</strong><br>　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n　　</p>\n<h2 id=\"3、浏览器向-web-服务器发送一个-HTTP-请求\"><a href=\"#3、浏览器向-web-服务器发送一个-HTTP-请求\" class=\"headerlink\" title=\"3、浏览器向 web 服务器发送一个 HTTP 请求\"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h2><p>　　拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。<br>　　<br>TCP连接如图所示:<br><img src=\"http://img.bitscn.com/upimg/allimg/c160831/14H61600J21Z-2N62.jpg?_=6547807\" alt=\"\"></p>\n<p>　　建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。<br>　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>\n<ul>\n<li>请求方法URI协议/版本</li>\n<li>请求头(Request Header)</li>\n<li>请求正文：</li>\n</ul>\n<p>下面是一个完整的HTTP请求例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET/sample.jspHTTP/1.1</div><div class=\"line\">Accept:image/gif.image/jpeg,*/*</div><div class=\"line\">Accept-Language:zh-cn</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Host:localhost</div><div class=\"line\">User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)</div><div class=\"line\">Accept-Encoding:gzip,deflate</div><div class=\"line\"></div><div class=\"line\">username=jinqiao&amp;password=1234</div></pre></td></tr></table></figure></p>\n<p> 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>\n<p>（1）请求的第一行是“方法URL议/版本”：<code>GET/sample.jsp HTTP/1.1</code><br>（2）请求头(Request Header)<br>　　 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Accept:image/gif.image/jpeg.*/*</div><div class=\"line\">Accept-Language:zh-cn</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Host:localhost</div><div class=\"line\">User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)</div><div class=\"line\">Accept-Encoding:gzip,deflate.</div></pre></td></tr></table></figure></p>\n<p>（3）请求正文<br>    请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p>\n<p><code>username=jinqiao&amp;password=1234</code></p>\n<p><strong>—- 知识扩展—-</strong></p>\n<p><strong>1）TCP三次握手</strong></p>\n<ul>\n<li>第一次握手：客户端A将标志位SYN置为1,随机产生一个值为<code>seq=J</code>（J的取值范围为=1234567）的数据包到服务器，客户端A进入<code>SYN_SENT</code>状态，等待服务端B确认；</li>\n<li>第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给客户端A以确认连接请求，服务端B进入<code>SYN_RCVD</code>状态。</li>\n<li>第三次握手：客户端A收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务端B，服务端B检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。</li>\n</ul>\n<p>如图所示：<br><img src=\"http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png?_=6547807\" alt=\"\"></p>\n<p><strong>2）为什需要三次握手？</strong><br>&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”<br>&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。<br>&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>\n<p><strong>3）TCP四次挥手</strong></p>\n<ul>\n<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>\n<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li>\n<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>\n<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>\n</ul>\n<p><img src=\"http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png?_=6547807\" alt=\"\"></p>\n<p><strong>4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong><br>　　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>\n<h2 id=\"4、服务器的永久重定向响应\"><a href=\"#4、服务器的永久重定向响应\" class=\"headerlink\" title=\"4、服务器的永久重定向响应\"></a>4、服务器的永久重定向响应</h2><p> 　　服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<code>http://www.google.com/</code> 而非<code>http://google.com/</code>。<br>　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<code>http://www.yy.com/</code>和<code>http://yy.com/</code>，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>\n<p><strong>—-扩展知识—-</strong></p>\n<p><strong>1）301和302的区别。</strong><br>　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。<br>　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；<br>　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p>\n<p><strong>2）重定向原因：</strong><br>（1）网站调整（如改变网页目录结构）；<br>（2）网页被移到一个新地址；<br>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>\n<p><strong>3）什么时候进行301或者302跳转呢？</strong><br>&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。<br>清晰明确而言：使用301跳转的大概场景如下：</p>\n<ul>\n<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>\n<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>\n<li>空间服务器不稳定，换空间的时候。</li>\n</ul>\n<h2 id=\"5、浏览器跟踪重定向地址\"><a href=\"#5、浏览器跟踪重定向地址\" class=\"headerlink\" title=\"5、浏览器跟踪重定向地址\"></a>5、浏览器跟踪重定向地址</h2><p>   现在浏览器知道了 <code>&quot;http://www.google.com/&quot;</code>才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</p>\n<h2 id=\"6、服务器处理请求\"><a href=\"#6、服务器处理请求\" class=\"headerlink\" title=\"6、服务器处理请求\"></a>6、服务器处理请求</h2><p>　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？<br>　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。<br>　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n<p>如图所示：<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1489904964343&amp;di=c6043cd72bb60f4e129589b6a8f79299&amp;imgtype=0&amp;src=http%3A%2F%2Fhi.csdn.net%2Fattachment%2F201110%2F10%2F0_1318255239Hxxe.gif\" alt=\"\"></p>\n<p>   通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。</p>\n<p><strong>—-扩展阅读—-</strong></p>\n<p><strong>1）什么是反向代理？</strong><br>&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img src=\"http://www.2cto.com/uploadfile/Collfiles/20150518/201505180932502.jpg?_=6547807\" alt=\"\"></p>\n<h2 id=\"7、服务器返回一个-HTTP-响应\"><a href=\"#7、服务器返回一个-HTTP-响应\" class=\"headerlink\" title=\"7、服务器返回一个 HTTP 响应　\"></a>7、服务器返回一个 HTTP 响应　</h2><p>　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。<br>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>\n<ul>\n<li>状态行</li>\n<li>响应头(Response Header)</li>\n<li>响应正文<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</div><div class=\"line\">Content-Type: text/html;charset=ISO-8859-1</div><div class=\"line\">Content-Length: 122</div><div class=\"line\"></div><div class=\"line\">＜html＞</div><div class=\"line\">＜head＞</div><div class=\"line\">＜title＞http＜/title＞</div><div class=\"line\">＜/head＞</div><div class=\"line\">＜body＞</div><div class=\"line\">＜!-- body goes here --＞</div><div class=\"line\">＜/body＞</div><div class=\"line\">＜/html＞</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>状态行：</strong><br>   状态行由<code>协议版本</code>、数字形式的<code>状态代码</code>、及相应的<code>状态描述</code>，各元素之间以空格分隔。<br>格式:   <code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br>例如:   <code>HTTP/1.1 200 OK \\r\\n</code><br>| -协议版本：是用http1.0还是其他版本<br>| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok<br>| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下</p>\n<p><code>1xx：</code>信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>\n<ul>\n<li>100 Continue</li>\n<li>101 Switching Protocols</li>\n</ul>\n<p><code>2xx：</code>成功状态码，表示服务器已成功接收到请求并进行处理。</p>\n<ul>\n<li>200 OK 表示客户端请求成功</li>\n<li>204 No Content 成功，但不返回任何实体的主体部分</li>\n<li>206 Partial Content 成功执行了一个范围（Range）请求</li>\n</ul>\n<p><code>3xx：</code> 重定向状态码，表示服务器要求客户端重定向。</p>\n<ul>\n<li>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</li>\n<li>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</li>\n<li>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</li>\n<li>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</li>\n<li>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</li>\n</ul>\n<p><code>4xx：</code>客户端错误状态码，表示客户端的请求有非法内容。</p>\n<ul>\n<li>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</li>\n<li>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</li>\n<li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li>\n</ul>\n<p><code>5xx</code>：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>\n<ul>\n<li>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</li>\n<li>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>\n</ul>\n<p><strong>响应头：</strong><br>　　响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201703/776370-20170322193336611-2098719977.png\" alt=\"\"><br>　　<br><strong>响应正文</strong><br>包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201703/776370-20170319190828323-2078498869.png\" alt=\"\"></p>\n<h2 id=\"8、浏览器显示-HTML\"><a href=\"#8、浏览器显示-HTML\" class=\"headerlink\" title=\"8、浏览器显示 HTML\"></a>8、浏览器显示 HTML</h2><p>　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：</p>\n<p>解析html以<code>构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</code><br><img src=\"https://segmentfault.com/img/bVCZ1H?w=694&amp;h=340&amp;_=6547807\" alt=\"\"></p>\n<p>　　浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。<br>　　解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。<br>　　DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。<br>　　页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br><img src=\"https://segmentfault.com/img/bVC1uE?w=734&amp;h=689&amp;_=6547807\" alt=\"\"><br>　　当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。<br>　　JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。<br>　　JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里\n　　</p>\n<h2 id=\"9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\"><a href=\"#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\" class=\"headerlink\" title=\"9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h2><p>　　其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：<br>图片：<code>http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</code><br>CSS式样表：<code>http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</code><br>JavaScript 文件：<code>http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</code></p>\n<p>这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…<br>不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中</p>\n<p> ————————————————-分割线—————————————————–</p>\n<p>　　至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。<br>　　如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。<br>　　当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。</p>\n<p>参考文献：<br><a href=\"https://segmentfault.com/a/1190000006879700\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000006879700</a><br><a href=\"http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/\" target=\"_blank\" rel=\"external\">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a><br><a href=\"http://zrj.me/archives/589\" target=\"_blank\" rel=\"external\">http://zrj.me/archives/589</a>  </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>&ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。<br> &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。</p>\n</blockquote>","more":"<p>总的过程大概如下:</p>\n<h2 id=\"1、输入地址\"><a href=\"#1、输入地址\" class=\"headerlink\" title=\"1、输入地址\"></a>1、输入地址</h2><p> &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。</p>\n<h2 id=\"2、浏览器查找域名的-IP-地址\"><a href=\"#2、浏览器查找域名的-IP-地址\" class=\"headerlink\" title=\"2、浏览器查找域名的 IP 地址　　\"></a>2、浏览器查找域名的 IP 地址　　</h2><p>&ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。<br>&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。<br>&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。<br>&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。<br>&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。<br>&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。<br>下面这张图很完美的解释了这一过程：</p>\n<p><img src=\"http://www.maixj.net/wp-content/uploads/2015/10/dns.jpg?_=6547807\" alt=\"图片\"></p>\n<p> <strong>—-知识扩展—- </strong></p>\n<p><strong>1)什么是DNS？</strong><br>　　DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。<br>　　通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。</p>\n<p><strong>2)DNS查询的两种方式：递归查询和迭代查询</strong></p>\n<p>1、递归解析<br>    当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br><img src=\"http://s16.sinaimg.cn/mw690/4078ccd6hcdcf48aab7af&amp;690?_=6547807\" alt=\"图\"></p>\n<p>2、迭代解析<br>　　当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<br><img src=\"http://s12.sinaimg.cn/mw690/4078ccd6h7afb21339ebb&amp;690?_=6547807\" alt=\"\"></p>\n<p><strong>3)DNS域名称空间的组织方式</strong></p>\n<p> 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例<br><img src=\"http://img1.51cto.com/attachment/201203/171409287.jpg?_=6547807\" alt=\"\"></p>\n<p><strong>4)DNS负载均衡</strong><br>　　当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。\n　　</p>\n<h2 id=\"3、浏览器向-web-服务器发送一个-HTTP-请求\"><a href=\"#3、浏览器向-web-服务器发送一个-HTTP-请求\" class=\"headerlink\" title=\"3、浏览器向 web 服务器发送一个 HTTP 请求\"></a>3、浏览器向 web 服务器发送一个 HTTP 请求</h2><p>　　拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。<br>　　<br>TCP连接如图所示:<br><img src=\"http://img.bitscn.com/upimg/allimg/c160831/14H61600J21Z-2N62.jpg?_=6547807\" alt=\"\"></p>\n<p>　　建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。<br>　　客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p>\n<ul>\n<li>请求方法URI协议/版本</li>\n<li>请求头(Request Header)</li>\n<li>请求正文：</li>\n</ul>\n<p>下面是一个完整的HTTP请求例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">GET/sample.jspHTTP/1.1</div><div class=\"line\">Accept:image/gif.image/jpeg,*/*</div><div class=\"line\">Accept-Language:zh-cn</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Host:localhost</div><div class=\"line\">User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)</div><div class=\"line\">Accept-Encoding:gzip,deflate</div><div class=\"line\"></div><div class=\"line\">username=jinqiao&amp;password=1234</div></pre></td></tr></table></figure></p>\n<p> 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>\n<p>（1）请求的第一行是“方法URL议/版本”：<code>GET/sample.jsp HTTP/1.1</code><br>（2）请求头(Request Header)<br>　　 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Accept:image/gif.image/jpeg.*/*</div><div class=\"line\">Accept-Language:zh-cn</div><div class=\"line\">Connection:Keep-Alive</div><div class=\"line\">Host:localhost</div><div class=\"line\">User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)</div><div class=\"line\">Accept-Encoding:gzip,deflate.</div></pre></td></tr></table></figure></p>\n<p>（3）请求正文<br>    请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p>\n<p><code>username=jinqiao&amp;password=1234</code></p>\n<p><strong>—- 知识扩展—-</strong></p>\n<p><strong>1）TCP三次握手</strong></p>\n<ul>\n<li>第一次握手：客户端A将标志位SYN置为1,随机产生一个值为<code>seq=J</code>（J的取值范围为=1234567）的数据包到服务器，客户端A进入<code>SYN_SENT</code>状态，等待服务端B确认；</li>\n<li>第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给客户端A以确认连接请求，服务端B进入<code>SYN_RCVD</code>状态。</li>\n<li>第三次握手：客户端A收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务端B，服务端B检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。</li>\n</ul>\n<p>如图所示：<br><img src=\"http://www.2cto.com/uploadfile/2013/1022/20131022025346218.png?_=6547807\" alt=\"\"></p>\n<p><strong>2）为什需要三次握手？</strong><br>&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”<br>&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。<br>&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。</p>\n<p><strong>3）TCP四次挥手</strong></p>\n<ul>\n<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>\n<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</li>\n<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>\n<li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>\n</ul>\n<p><img src=\"http://www.2cto.com/uploadfile/2013/1022/20131022025350523.png?_=6547807\" alt=\"\"></p>\n<p><strong>4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong><br>　　这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>\n<h2 id=\"4、服务器的永久重定向响应\"><a href=\"#4、服务器的永久重定向响应\" class=\"headerlink\" title=\"4、服务器的永久重定向响应\"></a>4、服务器的永久重定向响应</h2><p> 　　服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问<code>http://www.google.com/</code> 而非<code>http://google.com/</code>。<br>　　为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像<code>http://www.yy.com/</code>和<code>http://yy.com/</code>，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>\n<p><strong>—-扩展知识—-</strong></p>\n<p><strong>1）301和302的区别。</strong><br>　　301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。<br>　　他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；<br>　　302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301</p>\n<p><strong>2）重定向原因：</strong><br>（1）网站调整（如改变网页目录结构）；<br>（2）网页被移到一个新地址；<br>（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。<br>        这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>\n<p><strong>3）什么时候进行301或者302跳转呢？</strong><br>&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。<br>清晰明确而言：使用301跳转的大概场景如下：</p>\n<ul>\n<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名。</li>\n<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>\n<li>空间服务器不稳定，换空间的时候。</li>\n</ul>\n<h2 id=\"5、浏览器跟踪重定向地址\"><a href=\"#5、浏览器跟踪重定向地址\" class=\"headerlink\" title=\"5、浏览器跟踪重定向地址\"></a>5、浏览器跟踪重定向地址</h2><p>   现在浏览器知道了 <code>&quot;http://www.google.com/&quot;</code>才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的</p>\n<h2 id=\"6、服务器处理请求\"><a href=\"#6、服务器处理请求\" class=\"headerlink\" title=\"6、服务器处理请求\"></a>6、服务器处理请求</h2><p>　　经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？<br>　　后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。<br>　　一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>\n<p>如图所示：<br><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1489904964343&amp;di=c6043cd72bb60f4e129589b6a8f79299&amp;imgtype=0&amp;src=http%3A%2F%2Fhi.csdn.net%2Fattachment%2F201110%2F10%2F0_1318255239Hxxe.gif\" alt=\"\"></p>\n<p>   通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。</p>\n<p><strong>—-扩展阅读—-</strong></p>\n<p><strong>1）什么是反向代理？</strong><br>&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。<br><img src=\"http://www.2cto.com/uploadfile/Collfiles/20150518/201505180932502.jpg?_=6547807\" alt=\"\"></p>\n<h2 id=\"7、服务器返回一个-HTTP-响应\"><a href=\"#7、服务器返回一个-HTTP-响应\" class=\"headerlink\" title=\"7、服务器返回一个 HTTP 响应　\"></a>7、服务器返回一个 HTTP 响应　</h2><p>　　经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。<br>HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p>\n<ul>\n<li>状态行</li>\n<li>响应头(Response Header)</li>\n<li>响应正文<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">HTTP/1.1 200 OK</div><div class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</div><div class=\"line\">Content-Type: text/html;charset=ISO-8859-1</div><div class=\"line\">Content-Length: 122</div><div class=\"line\"></div><div class=\"line\">＜html＞</div><div class=\"line\">＜head＞</div><div class=\"line\">＜title＞http＜/title＞</div><div class=\"line\">＜/head＞</div><div class=\"line\">＜body＞</div><div class=\"line\">＜!-- body goes here --＞</div><div class=\"line\">＜/body＞</div><div class=\"line\">＜/html＞</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>状态行：</strong><br>   状态行由<code>协议版本</code>、数字形式的<code>状态代码</code>、及相应的<code>状态描述</code>，各元素之间以空格分隔。<br>格式:   <code>HTTP-Version Status-Code Reason-Phrase CRLF</code><br>例如:   <code>HTTP/1.1 200 OK \\r\\n</code><br>| -协议版本：是用http1.0还是其他版本<br>| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok<br>| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下</p>\n<p><code>1xx：</code>信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。</p>\n<ul>\n<li>100 Continue</li>\n<li>101 Switching Protocols</li>\n</ul>\n<p><code>2xx：</code>成功状态码，表示服务器已成功接收到请求并进行处理。</p>\n<ul>\n<li>200 OK 表示客户端请求成功</li>\n<li>204 No Content 成功，但不返回任何实体的主体部分</li>\n<li>206 Partial Content 成功执行了一个范围（Range）请求</li>\n</ul>\n<p><code>3xx：</code> 重定向状态码，表示服务器要求客户端重定向。</p>\n<ul>\n<li>301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL</li>\n<li>302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源</li>\n<li>303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源</li>\n<li>304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存</li>\n<li>307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现</li>\n</ul>\n<p><code>4xx：</code>客户端错误状态码，表示客户端的请求有非法内容。</p>\n<ul>\n<li>400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解</li>\n<li>401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用</li>\n<li>403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因</li>\n<li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li>\n</ul>\n<p><code>5xx</code>：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。</p>\n<ul>\n<li>500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求</li>\n<li>503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>\n</ul>\n<p><strong>响应头：</strong><br>　　响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201703/776370-20170322193336611-2098719977.png\" alt=\"\"><br>　　<br><strong>响应正文</strong><br>包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文：<br><img src=\"http://images2015.cnblogs.com/blog/776370/201703/776370-20170319190828323-2078498869.png\" alt=\"\"></p>\n<h2 id=\"8、浏览器显示-HTML\"><a href=\"#8、浏览器显示-HTML\" class=\"headerlink\" title=\"8、浏览器显示 HTML\"></a>8、浏览器显示 HTML</h2><p>　　在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括：</p>\n<p>解析html以<code>构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</code><br><img src=\"https://segmentfault.com/img/bVCZ1H?w=694&amp;h=340&amp;_=6547807\" alt=\"\"></p>\n<p>　　浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。<br>　　解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。<br>　　DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。<br>　　页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。<br><img src=\"https://segmentfault.com/img/bVC1uE?w=734&amp;h=689&amp;_=6547807\" alt=\"\"><br>　　当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。<br>　　JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。<br>　　JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里\n　　</p>\n<h2 id=\"9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\"><a href=\"#9、浏览器发送请求获取嵌入在-HTML-中的资源（如图片、音频、视频、CSS、JS等等）\" class=\"headerlink\" title=\"9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）\"></a>9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</h2><p>　　其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：<br>图片：<code>http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif</code><br>CSS式样表：<code>http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css</code><br>JavaScript 文件：<code>http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js</code></p>\n<p>这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…<br>不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中</p>\n<p> ————————————————-分割线—————————————————–</p>\n<p>　　至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。<br>　　如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。<br>　　当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。</p>\n<p>参考文献：<br><a href=\"https://segmentfault.com/a/1190000006879700\">https://segmentfault.com/a/1190000006879700</a><br><a href=\"http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/\">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a><br><a href=\"http://zrj.me/archives/589\">http://zrj.me/archives/589</a>  </p>"},{"title":"使用vue2+vue-router+vuex写一个cnode的脚手架","date":"2017-03-29T12:46:00.000Z","_content":"\n&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。\n\n<!--more-->\n**本项目github地址** [点击这里](https://github.com/xianyulaodi/vue-cnode-template)\n\n&ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。\n\n&ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑)\n\n![首页](//images2015.cnblogs.com/blog/776370/201703/776370-20170330192330508-241902663.png)首页&ensp;&ensp;\n![详情页](//images2015.cnblogs.com/blog/776370/201703/776370-20170330192446461-1898007541.png)详情页\n## 项目简介\n基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含：\n\n- 基础库：`vue.js`、 `vue-router2.0版本`、`vuex`、`axios`\n- 编译/打包工具：`webpack`、`babel`、`node-sass`\n- 单元测试工具：`karma`、`mocha`、`sinon-chai`\n- 本地服务器：`express`\n\n## 运行方式\n* 开发环境\n1. `npm install` \n2. 点击start.sh、或者直接cmd里面输入  `npm run dev`\n*  配置构建项目，构建好的文件会输出到 \"dist\" 目录，\n    `npm run build`\n* 服务器，可以查看构建的页面\n    `npm run build-server`\n* 单元测试\n    `npm run unit`\n\n## 项目说明\n&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者\n\n## vue组件的生命周期\n&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下：\n![组件生命周期](//images.cnblogs.com/cnblogs_com/fly_dragon/276813/o_lifecycle-%E6%A0%87%E6%B3%A8%E7%89%88%E6%9C%AC.png)\n\n## 如何写一个组件\n&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例\n>我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue\n\n```html\n<template>\n\t <div class=\"item-list-wrap\">\n        <ul class=\"item-list\">\n           <li v-for=\"item in itemList\">\n           \t    <router-link :to=\"{name:'detail',params:{id:item.id}}\" >{{ item.title }}</router-link>\n           </li>\n        </ul>\n    </div>\n</template>\n\n<script>\nexport default {\n  props: ['itemList'],\n  mounted: function () {\n\n  }\n}\n</script>\n\n<style lang=\"scss\" rel=\"stylesheet/scss\">\n\n.item-list-wrap{\n  background: #fff;\n  .item-list li{\n    height: 45px;\n    line-height: 45px;\n    text-align: left;\n    padding:0 10px;\n    font-size: 14px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space:nowrap;\n    border-bottom: 1px solid #ccc;\n  }\n}\n</style>\n\n```\n\n&ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.\n那么父组件如何调用这些组件呢，使用方法如下：\nviews/index.vue\n```html\n<template>\n  <div>\n    <c-header :hTitle=\"title\"></c-header>\n     <index-item :item-list='topicsListData'></index-item>\n  </div>\n</template>\n\n<script>\n  import cHeader from 'components/header';\n  import indexItem from 'components/indexItem';\n\n  export default {\n    data () {\n      return {\n        title: 'node中文网',\n        tabId:0\n      }\n    },\n    computed: mapGetters({\n\n      topicsListData :'getTopicsListData'\n\n    }),\n    methods: {\n     components: {cHeader,indexItem}\n  }\n</script>\n\n```\n&ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。\n   \n&ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过\n ```html\n <index-item :item-list=传入的数据></index-item>\n ```\n&ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码\n ```javascript\n components: {cHeader,indexItem}\n ```\n ## vur-router\n1. 我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。\n2. 传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取\n ```\n this.$route.params.id\n ```\n关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大\n \n## vuex2.0\n&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。\n   ![vuex示意图](https://vuex.vuejs.org/zh-cn/images/vuex.png)\n   \n#### 这里稍作解释：(个人理解，有误之处，欢迎指出)\n - vuex也是跟redux一样，有且只能由一个store\n - 在vuex中，状态的改变只能是通过mutations\n - 用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations\n - mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations\n - 触发action用dispatch、触发mutations用commit\n \n### 这里介绍一下vuex异步的操作\n&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。\n&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？   \n```javascript\nimport Vue from 'vue';\nimport axios from 'axios';\nimport * as types from '../../constants/constants';\nconst state = {\n    topicsList:[]\n};\nconst getters = {\n    getTopicsListData: state => state.topicsList\n};\nconst actions = {\n\t/**\n     * @name  获取主页数据\n     * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去\n     * \n     * # 注意点：\n     * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定\n     */\n    [types.GET_TOPICS]({commit},obj) {\n        axios.get(`https://cnodejs.org/api/v1/topics?page=${obj.pageNo}&limit=20&tab=${obj.tab}`)\n        .then((response) => {\n          commit(types.SET_TOPICS, { list: response.data.data })\n        }, (err) => {\n          console.log(err)\n        })\n    }  \n}\nconst mutations = {\n    // 获取首页的数据\n    [types.SET_TOPICS](state,{list}) {\n        state.topicsList=list;  //再次记住，mutations是唯一允许更新应用状态的地方\n    }\n};\nexport default{\n    state,\n    getters,\n    actions,\n    mutations\n}\n```\n&ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下：\n1. 我们定义了一个默认的状态topicsList，并赋值为一个空数组\n2. 我们定义了一个action来获取后端数据， `[types.GET_TOPICS]({commit},obj) {}`,其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成`getTopics({commit},obj) {}`这种形式的。\n   action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。\n3. 我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态\n4. 在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。\n\n### 页面是如何使用传回来的数据的？\n 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分\n \n ```html\n <template>\n  <div>\n    <index-item :item-list='topicsListData'></index-item>\n  </div>\n</template>\n\n<script>\n  import Vue from 'vue';\n  import {mapState} from 'vuex';\n  import {mapGetters} from 'vuex';\n  import indexItem from 'components/indexItem';\n  import * as types from '../constants/constants';\n  \n  export default {\n    data () {\n      return {\n        title: 'node中文网'\n      }\n    },\n    // computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新\n    computed: mapGetters({\n\n      topicsListData :'getTopicsListData'\n\n    }),\n    methods: {\n\n      /*\n      * @获取内容\n      */\n      getTopics (page,tab,index) {\n          // 触发action\n          this.$store.dispatch({\n              type:types.GET_TOPICS,\n              pageNo:page,\n              tab:tab\n          });\n          this.tabId=index;\n      },\n    },\n    /*\n    * @初始化(组件挂载完成)，相当于react中的componentWillamount\n    */\n    mounted () {\n\n      this.getTopics(1,'all'); \n      \n    },\n    components: {indexItem}\n  }\n</script>\n ```\n&ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 `getTopics`，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。  \n&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：  \n&ensp;&ensp;  \n``` javascript\ncomputed: mapGetters({\n    topicsListData :'getTopicsListData'\n}),\n ```\n    \n    \n&ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式：  \n \n `topicsListData :'getTopicsListData`  \n \n &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。\n \n&ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示  \n  \n  \n`<index-item :item-list='topicsListData'></index-item>`;  \n\n\n在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 \n## 后记\n - 对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。\n- 后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。\n- 当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出\n\n\n\n\n","source":"_posts/使用vue2+vue-router+vuex写一个cnode的脚手架.md","raw":"---\ntitle: 使用vue2+vue-router+vuex写一个cnode的脚手架\ndate: 2017-03-29 20:46\ncategories: \n\t- vue\ntags:\n    - vue\n    - vuex\n    - vue-router\n---\n\n&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。\n\n<!--more-->\n**本项目github地址** [点击这里](https://github.com/xianyulaodi/vue-cnode-template)\n\n&ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。\n\n&ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑)\n\n![首页](//images2015.cnblogs.com/blog/776370/201703/776370-20170330192330508-241902663.png)首页&ensp;&ensp;\n![详情页](//images2015.cnblogs.com/blog/776370/201703/776370-20170330192446461-1898007541.png)详情页\n## 项目简介\n基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含：\n\n- 基础库：`vue.js`、 `vue-router2.0版本`、`vuex`、`axios`\n- 编译/打包工具：`webpack`、`babel`、`node-sass`\n- 单元测试工具：`karma`、`mocha`、`sinon-chai`\n- 本地服务器：`express`\n\n## 运行方式\n* 开发环境\n1. `npm install` \n2. 点击start.sh、或者直接cmd里面输入  `npm run dev`\n*  配置构建项目，构建好的文件会输出到 \"dist\" 目录，\n    `npm run build`\n* 服务器，可以查看构建的页面\n    `npm run build-server`\n* 单元测试\n    `npm run unit`\n\n## 项目说明\n&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者\n\n## vue组件的生命周期\n&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下：\n![组件生命周期](//images.cnblogs.com/cnblogs_com/fly_dragon/276813/o_lifecycle-%E6%A0%87%E6%B3%A8%E7%89%88%E6%9C%AC.png)\n\n## 如何写一个组件\n&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例\n>我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue\n\n```html\n<template>\n\t <div class=\"item-list-wrap\">\n        <ul class=\"item-list\">\n           <li v-for=\"item in itemList\">\n           \t    <router-link :to=\"{name:'detail',params:{id:item.id}}\" >{{ item.title }}</router-link>\n           </li>\n        </ul>\n    </div>\n</template>\n\n<script>\nexport default {\n  props: ['itemList'],\n  mounted: function () {\n\n  }\n}\n</script>\n\n<style lang=\"scss\" rel=\"stylesheet/scss\">\n\n.item-list-wrap{\n  background: #fff;\n  .item-list li{\n    height: 45px;\n    line-height: 45px;\n    text-align: left;\n    padding:0 10px;\n    font-size: 14px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space:nowrap;\n    border-bottom: 1px solid #ccc;\n  }\n}\n</style>\n\n```\n\n&ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.\n那么父组件如何调用这些组件呢，使用方法如下：\nviews/index.vue\n```html\n<template>\n  <div>\n    <c-header :hTitle=\"title\"></c-header>\n     <index-item :item-list='topicsListData'></index-item>\n  </div>\n</template>\n\n<script>\n  import cHeader from 'components/header';\n  import indexItem from 'components/indexItem';\n\n  export default {\n    data () {\n      return {\n        title: 'node中文网',\n        tabId:0\n      }\n    },\n    computed: mapGetters({\n\n      topicsListData :'getTopicsListData'\n\n    }),\n    methods: {\n     components: {cHeader,indexItem}\n  }\n</script>\n\n```\n&ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。\n   \n&ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过\n ```html\n <index-item :item-list=传入的数据></index-item>\n ```\n&ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码\n ```javascript\n components: {cHeader,indexItem}\n ```\n ## vur-router\n1. 我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。\n2. 传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取\n ```\n this.$route.params.id\n ```\n关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大\n \n## vuex2.0\n&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。\n   ![vuex示意图](https://vuex.vuejs.org/zh-cn/images/vuex.png)\n   \n#### 这里稍作解释：(个人理解，有误之处，欢迎指出)\n - vuex也是跟redux一样，有且只能由一个store\n - 在vuex中，状态的改变只能是通过mutations\n - 用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations\n - mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations\n - 触发action用dispatch、触发mutations用commit\n \n### 这里介绍一下vuex异步的操作\n&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。\n&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？   \n```javascript\nimport Vue from 'vue';\nimport axios from 'axios';\nimport * as types from '../../constants/constants';\nconst state = {\n    topicsList:[]\n};\nconst getters = {\n    getTopicsListData: state => state.topicsList\n};\nconst actions = {\n\t/**\n     * @name  获取主页数据\n     * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去\n     * \n     * # 注意点：\n     * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定\n     */\n    [types.GET_TOPICS]({commit},obj) {\n        axios.get(`https://cnodejs.org/api/v1/topics?page=${obj.pageNo}&limit=20&tab=${obj.tab}`)\n        .then((response) => {\n          commit(types.SET_TOPICS, { list: response.data.data })\n        }, (err) => {\n          console.log(err)\n        })\n    }  \n}\nconst mutations = {\n    // 获取首页的数据\n    [types.SET_TOPICS](state,{list}) {\n        state.topicsList=list;  //再次记住，mutations是唯一允许更新应用状态的地方\n    }\n};\nexport default{\n    state,\n    getters,\n    actions,\n    mutations\n}\n```\n&ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下：\n1. 我们定义了一个默认的状态topicsList，并赋值为一个空数组\n2. 我们定义了一个action来获取后端数据， `[types.GET_TOPICS]({commit},obj) {}`,其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成`getTopics({commit},obj) {}`这种形式的。\n   action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。\n3. 我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态\n4. 在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。\n\n### 页面是如何使用传回来的数据的？\n 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分\n \n ```html\n <template>\n  <div>\n    <index-item :item-list='topicsListData'></index-item>\n  </div>\n</template>\n\n<script>\n  import Vue from 'vue';\n  import {mapState} from 'vuex';\n  import {mapGetters} from 'vuex';\n  import indexItem from 'components/indexItem';\n  import * as types from '../constants/constants';\n  \n  export default {\n    data () {\n      return {\n        title: 'node中文网'\n      }\n    },\n    // computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新\n    computed: mapGetters({\n\n      topicsListData :'getTopicsListData'\n\n    }),\n    methods: {\n\n      /*\n      * @获取内容\n      */\n      getTopics (page,tab,index) {\n          // 触发action\n          this.$store.dispatch({\n              type:types.GET_TOPICS,\n              pageNo:page,\n              tab:tab\n          });\n          this.tabId=index;\n      },\n    },\n    /*\n    * @初始化(组件挂载完成)，相当于react中的componentWillamount\n    */\n    mounted () {\n\n      this.getTopics(1,'all'); \n      \n    },\n    components: {indexItem}\n  }\n</script>\n ```\n&ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 `getTopics`，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。  \n&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：  \n&ensp;&ensp;  \n``` javascript\ncomputed: mapGetters({\n    topicsListData :'getTopicsListData'\n}),\n ```\n    \n    \n&ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式：  \n \n `topicsListData :'getTopicsListData`  \n \n &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。\n \n&ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示  \n  \n  \n`<index-item :item-list='topicsListData'></index-item>`;  \n\n\n在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 \n## 后记\n - 对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。\n- 后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。\n- 当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出\n\n\n\n\n","slug":"使用vue2+vue-router+vuex写一个cnode的脚手架","published":1,"updated":"2017-04-09T15:49:54.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr7n000j9gsc39fcyvpk","content":"<p>&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。</p>\n<a id=\"more\"></a>\n<p><strong>本项目github地址</strong> <a href=\"https://github.com/xianyulaodi/vue-cnode-template\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<p>&ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。</p>\n<p>&ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑)</p>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201703/776370-20170330192330508-241902663.png\" alt=\"首页\">首页&ensp;&ensp;<br><img src=\"//images2015.cnblogs.com/blog/776370/201703/776370-20170330192446461-1898007541.png\" alt=\"详情页\">详情页</p>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含：</p>\n<ul>\n<li>基础库：<code>vue.js</code>、 <code>vue-router2.0版本</code>、<code>vuex</code>、<code>axios</code></li>\n<li>编译/打包工具：<code>webpack</code>、<code>babel</code>、<code>node-sass</code></li>\n<li>单元测试工具：<code>karma</code>、<code>mocha</code>、<code>sinon-chai</code></li>\n<li>本地服务器：<code>express</code></li>\n</ul>\n<h2 id=\"运行方式\"><a href=\"#运行方式\" class=\"headerlink\" title=\"运行方式\"></a>运行方式</h2><ul>\n<li>开发环境</li>\n</ul>\n<ol>\n<li><code>npm install</code> </li>\n<li>点击start.sh、或者直接cmd里面输入  <code>npm run dev</code></li>\n</ol>\n<ul>\n<li>配置构建项目，构建好的文件会输出到 “dist” 目录，<br> <code>npm run build</code></li>\n<li>服务器，可以查看构建的页面<br>  <code>npm run build-server</code></li>\n<li>单元测试<br>  <code>npm run unit</code></li>\n</ul>\n<h2 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h2><p>&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者</p>\n<h2 id=\"vue组件的生命周期\"><a href=\"#vue组件的生命周期\" class=\"headerlink\" title=\"vue组件的生命周期\"></a>vue组件的生命周期</h2><p>&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下：<br><img src=\"//images.cnblogs.com/cnblogs_com/fly_dragon/276813/o_lifecycle-%E6%A0%87%E6%B3%A8%E7%89%88%E6%9C%AC.png\" alt=\"组件生命周期\"></p>\n<h2 id=\"如何写一个组件\"><a href=\"#如何写一个组件\" class=\"headerlink\" title=\"如何写一个组件\"></a>如何写一个组件</h2><p>&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例</p>\n<blockquote>\n<p>我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-list-wrap\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-list\"</span>&gt;</span></div><div class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in itemList\"</span>&gt;</span></div><div class=\"line\">           \t    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:'detail',params:&#123;id:item.id&#125;&#125;\"</span> &gt;</span>&#123;&#123; item.title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'itemList'</span>],</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"scss\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet/scss\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"></div><div class=\"line\">.item-list-wrap&#123;</div><div class=\"line\">  background: #fff;</div><div class=\"line\">  .item-list li&#123;</div><div class=\"line\">    height: 45px;</div><div class=\"line\">    line-height: 45px;</div><div class=\"line\">    text-align: left;</div><div class=\"line\">    padding:0 10px;</div><div class=\"line\">    font-size: 14px;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    text-overflow: ellipsis;</div><div class=\"line\">    white-space:nowrap;</div><div class=\"line\">    border-bottom: 1px solid #ccc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>&ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.<br>那么父组件如何调用这些组件呢，使用方法如下：<br>views/index.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">c-header</span> <span class=\"attr\">:hTitle</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">c-header</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">'topicsListData'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">import</span> cHeader <span class=\"keyword\">from</span> <span class=\"string\">'components/header'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> indexItem <span class=\"keyword\">from</span> <span class=\"string\">'components/indexItem'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'node中文网'</span>,</div><div class=\"line\">        <span class=\"attr\">tabId</span>:<span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">computed</span>: mapGetters(&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\"></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">     <span class=\"attr\">components</span>: &#123;cHeader,indexItem&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。</p>\n<p>&ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过<br> <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">传入的数据</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">components: &#123;cHeader,indexItem&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"vur-router\"><a href=\"#vur-router\" class=\"headerlink\" title=\"vur-router\"></a>vur-router</h2><ol>\n<li>我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。</li>\n<li>传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.$route.params.id</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大</p>\n<h2 id=\"vuex2-0\"><a href=\"#vuex2-0\" class=\"headerlink\" title=\"vuex2.0\"></a>vuex2.0</h2><p>&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。<br>   <img src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"vuex示意图\"></p>\n<h4 id=\"这里稍作解释：-个人理解，有误之处，欢迎指出\"><a href=\"#这里稍作解释：-个人理解，有误之处，欢迎指出\" class=\"headerlink\" title=\"这里稍作解释：(个人理解，有误之处，欢迎指出)\"></a>这里稍作解释：(个人理解，有误之处，欢迎指出)</h4><ul>\n<li>vuex也是跟redux一样，有且只能由一个store</li>\n<li>在vuex中，状态的改变只能是通过mutations</li>\n<li>用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations</li>\n<li>mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations</li>\n<li>触发action用dispatch、触发mutations用commit</li>\n</ul>\n<h3 id=\"这里介绍一下vuex异步的操作\"><a href=\"#这里介绍一下vuex异步的操作\" class=\"headerlink\" title=\"这里介绍一下vuex异步的操作\"></a>这里介绍一下vuex异步的操作</h3><p>&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。<br>&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../../constants/constants'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">    <span class=\"attr\">topicsList</span>:[]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</div><div class=\"line\">    <span class=\"attr\">getTopicsListData</span>: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.topicsList</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</div><div class=\"line\">\t<span class=\"comment\">/**</span></div><div class=\"line\">     * @name  获取主页数据</div><div class=\"line\">     * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去</div><div class=\"line\">     * </div><div class=\"line\">     * # 注意点：</div><div class=\"line\">     * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定</div><div class=\"line\">     */</div><div class=\"line\">    [types.GET_TOPICS](&#123;commit&#125;,obj) &#123;</div><div class=\"line\">        axios.get(<span class=\"string\">`https://cnodejs.org/api/v1/topics?page=<span class=\"subst\">$&#123;obj.pageNo&#125;</span>&amp;limit=20&amp;tab=<span class=\"subst\">$&#123;obj.tab&#125;</span>`</span>)</div><div class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</div><div class=\"line\">          commit(types.SET_TOPICS, &#123; <span class=\"attr\">list</span>: response.data.data &#125;)</div><div class=\"line\">        &#125;, (err) =&gt; &#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(err)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">    <span class=\"comment\">// 获取首页的数据</span></div><div class=\"line\">    [types.SET_TOPICS](state,&#123;list&#125;) &#123;</div><div class=\"line\">        state.topicsList=list;  <span class=\"comment\">//再次记住，mutations是唯一允许更新应用状态的地方</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span>&#123;</div><div class=\"line\">    state,</div><div class=\"line\">    getters,</div><div class=\"line\">    actions,</div><div class=\"line\">    mutations</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下：</p>\n<ol>\n<li>我们定义了一个默认的状态topicsList，并赋值为一个空数组</li>\n<li>我们定义了一个action来获取后端数据， <code>[types.GET_TOPICS]({commit},obj) {}</code>,其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成<code>getTopics({commit},obj) {}</code>这种形式的。<br>action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。</li>\n<li>我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态</li>\n<li>在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。</li>\n</ol>\n<h3 id=\"页面是如何使用传回来的数据的？\"><a href=\"#页面是如何使用传回来的数据的？\" class=\"headerlink\" title=\"页面是如何使用传回来的数据的？\"></a>页面是如何使用传回来的数据的？</h3><p> 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">'topicsListData'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  <span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;mapGetters&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> indexItem <span class=\"keyword\">from</span> <span class=\"string\">'components/indexItem'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/constants'</span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'node中文网'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新</span></div><div class=\"line\">    computed: mapGetters(&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\"></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/*</span></div><div class=\"line\">      * @获取内容</div><div class=\"line\">      */</div><div class=\"line\">      getTopics (page,tab,index) &#123;</div><div class=\"line\">          <span class=\"comment\">// 触发action</span></div><div class=\"line\">          <span class=\"keyword\">this</span>.$store.dispatch(&#123;</div><div class=\"line\">              <span class=\"attr\">type</span>:types.GET_TOPICS,</div><div class=\"line\">              <span class=\"attr\">pageNo</span>:page,</div><div class=\"line\">              <span class=\"attr\">tab</span>:tab</div><div class=\"line\">          &#125;);</div><div class=\"line\">          <span class=\"keyword\">this</span>.tabId=index;</div><div class=\"line\">      &#125;,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\">    * @初始化(组件挂载完成)，相当于react中的componentWillamount</div><div class=\"line\">    */</div><div class=\"line\">    mounted () &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>.getTopics(<span class=\"number\">1</span>,<span class=\"string\">'all'</span>); </div><div class=\"line\">      </div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">components</span>: &#123;indexItem&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>&ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 <code>getTopics</code>，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。<br>&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：<br>&ensp;&ensp;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">computed: mapGetters(&#123;</div><div class=\"line\">    <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\">&#125;),</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式：  </p>\n<p> <code>topicsListData :&#39;getTopicsListData</code>  </p>\n<p> &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。</p>\n<p>&ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示  </p>\n<p><code>&lt;index-item :item-list=&#39;topicsListData&#39;&gt;&lt;/index-item&gt;</code>;  </p>\n<p>在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 </p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><ul>\n<li>对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。<ul>\n<li>后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。</li>\n<li>当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。</p>","more":"<p><strong>本项目github地址</strong> <a href=\"https://github.com/xianyulaodi/vue-cnode-template\">点击这里</a></p>\n<p>&ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。</p>\n<p>&ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑)</p>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201703/776370-20170330192330508-241902663.png\" alt=\"首页\">首页&ensp;&ensp;<br><img src=\"//images2015.cnblogs.com/blog/776370/201703/776370-20170330192446461-1898007541.png\" alt=\"详情页\">详情页</p>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含：</p>\n<ul>\n<li>基础库：<code>vue.js</code>、 <code>vue-router2.0版本</code>、<code>vuex</code>、<code>axios</code></li>\n<li>编译/打包工具：<code>webpack</code>、<code>babel</code>、<code>node-sass</code></li>\n<li>单元测试工具：<code>karma</code>、<code>mocha</code>、<code>sinon-chai</code></li>\n<li>本地服务器：<code>express</code></li>\n</ul>\n<h2 id=\"运行方式\"><a href=\"#运行方式\" class=\"headerlink\" title=\"运行方式\"></a>运行方式</h2><ul>\n<li>开发环境</li>\n</ul>\n<ol>\n<li><code>npm install</code> </li>\n<li>点击start.sh、或者直接cmd里面输入  <code>npm run dev</code></li>\n</ol>\n<ul>\n<li>配置构建项目，构建好的文件会输出到 “dist” 目录，<br> <code>npm run build</code></li>\n<li>服务器，可以查看构建的页面<br>  <code>npm run build-server</code></li>\n<li>单元测试<br>  <code>npm run unit</code></li>\n</ul>\n<h2 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h2><p>&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者</p>\n<h2 id=\"vue组件的生命周期\"><a href=\"#vue组件的生命周期\" class=\"headerlink\" title=\"vue组件的生命周期\"></a>vue组件的生命周期</h2><p>&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下：<br><img src=\"//images.cnblogs.com/cnblogs_com/fly_dragon/276813/o_lifecycle-%E6%A0%87%E6%B3%A8%E7%89%88%E6%9C%AC.png\" alt=\"组件生命周期\"></p>\n<h2 id=\"如何写一个组件\"><a href=\"#如何写一个组件\" class=\"headerlink\" title=\"如何写一个组件\"></a>如何写一个组件</h2><p>&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例</p>\n<blockquote>\n<p>我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">\t <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-list-wrap\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-list\"</span>&gt;</span></div><div class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">\"item in itemList\"</span>&gt;</span></div><div class=\"line\">           \t    <span class=\"tag\">&lt;<span class=\"name\">router-link</span> <span class=\"attr\">:to</span>=<span class=\"string\">\"&#123;name:'detail',params:&#123;id:item.id&#125;&#125;\"</span> &gt;</span>&#123;&#123; item.title &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">router-link</span>&gt;</span></div><div class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">  <span class=\"attr\">props</span>: [<span class=\"string\">'itemList'</span>],</div><div class=\"line\">  <span class=\"attr\">mounted</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"scss\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet/scss\"</span>&gt;</span><span class=\"undefined\"></div><div class=\"line\"></div><div class=\"line\">.item-list-wrap&#123;</div><div class=\"line\">  background: #fff;</div><div class=\"line\">  .item-list li&#123;</div><div class=\"line\">    height: 45px;</div><div class=\"line\">    line-height: 45px;</div><div class=\"line\">    text-align: left;</div><div class=\"line\">    padding:0 10px;</div><div class=\"line\">    font-size: 14px;</div><div class=\"line\">    overflow: hidden;</div><div class=\"line\">    text-overflow: ellipsis;</div><div class=\"line\">    white-space:nowrap;</div><div class=\"line\">    border-bottom: 1px solid #ccc;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>&ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.<br>那么父组件如何调用这些组件呢，使用方法如下：<br>views/index.vue<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">c-header</span> <span class=\"attr\">:hTitle</span>=<span class=\"string\">\"title\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">c-header</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">'topicsListData'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">import</span> cHeader <span class=\"keyword\">from</span> <span class=\"string\">'components/header'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> indexItem <span class=\"keyword\">from</span> <span class=\"string\">'components/indexItem'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'node中文网'</span>,</div><div class=\"line\">        <span class=\"attr\">tabId</span>:<span class=\"number\">0</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">computed</span>: mapGetters(&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\"></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\">     <span class=\"attr\">components</span>: &#123;cHeader,indexItem&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。</p>\n<p>&ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过<br> <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">传入的数据</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">components: &#123;cHeader,indexItem&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"vur-router\"><a href=\"#vur-router\" class=\"headerlink\" title=\"vur-router\"></a>vur-router</h2><ol>\n<li>我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。</li>\n<li>传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.$route.params.id</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大</p>\n<h2 id=\"vuex2-0\"><a href=\"#vuex2-0\" class=\"headerlink\" title=\"vuex2.0\"></a>vuex2.0</h2><p>&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。<br>   <img src=\"https://vuex.vuejs.org/zh-cn/images/vuex.png\" alt=\"vuex示意图\"></p>\n<h4 id=\"这里稍作解释：-个人理解，有误之处，欢迎指出\"><a href=\"#这里稍作解释：-个人理解，有误之处，欢迎指出\" class=\"headerlink\" title=\"这里稍作解释：(个人理解，有误之处，欢迎指出)\"></a>这里稍作解释：(个人理解，有误之处，欢迎指出)</h4><ul>\n<li>vuex也是跟redux一样，有且只能由一个store</li>\n<li>在vuex中，状态的改变只能是通过mutations</li>\n<li>用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations</li>\n<li>mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations</li>\n<li>触发action用dispatch、触发mutations用commit</li>\n</ul>\n<h3 id=\"这里介绍一下vuex异步的操作\"><a href=\"#这里介绍一下vuex异步的操作\" class=\"headerlink\" title=\"这里介绍一下vuex异步的操作\"></a>这里介绍一下vuex异步的操作</h3><p>&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。<br>&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'axios'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../../constants/constants'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> state = &#123;</div><div class=\"line\">    <span class=\"attr\">topicsList</span>:[]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> getters = &#123;</div><div class=\"line\">    <span class=\"attr\">getTopicsListData</span>: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.topicsList</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> actions = &#123;</div><div class=\"line\">\t<span class=\"comment\">/**</div><div class=\"line\">     * @name  获取主页数据</div><div class=\"line\">     * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去</div><div class=\"line\">     * </div><div class=\"line\">     * # 注意点：</div><div class=\"line\">     * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定</div><div class=\"line\">     */</span></div><div class=\"line\">    [types.GET_TOPICS](&#123;commit&#125;,obj) &#123;</div><div class=\"line\">        axios.get(<span class=\"string\">`https://cnodejs.org/api/v1/topics?page=<span class=\"subst\">$&#123;obj.pageNo&#125;</span>&amp;limit=20&amp;tab=<span class=\"subst\">$&#123;obj.tab&#125;</span>`</span>)</div><div class=\"line\">        .then(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> &#123;</div><div class=\"line\">          commit(types.SET_TOPICS, &#123; <span class=\"attr\">list</span>: response.data.data &#125;)</div><div class=\"line\">        &#125;, (err) =&gt; &#123;</div><div class=\"line\">          <span class=\"built_in\">console</span>.log(err)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">const</span> mutations = &#123;</div><div class=\"line\">    <span class=\"comment\">// 获取首页的数据</span></div><div class=\"line\">    [types.SET_TOPICS](state,&#123;list&#125;) &#123;</div><div class=\"line\">        state.topicsList=list;  <span class=\"comment\">//再次记住，mutations是唯一允许更新应用状态的地方</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span>&#123;</div><div class=\"line\">    state,</div><div class=\"line\">    getters,</div><div class=\"line\">    actions,</div><div class=\"line\">    mutations</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下：</p>\n<ol>\n<li>我们定义了一个默认的状态topicsList，并赋值为一个空数组</li>\n<li>我们定义了一个action来获取后端数据， <code>[types.GET_TOPICS]({commit},obj) {}</code>,其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成<code>getTopics({commit},obj) {}</code>这种形式的。<br>action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。</li>\n<li>我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态</li>\n<li>在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。</li>\n</ol>\n<h3 id=\"页面是如何使用传回来的数据的？\"><a href=\"#页面是如何使用传回来的数据的？\" class=\"headerlink\" title=\"页面是如何使用传回来的数据的？\"></a>页面是如何使用传回来的数据的？</h3><p> 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">index-item</span> <span class=\"attr\">:item-list</span>=<span class=\"string\">'topicsListData'</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">index-item</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></div><div class=\"line\">  <span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;mapState&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> &#123;mapGetters&#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> indexItem <span class=\"keyword\">from</span> <span class=\"string\">'components/indexItem'</span>;</div><div class=\"line\">  <span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'../constants/constants'</span>;</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    data () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'node中文网'</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">// computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新</span></div><div class=\"line\">    computed: mapGetters(&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\"></div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"attr\">methods</span>: &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">/*</div><div class=\"line\">      * @获取内容</div><div class=\"line\">      */</span></div><div class=\"line\">      getTopics (page,tab,index) &#123;</div><div class=\"line\">          <span class=\"comment\">// 触发action</span></div><div class=\"line\">          <span class=\"keyword\">this</span>.$store.dispatch(&#123;</div><div class=\"line\">              <span class=\"attr\">type</span>:types.GET_TOPICS,</div><div class=\"line\">              <span class=\"attr\">pageNo</span>:page,</div><div class=\"line\">              <span class=\"attr\">tab</span>:tab</div><div class=\"line\">          &#125;);</div><div class=\"line\">          <span class=\"keyword\">this</span>.tabId=index;</div><div class=\"line\">      &#125;,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">/*</div><div class=\"line\">    * @初始化(组件挂载完成)，相当于react中的componentWillamount</div><div class=\"line\">    */</span></div><div class=\"line\">    mounted () &#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>.getTopics(<span class=\"number\">1</span>,<span class=\"string\">'all'</span>); </div><div class=\"line\">      </div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">components</span>: &#123;indexItem&#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>&ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 <code>getTopics</code>，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。<br>&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：<br>&ensp;&ensp;<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">computed: mapGetters(&#123;</div><div class=\"line\">    <span class=\"attr\">topicsListData</span> :<span class=\"string\">'getTopicsListData'</span></div><div class=\"line\">&#125;),</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式：  </p>\n<p> <code>topicsListData :&#39;getTopicsListData</code>  </p>\n<p> &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。</p>\n<p>&ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示  </p>\n<p><code>&lt;index-item :item-list=&#39;topicsListData&#39;&gt;&lt;/index-item&gt;</code>;  </p>\n<p>在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 </p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><ul>\n<li>对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。<ul>\n<li>后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。</li>\n<li>当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出</li>\n</ul>\n</li>\n</ul>"},{"title":"老生常谈，css实现左侧固定右侧自适应","date":"2017-05-25T02:20:00.000Z","_content":"\n&ensp;&ensp;这是一个在项目中经常使用的一个功能，而且实现方式也比较多，所以我们今天来总结以下几种实现方法\n\n<!--more-->\n我们的所有html布局都一样，都为下面的布局\n\n```html\n<div class=\"parent\">\n  <div class=\"left\">左边内容</div>\n  <div class=\"right\">右边内容</div>\n</div>\n```\n<br>\n## 方法1：position + margin\n\n方法：父集相对定位，左侧绝对定位，右侧margin-left\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position: relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   position: absolute;\n   left: 0;\n   background: red;\n}\n.right {\n  height: 100px;\n  margin-left: 100px;\n  background: blue;\n}\n```\n\n<br>\n## 方法2 ： 左测浮动，右侧overflow\n\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float: left;\n   background: red;\n}\n.right {\n  height: 100px;\n  overflow: hidden;\n  background: blue;\n}\n```\n<br>\n## 方法3：左侧浮动，右侧margin-left\n跟方法2类似，只是将右侧overflow改为margin-left\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position: relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float: left;\n   background: red;\n}\n.right {\n  height: 100px;\n  margin-left: 100px;\n  background: blue;\n}\n```\n<br>\n## 方法4; css3 flex\n方法： 利用css3的flex属性，右边设置为占比1，填充满剩余空间\n\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  display: flex;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   background: red;\n}\n.right {\n  height: 100px;\n  flex: 1;\n  background: blue;\n}\n```\n<br>\n## 方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position:relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float:left;\n   background: red;\n}\n.right {\n  height: 100px;\n  float:left;\n  width:calc(100% - 100px);\n  background: blue;\n}\n```\n<br>\n## 方法六  左右两边 absolute\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position:relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   position: absolute;\n   left: 0;\n   background: red;\n}\n.right {\n  height: 100px;\n  position: absolute;\n  left: 100px;\n  right: 0;\n  background: blue;\n}\n```\n","source":"_posts/老生常谈css实现左侧固定，右侧自适应.md","raw":"---\ntitle: 老生常谈，css实现左侧固定右侧自适应\ndate: 2017-05-25 10:20\ncategories:\ntags:\n     - css\n---\n\n&ensp;&ensp;这是一个在项目中经常使用的一个功能，而且实现方式也比较多，所以我们今天来总结以下几种实现方法\n\n<!--more-->\n我们的所有html布局都一样，都为下面的布局\n\n```html\n<div class=\"parent\">\n  <div class=\"left\">左边内容</div>\n  <div class=\"right\">右边内容</div>\n</div>\n```\n<br>\n## 方法1：position + margin\n\n方法：父集相对定位，左侧绝对定位，右侧margin-left\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position: relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   position: absolute;\n   left: 0;\n   background: red;\n}\n.right {\n  height: 100px;\n  margin-left: 100px;\n  background: blue;\n}\n```\n\n<br>\n## 方法2 ： 左测浮动，右侧overflow\n\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float: left;\n   background: red;\n}\n.right {\n  height: 100px;\n  overflow: hidden;\n  background: blue;\n}\n```\n<br>\n## 方法3：左侧浮动，右侧margin-left\n跟方法2类似，只是将右侧overflow改为margin-left\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position: relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float: left;\n   background: red;\n}\n.right {\n  height: 100px;\n  margin-left: 100px;\n  background: blue;\n}\n```\n<br>\n## 方法4; css3 flex\n方法： 利用css3的flex属性，右边设置为占比1，填充满剩余空间\n\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  display: flex;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   background: red;\n}\n.right {\n  height: 100px;\n  flex: 1;\n  background: blue;\n}\n```\n<br>\n## 方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position:relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   float:left;\n   background: red;\n}\n.right {\n  height: 100px;\n  float:left;\n  width:calc(100% - 100px);\n  background: blue;\n}\n```\n<br>\n## 方法六  左右两边 absolute\n```css\n.parent {\n  width: 300px;\n  height: 100px;\n  margin: 100px auto;\n  position:relative;\n}\n.left {\n   width: 100px;\n   height: 100px;\n   position: absolute;\n   left: 0;\n   background: red;\n}\n.right {\n  height: 100px;\n  position: absolute;\n  left: 100px;\n  right: 0;\n  background: blue;\n}\n```\n","slug":"老生常谈css实现左侧固定，右侧自适应","published":1,"updated":"2017-05-25T15:42:24.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr7z000m9gscliu94fjv","content":"<p>&ensp;&ensp;这是一个在项目中经常使用的一个功能，而且实现方式也比较多，所以我们今天来总结以下几种实现方法</p>\n<a id=\"more\"></a>\n<p>我们的所有html布局都一样，都为下面的布局</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>左边内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>右边内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法1：position-margin\"><a href=\"#方法1：position-margin\" class=\"headerlink\" title=\"方法1：position + margin\"></a>方法1：position + margin</h2><p>方法：父集相对定位，左侧绝对定位，右侧margin-left<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">   <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"方法2-：-左测浮动，右侧overflow\"><a href=\"#方法2-：-左测浮动，右侧overflow\" class=\"headerlink\" title=\"方法2 ： 左测浮动，右侧overflow\"></a>方法2 ： 左测浮动，右侧overflow</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>: left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法3：左侧浮动，右侧margin-left\"><a href=\"#方法3：左侧浮动，右侧margin-left\" class=\"headerlink\" title=\"方法3：左侧浮动，右侧margin-left\"></a>方法3：左侧浮动，右侧margin-left</h2><p>跟方法2类似，只是将右侧overflow改为margin-left<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>: left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"方法4-css3-flex\"><a href=\"#方法4-css3-flex\" class=\"headerlink\" title=\"方法4; css3 flex\"></a>方法4; css3 flex</h2><p>方法： 利用css3的flex属性，右边设置为占比1，填充满剩余空间</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法五：使用CSS3属性calc-进行计算。注意：calc-里的运算符两边必须有空格\"><a href=\"#方法五：使用CSS3属性calc-进行计算。注意：calc-里的运算符两边必须有空格\" class=\"headerlink\" title=\"方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格\"></a>方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>:left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>:left;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"built_in\">calc</span>(100% - 100px);</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法六-左右两边-absolute\"><a href=\"#方法六-左右两边-absolute\" class=\"headerlink\" title=\"方法六  左右两边 absolute\"></a>方法六  左右两边 absolute</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">   <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;这是一个在项目中经常使用的一个功能，而且实现方式也比较多，所以我们今天来总结以下几种实现方法</p>","more":"<p>我们的所有html布局都一样，都为下面的布局</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"parent\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"left\"</span>&gt;</span>左边内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"right\"</span>&gt;</span>右边内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法1：position-margin\"><a href=\"#方法1：position-margin\" class=\"headerlink\" title=\"方法1：position + margin\"></a>方法1：position + margin</h2><p>方法：父集相对定位，左侧绝对定位，右侧margin-left<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">   <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"方法2-：-左测浮动，右侧overflow\"><a href=\"#方法2-：-左测浮动，右侧overflow\" class=\"headerlink\" title=\"方法2 ： 左测浮动，右侧overflow\"></a>方法2 ： 左测浮动，右侧overflow</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>: left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法3：左侧浮动，右侧margin-left\"><a href=\"#方法3：左侧浮动，右侧margin-left\" class=\"headerlink\" title=\"方法3：左侧浮动，右侧margin-left\"></a>方法3：左侧浮动，右侧margin-left</h2><p>跟方法2类似，只是将右侧overflow改为margin-left<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>: relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>: left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><br></p>\n<h2 id=\"方法4-css3-flex\"><a href=\"#方法4-css3-flex\" class=\"headerlink\" title=\"方法4; css3 flex\"></a>方法4; css3 flex</h2><p>方法： 利用css3的flex属性，右边设置为占比1，填充满剩余空间</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">display</span>: flex;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法五：使用CSS3属性calc-进行计算。注意：calc-里的运算符两边必须有空格\"><a href=\"#方法五：使用CSS3属性calc-进行计算。注意：calc-里的运算符两边必须有空格\" class=\"headerlink\" title=\"方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格\"></a>方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">float</span>:left;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">float</span>:left;</div><div class=\"line\">  <span class=\"attribute\">width</span>:<span class=\"built_in\">calc</span>(100% - 100px);</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"方法六-左右两边-absolute\"><a href=\"#方法六-左右两边-absolute\" class=\"headerlink\" title=\"方法六  左右两边 absolute\"></a>方法六  左右两边 absolute</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.parent</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span> auto;</div><div class=\"line\">  <span class=\"attribute\">position</span>:relative;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.left</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">   <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">   <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</div><div class=\"line\">   <span class=\"attribute\">background</span>: red;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.right</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">100px</span>;</div><div class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"以setTimeout来聊聊Event Loop","date":"2017-02-26T05:35:00.000Z","_content":"\n> 平时的工作中，也许你会经常用到setTimeout这个方法，可是你真的了解setTimeout吗？本文想通过总结setTimeout的用法，顺便来探索javascript里面的事件执行机制。\n\n\n<!--more-->\n\n## 1、setTimeout基本用法\n---\n1、`setTimeout(code,millisec)`\n　　setTimeout函数接受两个参数，第一个参数code是将要推迟执行的函数名或者一段代码，第二个参数millisec是推迟执行的毫秒数。\n例如：\n```javascript\nsetTimeout('console.log(2)',100);\nsetTimeout(function(){console.log(2)},100);\n```\n　　如果直接在setTimeout中直接执行代码， 需要以字符串的形式去写，引擎内部会将字符串转为可执行的代码\n\n2、再来一些简单些的代码\n```javascript\nconsole.log(1);\nsetTimeout('console.log(2)',1000);\nconsole.log(3);\n```\n是的，如你所愿，依次输出的是  `// 1 3 2`\n\n3、代码升级版\n```javascript\nconsole.log(1);\n\nsetTimeout(function(){\n    console.log(2);\n},300);\n\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n这个时候的输入顺序是怎样的呢？这里先埋个伏笔，因为我们是以setTimeout来聊Event Loop\n\n## 2、Event Loop简介\n---\n#### 什么是Event Loop呢？\n&ensp;&ensp;&ensp;&ensp;因为javascript是单线程的，所谓的单线程是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，可以叫它为主线程。\n&ensp;&ensp;&ensp;&ensp;除了主线程，还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。我们以setTimeout为例，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226101214523-381417596.png)\n　　Javascript执行引擎的主线程运行的时候，产生堆（heap）和栈（stack）。程序中代码依次进入栈中等待执行，当调用setTimeout()方法时，即图中右侧WebAPIs方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列，依次执行那些满足触发条件的回调函数。\n　　在上图中的callback queue中指的是 \"任务队列\"，也可以理解为消息的队列，“消息“我们可以简单理解为是：注册异步任务时添加的回调函数。\n\n例如：\n```javascript\nsetTimeout(function(){\n    console.log(‘hello’);\n},100);\n```\n&ensp;&ensp;&ensp;&ensp;其中里面的function(){console.log('hello')}就是一个消息，任务队列里面保存的就是这些回调函数\n\n## 3、理解js代码的执行\n---\n我们以一段代码的运行来进行理解，代码如下：\n```javascript\nconsole.log('start');\n\n//Timer1\nsetTimeout(function(){\n    console.log('hello');\n},200);\n\n//Timer2\nsetTimeout(function(){\n    console.log('world');\n},100);\n\nconsole.log('end');\n```\n代码运行的gif图如下：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226112523241-1162148115.gif)\n\n我们分步骤来进行这个过程解答\n　　 1、js执行引擎开始执行上述代码时，会先讲一个main()方法加入执行栈。首先第一个console.log(‘start’)入栈，console.log方法是一个webkit内核支持的普通方法，而不是前面图中WebAPIs涉及的方法，所以这里log('start')方法立即出栈被引擎执行。\n　　2、引擎继续往下，将setTimeout(callback,200)添加到执行栈。setTimeout()方法属于事件循环模型中WebAPIs中的方法，引擎在将setTimeout()方法出栈执行时，将延时执行的函数交给了相应模块，即图右方的timer模块来处理。\n　　3、然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印'end'，\n　　4、执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印'world'，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印'hello'，清空执行栈，此时任务队列为空，执行结束,程序处理完毕，main()方法也出栈。\n　　5、在这里再次强调一下，不是setTimeout加入了事件队列，而是setTimeout里面的回调函数加入了事件队列\n\n## 4、setTimeout问题的解答\n---\n回到我们文章之初的那倒题：\n```javascript\nconsole.log(1);\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n如果理解了上面的内容，那么这道题理解起来就比较容易了。\n　　首先是打印出 1，然后是10000个4，那么Time1、Time2、Time3是顺序是如何的呢？\n　　在这个代码中，for循环比较耗时，在Time1和Timer加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Time1和Time2并不会得以执行。当for循环结束，这时才将Time3交由Timer模块去管理，清空执行栈。虽然在这里Time3的延迟时间最短，但是加入任务队列后还是会排在Time1和Time2的后面，所以此时按顺序执行任务队列中的代码，依次打印2、3、5。\n所以执行结果为：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226131730320-9660993.jpg)\n\n## 5、关于setTimeout新的问题\n```javascript\nconsole.log(1);\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n　　上面这个问题中，Time3加入任务队列的时间比Time2,Time1晚，所以它是最后才执行的。那么问题来了，请看下面代码：\n```javascript\nconsole.log(1);\n\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n&ensp;&ensp;&ensp;&ensp;我们将Time1和Time2的顺序对换一下，按照前面的说法，Time2先加入任务队列，然后是Time1，再然后是Time3。可是执行的结果还是1、4、2、3、5，这是为什么呢？虽然Time1的执行时间短，可是它比Time2晚加入任务队列啊。\n&ensp;&ensp;&ensp;&ensp;为了验证这个问题，我们可以提出这样的一个假设：\n`如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大`\n\n可能假设听起来比较拗口，我们可以用代码来理解一下：\n\n**代码1：**\n\n```javascript\n//Time2\nsetTimeout(function(){\n    console.log(2);\n},400);\n\nvar start=new Date();\nfor (var i = 0;i<5000;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n\n```\nTime1比Time2设定的执行时间早100ms，但是Time2先加入任务队列，在Time2和Time1时间有一个阻塞的for循环，执行结果如下：\n\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227132406766-1770219106.png)\n\nTime2先执行；\n\n \n**代码2：**\n我们把for循环里面的时间设置短一点：\n\n```javascript\nsetTimeout(function(){\n    console.log(2);\n},400);\n\nvar start=new Date();\nfor (var i = 0;i<500;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n\n```\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227132754095-1066713665.png)\n\n此时，Time1先执行，因为阻塞的耗时小于Time1和Time2的执行间隔时间100毫秒；<br />\n\n**代码3：**\n我们再来验证一下，把Time2的执行时间设为350毫秒；\n```javascript\n//Time2\nsetTimeout(function(){\n    console.log(2);\n},350);\n\nvar start=new Date();\nfor (var i = 0;i<500;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n```\n直接结果为：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227133015141-186210832.png)\nTime2先执行，因为阻塞的时间大于两个setTimeout之间的间隔时间。\n\n　　通过上面的假设，我们可以得出这样一个结论：**如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大**\n\n## 总结\n 　　理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，知道事件的走向，才能更好的驾驭Javascript。本文是对事件循环的一个小小总结，更多的干货，可以看看下面的参考文档。本文有误之处，欢迎指出<br /><br />\n\n \n参考文档：\n\n[【转向Javascript系列】从setTimeout说事件循环模型](//www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)\n[JavaScript 运行机制详解：再谈Event Loop](//www.ruanyifeng.com/blog/2014/10/event-loop.html)\n[JavaScript：彻底理解同步、异步和事件循环(Event Loop)](https://segmentfault.com/a/1190000004322358)","source":"_posts/以setTimeout来聊聊Event Loop.md","raw":"---\ntitle: 以setTimeout来聊聊Event Loop\ndate: 2017-02-26 13:35\ncategories:\ntags:\n     - 博客园迁移\n     - setTimeout\n     - Eventloop\n---\n\n> 平时的工作中，也许你会经常用到setTimeout这个方法，可是你真的了解setTimeout吗？本文想通过总结setTimeout的用法，顺便来探索javascript里面的事件执行机制。\n\n\n<!--more-->\n\n## 1、setTimeout基本用法\n---\n1、`setTimeout(code,millisec)`\n　　setTimeout函数接受两个参数，第一个参数code是将要推迟执行的函数名或者一段代码，第二个参数millisec是推迟执行的毫秒数。\n例如：\n```javascript\nsetTimeout('console.log(2)',100);\nsetTimeout(function(){console.log(2)},100);\n```\n　　如果直接在setTimeout中直接执行代码， 需要以字符串的形式去写，引擎内部会将字符串转为可执行的代码\n\n2、再来一些简单些的代码\n```javascript\nconsole.log(1);\nsetTimeout('console.log(2)',1000);\nconsole.log(3);\n```\n是的，如你所愿，依次输出的是  `// 1 3 2`\n\n3、代码升级版\n```javascript\nconsole.log(1);\n\nsetTimeout(function(){\n    console.log(2);\n},300);\n\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n这个时候的输入顺序是怎样的呢？这里先埋个伏笔，因为我们是以setTimeout来聊Event Loop\n\n## 2、Event Loop简介\n---\n#### 什么是Event Loop呢？\n&ensp;&ensp;&ensp;&ensp;因为javascript是单线程的，所谓的单线程是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，可以叫它为主线程。\n&ensp;&ensp;&ensp;&ensp;除了主线程，还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。我们以setTimeout为例，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226101214523-381417596.png)\n　　Javascript执行引擎的主线程运行的时候，产生堆（heap）和栈（stack）。程序中代码依次进入栈中等待执行，当调用setTimeout()方法时，即图中右侧WebAPIs方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列，依次执行那些满足触发条件的回调函数。\n　　在上图中的callback queue中指的是 \"任务队列\"，也可以理解为消息的队列，“消息“我们可以简单理解为是：注册异步任务时添加的回调函数。\n\n例如：\n```javascript\nsetTimeout(function(){\n    console.log(‘hello’);\n},100);\n```\n&ensp;&ensp;&ensp;&ensp;其中里面的function(){console.log('hello')}就是一个消息，任务队列里面保存的就是这些回调函数\n\n## 3、理解js代码的执行\n---\n我们以一段代码的运行来进行理解，代码如下：\n```javascript\nconsole.log('start');\n\n//Timer1\nsetTimeout(function(){\n    console.log('hello');\n},200);\n\n//Timer2\nsetTimeout(function(){\n    console.log('world');\n},100);\n\nconsole.log('end');\n```\n代码运行的gif图如下：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226112523241-1162148115.gif)\n\n我们分步骤来进行这个过程解答\n　　 1、js执行引擎开始执行上述代码时，会先讲一个main()方法加入执行栈。首先第一个console.log(‘start’)入栈，console.log方法是一个webkit内核支持的普通方法，而不是前面图中WebAPIs涉及的方法，所以这里log('start')方法立即出栈被引擎执行。\n　　2、引擎继续往下，将setTimeout(callback,200)添加到执行栈。setTimeout()方法属于事件循环模型中WebAPIs中的方法，引擎在将setTimeout()方法出栈执行时，将延时执行的函数交给了相应模块，即图右方的timer模块来处理。\n　　3、然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印'end'，\n　　4、执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印'world'，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印'hello'，清空执行栈，此时任务队列为空，执行结束,程序处理完毕，main()方法也出栈。\n　　5、在这里再次强调一下，不是setTimeout加入了事件队列，而是setTimeout里面的回调函数加入了事件队列\n\n## 4、setTimeout问题的解答\n---\n回到我们文章之初的那倒题：\n```javascript\nconsole.log(1);\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n如果理解了上面的内容，那么这道题理解起来就比较容易了。\n　　首先是打印出 1，然后是10000个4，那么Time1、Time2、Time3是顺序是如何的呢？\n　　在这个代码中，for循环比较耗时，在Time1和Timer加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Time1和Time2并不会得以执行。当for循环结束，这时才将Time3交由Timer模块去管理，清空执行栈。虽然在这里Time3的延迟时间最短，但是加入任务队列后还是会排在Time1和Time2的后面，所以此时按顺序执行任务队列中的代码，依次打印2、3、5。\n所以执行结果为：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170226131730320-9660993.jpg)\n\n## 5、关于setTimeout新的问题\n```javascript\nconsole.log(1);\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n　　上面这个问题中，Time3加入任务队列的时间比Time2,Time1晚，所以它是最后才执行的。那么问题来了，请看下面代码：\n```javascript\nconsole.log(1);\n\n//Time2\nsetTimeout(function(){\n    console.log(3)\n},400);\n\n//Time1\nsetTimeout(function(){\n    console.log(2);\n},300);\n\nfor (var i = 0;i<10000;i++) {\n    console.log(4);\n}\n//Time3\nsetTimeout(function(){\n    console.log(5);\n},100);\n```\n&ensp;&ensp;&ensp;&ensp;我们将Time1和Time2的顺序对换一下，按照前面的说法，Time2先加入任务队列，然后是Time1，再然后是Time3。可是执行的结果还是1、4、2、3、5，这是为什么呢？虽然Time1的执行时间短，可是它比Time2晚加入任务队列啊。\n&ensp;&ensp;&ensp;&ensp;为了验证这个问题，我们可以提出这样的一个假设：\n`如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大`\n\n可能假设听起来比较拗口，我们可以用代码来理解一下：\n\n**代码1：**\n\n```javascript\n//Time2\nsetTimeout(function(){\n    console.log(2);\n},400);\n\nvar start=new Date();\nfor (var i = 0;i<5000;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n\n```\nTime1比Time2设定的执行时间早100ms，但是Time2先加入任务队列，在Time2和Time1时间有一个阻塞的for循环，执行结果如下：\n\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227132406766-1770219106.png)\n\nTime2先执行；\n\n \n**代码2：**\n我们把for循环里面的时间设置短一点：\n\n```javascript\nsetTimeout(function(){\n    console.log(2);\n},400);\n\nvar start=new Date();\nfor (var i = 0;i<500;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n\n```\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227132754095-1066713665.png)\n\n此时，Time1先执行，因为阻塞的耗时小于Time1和Time2的执行间隔时间100毫秒；<br />\n\n**代码3：**\n我们再来验证一下，把Time2的执行时间设为350毫秒；\n```javascript\n//Time2\nsetTimeout(function(){\n    console.log(2);\n},350);\n\nvar start=new Date();\nfor (var i = 0;i<500;i++) {\n    console.log('这里只是模拟一个耗时操作');\n};\nvar end=new Date();\nconsole.log('阻塞耗时：'+Number(end-start)+'毫秒');\n\n//Time1\nsetTimeout(function(){\n    console.log(3)\n},300);\n```\n直接结果为：\n![](//images2015.cnblogs.com/blog/776370/201702/776370-20170227133015141-186210832.png)\nTime2先执行，因为阻塞的时间大于两个setTimeout之间的间隔时间。\n\n　　通过上面的假设，我们可以得出这样一个结论：**如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大**\n\n## 总结\n 　　理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，知道事件的走向，才能更好的驾驭Javascript。本文是对事件循环的一个小小总结，更多的干货，可以看看下面的参考文档。本文有误之处，欢迎指出<br /><br />\n\n \n参考文档：\n\n[【转向Javascript系列】从setTimeout说事件循环模型](//www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/)\n[JavaScript 运行机制详解：再谈Event Loop](//www.ruanyifeng.com/blog/2014/10/event-loop.html)\n[JavaScript：彻底理解同步、异步和事件循环(Event Loop)](https://segmentfault.com/a/1190000004322358)","slug":"以setTimeout来聊聊Event Loop","published":1,"updated":"2017-04-18T15:40:01.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr93000p9gscmucyb6wh","content":"<blockquote>\n<p>平时的工作中，也许你会经常用到setTimeout这个方法，可是你真的了解setTimeout吗？本文想通过总结setTimeout的用法，顺便来探索javascript里面的事件执行机制。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1、setTimeout基本用法\"><a href=\"#1、setTimeout基本用法\" class=\"headerlink\" title=\"1、setTimeout基本用法\"></a>1、setTimeout基本用法</h2><hr>\n<p>1、<code>setTimeout(code,millisec)</code><br>　　setTimeout函数接受两个参数，第一个参数code是将要推迟执行的函数名或者一段代码，第二个参数millisec是推迟执行的毫秒数。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"string\">'console.log(2)'</span>,<span class=\"number\">100</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>　　如果直接在setTimeout中直接执行代码， 需要以字符串的形式去写，引擎内部会将字符串转为可执行的代码</p>\n<p>2、再来一些简单些的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">setTimeout(<span class=\"string\">'console.log(2)'</span>,<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>是的，如你所愿，依次输出的是  <code>// 1 3 2</code></p>\n<p>3、代码升级版<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>这个时候的输入顺序是怎样的呢？这里先埋个伏笔，因为我们是以setTimeout来聊Event Loop</p>\n<h2 id=\"2、Event-Loop简介\"><a href=\"#2、Event-Loop简介\" class=\"headerlink\" title=\"2、Event Loop简介\"></a>2、Event Loop简介</h2><hr>\n<h4 id=\"什么是Event-Loop呢？\"><a href=\"#什么是Event-Loop呢？\" class=\"headerlink\" title=\"什么是Event Loop呢？\"></a>什么是Event Loop呢？</h4><p>&ensp;&ensp;&ensp;&ensp;因为javascript是单线程的，所谓的单线程是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，可以叫它为主线程。<br>&ensp;&ensp;&ensp;&ensp;除了主线程，还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。我们以setTimeout为例，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226101214523-381417596.png\" alt=\"\"><br>　　Javascript执行引擎的主线程运行的时候，产生堆（heap）和栈（stack）。程序中代码依次进入栈中等待执行，当调用setTimeout()方法时，即图中右侧WebAPIs方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列，依次执行那些满足触发条件的回调函数。<br>　　在上图中的callback queue中指的是 “任务队列”，也可以理解为消息的队列，“消息“我们可以简单理解为是：注册异步任务时添加的回调函数。</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(‘hello’);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;其中里面的function(){console.log(‘hello’)}就是一个消息，任务队列里面保存的就是这些回调函数</p>\n<h2 id=\"3、理解js代码的执行\"><a href=\"#3、理解js代码的执行\" class=\"headerlink\" title=\"3、理解js代码的执行\"></a>3、理解js代码的执行</h2><hr>\n<p>我们以一段代码的运行来进行理解，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Timer1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Timer2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure></p>\n<p>代码运行的gif图如下：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226112523241-1162148115.gif\" alt=\"\"></p>\n<p>我们分步骤来进行这个过程解答<br>　　 1、js执行引擎开始执行上述代码时，会先讲一个main()方法加入执行栈。首先第一个console.log(‘start’)入栈，console.log方法是一个webkit内核支持的普通方法，而不是前面图中WebAPIs涉及的方法，所以这里log(‘start’)方法立即出栈被引擎执行。<br>　　2、引擎继续往下，将setTimeout(callback,200)添加到执行栈。setTimeout()方法属于事件循环模型中WebAPIs中的方法，引擎在将setTimeout()方法出栈执行时，将延时执行的函数交给了相应模块，即图右方的timer模块来处理。<br>　　3、然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’，<br>　　4、执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束,程序处理完毕，main()方法也出栈。<br>　　5、在这里再次强调一下，不是setTimeout加入了事件队列，而是setTimeout里面的回调函数加入了事件队列</p>\n<h2 id=\"4、setTimeout问题的解答\"><a href=\"#4、setTimeout问题的解答\" class=\"headerlink\" title=\"4、setTimeout问题的解答\"></a>4、setTimeout问题的解答</h2><hr>\n<p>回到我们文章之初的那倒题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>如果理解了上面的内容，那么这道题理解起来就比较容易了。<br>　　首先是打印出 1，然后是10000个4，那么Time1、Time2、Time3是顺序是如何的呢？<br>　　在这个代码中，for循环比较耗时，在Time1和Timer加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Time1和Time2并不会得以执行。当for循环结束，这时才将Time3交由Timer模块去管理，清空执行栈。虽然在这里Time3的延迟时间最短，但是加入任务队列后还是会排在Time1和Time2的后面，所以此时按顺序执行任务队列中的代码，依次打印2、3、5。<br>所以执行结果为：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226131730320-9660993.jpg\" alt=\"\"></p>\n<h2 id=\"5、关于setTimeout新的问题\"><a href=\"#5、关于setTimeout新的问题\" class=\"headerlink\" title=\"5、关于setTimeout新的问题\"></a>5、关于setTimeout新的问题</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<p>　　上面这个问题中，Time3加入任务队列的时间比Time2,Time1晚，所以它是最后才执行的。那么问题来了，请看下面代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;我们将Time1和Time2的顺序对换一下，按照前面的说法，Time2先加入任务队列，然后是Time1，再然后是Time3。可是执行的结果还是1、4、2、3、5，这是为什么呢？虽然Time1的执行时间短，可是它比Time2晚加入任务队列啊。<br>&ensp;&ensp;&ensp;&ensp;为了验证这个问题，我们可以提出这样的一个假设：<br><code>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大</code></p>\n<p>可能假设听起来比较拗口，我们可以用代码来理解一下：</p>\n<p><strong>代码1：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure>\n<p>Time1比Time2设定的执行时间早100ms，但是Time2先加入任务队列，在Time2和Time1时间有一个阻塞的for循环，执行结果如下：</p>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227132406766-1770219106.png\" alt=\"\"></p>\n<p>Time2先执行；</p>\n<p><strong>代码2：</strong><br>我们把for循环里面的时间设置短一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">500</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227132754095-1066713665.png\" alt=\"\"></p>\n<p>此时，Time1先执行，因为阻塞的耗时小于Time1和Time2的执行间隔时间100毫秒；<br></p>\n<p><strong>代码3：</strong><br>我们再来验证一下，把Time2的执行时间设为350毫秒；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">350</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">500</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure></p>\n<p>直接结果为：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227133015141-186210832.png\" alt=\"\"><br>Time2先执行，因为阻塞的时间大于两个setTimeout之间的间隔时间。</p>\n<p>　　通过上面的假设，我们可以得出这样一个结论：<strong>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p> 　　理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，知道事件的走向，才能更好的驾驭Javascript。本文是对事件循环的一个小小总结，更多的干货，可以看看下面的参考文档。本文有误之处，欢迎指出<br><br></p>\n<p>参考文档：</p>\n<p><a href=\"//www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/\">【转向Javascript系列】从setTimeout说事件循环模型</a><br><a href=\"//www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a><br><a href=\"https://segmentfault.com/a/1190000004322358\" target=\"_blank\" rel=\"external\">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>平时的工作中，也许你会经常用到setTimeout这个方法，可是你真的了解setTimeout吗？本文想通过总结setTimeout的用法，顺便来探索javascript里面的事件执行机制。</p>\n</blockquote>","more":"<h2 id=\"1、setTimeout基本用法\"><a href=\"#1、setTimeout基本用法\" class=\"headerlink\" title=\"1、setTimeout基本用法\"></a>1、setTimeout基本用法</h2><hr>\n<p>1、<code>setTimeout(code,millisec)</code><br>　　setTimeout函数接受两个参数，第一个参数code是将要推迟执行的函数名或者一段代码，第二个参数millisec是推迟执行的毫秒数。<br>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"string\">'console.log(2)'</span>,<span class=\"number\">100</span>);</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>　　如果直接在setTimeout中直接执行代码， 需要以字符串的形式去写，引擎内部会将字符串转为可执行的代码</p>\n<p>2、再来一些简单些的代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\">setTimeout(<span class=\"string\">'console.log(2)'</span>,<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>是的，如你所愿，依次输出的是  <code>// 1 3 2</code></p>\n<p>3、代码升级版<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>这个时候的输入顺序是怎样的呢？这里先埋个伏笔，因为我们是以setTimeout来聊Event Loop</p>\n<h2 id=\"2、Event-Loop简介\"><a href=\"#2、Event-Loop简介\" class=\"headerlink\" title=\"2、Event Loop简介\"></a>2、Event Loop简介</h2><hr>\n<h4 id=\"什么是Event-Loop呢？\"><a href=\"#什么是Event-Loop呢？\" class=\"headerlink\" title=\"什么是Event Loop呢？\"></a>什么是Event Loop呢？</h4><p>&ensp;&ensp;&ensp;&ensp;因为javascript是单线程的，所谓的单线程是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，可以叫它为主线程。<br>&ensp;&ensp;&ensp;&ensp;除了主线程，还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。我们以setTimeout为例，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226101214523-381417596.png\" alt=\"\"><br>　　Javascript执行引擎的主线程运行的时候，产生堆（heap）和栈（stack）。程序中代码依次进入栈中等待执行，当调用setTimeout()方法时，即图中右侧WebAPIs方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列，依次执行那些满足触发条件的回调函数。<br>　　在上图中的callback queue中指的是 “任务队列”，也可以理解为消息的队列，“消息“我们可以简单理解为是：注册异步任务时添加的回调函数。</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(‘hello’);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;其中里面的function(){console.log(‘hello’)}就是一个消息，任务队列里面保存的就是这些回调函数</p>\n<h2 id=\"3、理解js代码的执行\"><a href=\"#3、理解js代码的执行\" class=\"headerlink\" title=\"3、理解js代码的执行\"></a>3、理解js代码的执行</h2><hr>\n<p>我们以一段代码的运行来进行理解，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'start'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Timer1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'hello'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">200</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Timer2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'world'</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'end'</span>);</div></pre></td></tr></table></figure></p>\n<p>代码运行的gif图如下：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226112523241-1162148115.gif\" alt=\"\"></p>\n<p>我们分步骤来进行这个过程解答<br>　　 1、js执行引擎开始执行上述代码时，会先讲一个main()方法加入执行栈。首先第一个console.log(‘start’)入栈，console.log方法是一个webkit内核支持的普通方法，而不是前面图中WebAPIs涉及的方法，所以这里log(‘start’)方法立即出栈被引擎执行。<br>　　2、引擎继续往下，将setTimeout(callback,200)添加到执行栈。setTimeout()方法属于事件循环模型中WebAPIs中的方法，引擎在将setTimeout()方法出栈执行时，将延时执行的函数交给了相应模块，即图右方的timer模块来处理。<br>　　3、然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’，<br>　　4、执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束,程序处理完毕，main()方法也出栈。<br>　　5、在这里再次强调一下，不是setTimeout加入了事件队列，而是setTimeout里面的回调函数加入了事件队列</p>\n<h2 id=\"4、setTimeout问题的解答\"><a href=\"#4、setTimeout问题的解答\" class=\"headerlink\" title=\"4、setTimeout问题的解答\"></a>4、setTimeout问题的解答</h2><hr>\n<p>回到我们文章之初的那倒题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>如果理解了上面的内容，那么这道题理解起来就比较容易了。<br>　　首先是打印出 1，然后是10000个4，那么Time1、Time2、Time3是顺序是如何的呢？<br>　　在这个代码中，for循环比较耗时，在Time1和Timer加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Time1和Time2并不会得以执行。当for循环结束，这时才将Time3交由Timer模块去管理，清空执行栈。虽然在这里Time3的延迟时间最短，但是加入任务队列后还是会排在Time1和Time2的后面，所以此时按顺序执行任务队列中的代码，依次打印2、3、5。<br>所以执行结果为：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170226131730320-9660993.jpg\" alt=\"\"></p>\n<h2 id=\"5、关于setTimeout新的问题\"><a href=\"#5、关于setTimeout新的问题\" class=\"headerlink\" title=\"5、关于setTimeout新的问题\"></a>5、关于setTimeout新的问题</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure>\n<p>　　上面这个问题中，Time3加入任务队列的时间比Time2,Time1晚，所以它是最后才执行的。那么问题来了，请看下面代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">10000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//Time3</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>);</div><div class=\"line\">&#125;,<span class=\"number\">100</span>);</div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;&ensp;&ensp;我们将Time1和Time2的顺序对换一下，按照前面的说法，Time2先加入任务队列，然后是Time1，再然后是Time3。可是执行的结果还是1、4、2、3、5，这是为什么呢？虽然Time1的执行时间短，可是它比Time2晚加入任务队列啊。<br>&ensp;&ensp;&ensp;&ensp;为了验证这个问题，我们可以提出这样的一个假设：<br><code>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大</code></p>\n<p>可能假设听起来比较拗口，我们可以用代码来理解一下：</p>\n<p><strong>代码1：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">5000</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure>\n<p>Time1比Time2设定的执行时间早100ms，但是Time2先加入任务队列，在Time2和Time1时间有一个阻塞的for循环，执行结果如下：</p>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227132406766-1770219106.png\" alt=\"\"></p>\n<p>Time2先执行；</p>\n<p><strong>代码2：</strong><br>我们把for循环里面的时间设置短一点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">400</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">500</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure>\n<p><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227132754095-1066713665.png\" alt=\"\"></p>\n<p>此时，Time1先执行，因为阻塞的耗时小于Time1和Time2的执行间隔时间100毫秒；<br /></p>\n<p><strong>代码3：</strong><br>我们再来验证一下，把Time2的执行时间设为350毫秒；<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//Time2</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</div><div class=\"line\">&#125;,<span class=\"number\">350</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> start=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">500</span>;i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这里只是模拟一个耗时操作'</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> end=<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'阻塞耗时：'</span>+<span class=\"built_in\">Number</span>(end-start)+<span class=\"string\">'毫秒'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Time1</span></div><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</div><div class=\"line\">&#125;,<span class=\"number\">300</span>);</div></pre></td></tr></table></figure></p>\n<p>直接结果为：<br><img src=\"//images2015.cnblogs.com/blog/776370/201702/776370-20170227133015141-186210832.png\" alt=\"\"><br>Time2先执行，因为阻塞的时间大于两个setTimeout之间的间隔时间。</p>\n<p>　　通过上面的假设，我们可以得出这样一个结论：<strong>如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p> 　　理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，知道事件的走向，才能更好的驾驭Javascript。本文是对事件循环的一个小小总结，更多的干货，可以看看下面的参考文档。本文有误之处，欢迎指出<br /><br /></p>\n<p>参考文档：</p>\n<p><a href=\"//www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/\">【转向Javascript系列】从setTimeout说事件循环模型</a><br><a href=\"//www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a><br><a href=\"https://segmentfault.com/a/1190000004322358\">JavaScript：彻底理解同步、异步和事件循环(Event Loop)</a></p>"},{"title":"正则表达式学习","date":"2017-05-30T01:04:00.000Z","_content":"\n&ensp;&ensp;&ensp;&ensp;正则表达式之前学习的时候，因为很久没怎么用，或者用的时候直接找网上现成的，所以都基本忘的差不多了。所以这篇文章即是笔记，也让自己再重新学习一遍正则表达式。\n&ensp;&ensp;&ensp;&ensp;其实平时在操作一些字符串的时候，用正则的机会还是挺多的，之前没怎么重视正则，这是一个错误。写完这篇文章后，发觉工作中很多地方都可以用到正则，而且用起来其实还是挺爽的。\n\n<!--more-->\n\n## 正则表达式作用\n&ensp;&ensp;&ensp;&ensp;正则表达式，又称规则表达式，它可以通过一些设定的规则来匹配一些字符串，是一个强大的`字符串`匹配工具。\n\n## 正则表达式方法\n\n#### 基本语法，正则声明\njs中，正则的声明有两种方式\n1. 直接量语法：\n```javascript  \n var reg = /d+/g/\n```\n2. 创建RegExp对象的语法\n```javascript  \nvar reg = new RegExp(\"\\\\d+\", \"g\");\n```\n这两种声明方式其实还是有区别的，平时的话我比较喜欢第一种，方便一点，如果需要给正则表达式传递参数的话，那么只能用第二种创建RegExp的形式\n格式：`var pattern = new RegExp('regexp','modifier')`;\n`regexp`： 匹配的模式，也就是上文指的正则规则。\n`modifier`: 正则实例的修饰符,可选值有：\ni : 表示区分大小写字母匹配。\nm ：表示多行匹配。\ng : 表示全局匹配。\n\n传参的形式如下：\n我们用构造函数来生成正则表达式\n```javascript\nvar re = new RegExp(\"^\\\\d+$\",\"gim\");\n```\n这里需要注意，反斜杠需要转义，所以，直接声明量中的语法为`\\d`，这里需要为 `\\\\d`\n那么，给它加变量，就和我们前面写的给字符串加变量一样了。\n```javascript\nvar v = \"bl\";\nvar re =new RegExp(\"^\\\\d+\" + v + \"$\",\"gim\");  // re为/^\\d+bl$/gim\n```\n<br />\n\n#### 支持正则的String对象方法\n1. search 方法\n** 作用： ** 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串\n** 基本语法：** `stringObject.search(regexp);`\n** 返回值：** 该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1；\n** 注意点：** search()方法不执行全局匹配，它将忽略标志g，\n```javascript\nvar str = \"hello world,hello world\";\n// 返回匹配到的第一个位置(使用的regexp对象检索)\nconsole.log(str.search(/hello/)); // 0\n// 没有全局的概念 总是返回匹配到的第一个位置\nconsole.log(str.search(/hello/g)); //0\n\nconsole.log(str.search(/world/)); // 6\n\n// 如果没有检索到的话，则返回-1\nconsole.log(str.search(/longen/)); // -1\n\n// 我们检索的时候 可以忽略大小写来检索\nvar str2 = \"Hello\";\nconsole.log(str2.search(/hello/i)); // 0\n```\n<br />\n2. match()方法\n** 作用：** 该方法用于在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。类似于indexOf()或者lastIndexOf();\n** 基本语法：** `stringObject.match(searchValue) 或者stringObject.match(regexp)`\n** 返回值：**\n&ensp;&ensp;存放匹配成功的数组; 它可以全局匹配模式，全局匹配的话，它返回的是一个数组。如果没有找到任何的一个匹配，那么它将返回的是null；\n&ensp;&ensp;返回的数组内有三个元素，第一个元素的存放的是匹配的文本，还有二个对象属性\n&ensp;&ensp;index属性表明的是匹配文本的起始字符在stringObject中的位置，input属性声明的是对stringObject对象的引用\n```javascript\nvar str = \"hello world\";\nconsole.log(str.match(\"hello\")); // [\"hello\", index: 0, input: \"hello world\"]\nconsole.log(str.match(\"Helloy\")); // null\nconsole.log(str.match(/hello/)); // [\"hello\", index: 0, input: \"hello world\"]\n// 全局匹配\nvar str2=\"1 plus 2 equal 3\"\nconsole.log(str2.match(/\\d+/g)); //[\"1\", \"2\", \"3\"]\n```\n<br />\n3. replace()方法\n** 作用：** 该方法用于在字符串中使用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子字符串；\n** 基本用法：** `stringObject.replace(regexp/substr,replacement);`\n** 返回值：** 返回替换后的新字符串\n** 注意：** 字符串的stringObject的replace()方法执行的是查找和替换操作，替换的模式有2种，既可以是字符串，也可以是正则匹配模式，如果是正则匹配模式的话，那么它可以加修饰符g,代表全局替换，否则的话，它只替换第一个匹配的字符串；\n\n* &ensp;&ensp;replacement 既可以是字符串，也可以是函数，如果它是字符串的话，那么匹配的将与字符串替换，replacement中的$有具体的含义，如下：\n* &ensp;&ensp;$1,$2,$3....$99 含义是：与regexp中的第1到第99个子表达式相匹配的文本。可以看下面的例子\n* &ensp;&ensp;$& 的含义是：与RegExp相匹配的子字符串。\n* &ensp;&ensp;lastMatch或RegExp[\"$_\"]的含义是：返回任何正则表达式搜索过程中的最后匹配的字符。\n* &ensp;&ensp;lastParen或 RegExp[\"$+\"]的含义是：返回任何正则表达式查找过程中最后括号的子匹配。\n* &ensp;&ensp;leftContext或RegExp[\"$`\"]的含义是：返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。\n* &ensp;&ensp;rightContext或RegExp[\"$'\"]的含义是：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。\n\n```javascript\nvar str = \"hello world\";\n// 替换字符串\nvar s1 = str.replace(\"hello\",\"a\");\nconsole.log(s1);// a world\n// 使用正则替换字符串\nvar s2 = str.replace(/hello/,\"b\");\nconsole.log(s2); // b world\n\n// 使用正则全局替换 字符串\nvar s3 = str.replace(/l/g,'');\nconsole.log(s3); // heo word\n\n// $1,$2 代表的是第一个和第二个子表达式相匹配的文本\n// 子表达式需要使用小括号括起来,代表的含义是分组\nvar name = \"longen,yunxi\";\nvar s4 = name.replace(/(\\w+)\\s*,\\s*(\\w+)/,\"$2 $1\");\nconsole.log(s4); // \"yunxi,longen\"\n\nvar str = '123-mm';\nvar strReg = str.replace(/(\\d+)-([A-Za-z]+)/g,'$2');\nconsole.log(strReg)//mm  上面那段$2这个就是表示正则第二组个匹配到的内容,也就是说$1,$2.. 表示的是第几个括号匹配到的内容\n\n// $& 是与RegExp相匹配的子字符串\nvar name = \"hello I am a chinese people\";\nvar regexp = /am/g;\nif(regexp.test(name)) {\n  //返回正则表达式匹配项的字符串\n  console.log(RegExp['$&']);  // am\n\n  //返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。\n  console.log(RegExp[\"$'\"]); // a chinese people\n\n  //返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。\n  console.log(RegExp['$`']);  // hello I\n\n  // 返回任何正则表达式查找过程中最后括号的子匹配。\n  console.log(RegExp['$+']); // 空字符串\n\n  //返回任何正则表达式搜索过程中的最后匹配的字符。\n  console.log(RegExp['$_']);  // hello I am a chinese people\n}\n\n// replace 第二个参数也可以是一个function 函数\nvar name2 = \"123sdasadsr44565dffghg987gff33234\";\nname2.replace(/\\d+/g,function(v){\n  console.log(v);\n   // 第一次打印123\n   // 第二次打印44565\n   // 第三次打印987\n   // 第四次打印 33234\n});\n```\n\n#### RegExp对象方法\n 1. test()方法\n** 作用：** 该方法用于检测一个字符串是否匹配某个模式；\n** 基本语法：** `RegExpObject.test(str);`\n** 返回：** 返回true，否则返回false；\n```javascript\nvar str = \"longen and yunxi\";\nconsole.log(/longen/.test(str)); // true\nconsole.log(/longlong/.test(str)); //false\n\n// 或者创建RegExp对象模式\nvar regexp = new RegExp(\"longen\");\nconsole.log(regexp.test(str)); // true\n```\n<br />\n 2. exec()方法\n ** 作用：** 该方法用于检索字符串中的正则表达式的匹配\n ** 基本语法：** `RegExpObject.exec(string)`\n ** 返回值：** 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null；\n ** 注意点：** 该返回的数组的第一个元素是与正则表达式相匹配的文本\n该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的。\n```javascript\nvar str = \"longen and yunxi\";\nconsole.log(/longen/.exec(str));\n// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]\n\n// 假如没有找到的话，则返回null\nconsole.log(/wo/.exec(str)); // null\n```\n\n\n## 正则表达式类型\n#### 元字符\n用于构建正则表达式的符号，常用的有\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| .        | 查找任意的单个字符，除换行符外      |   \n| \\w        | 任意一个字母或数字或下划线，A_Za_Z0_9,_中任意一个       |   \n| \\W        | 查找非单词的字符，等价于[^A_Za_z0_9_       |   \n| \\d         | 匹配一个数字字符，等价于[0-9]       |   \n| \\D       | 匹配一个非数字字符，等价于[^0-9]       |   \n| \\s       | 匹配任何空白字符，包括空格，制表符，换行符等等。等价于[\\f\\n\\r\\t\\v]       |   \n| \\S       | 匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]       |   \n| \\b       | 匹配一个单词边界，也就是指单词和空格间的位置，比如’er\\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er”      |   \n| \\B       | 匹配非单词边界,’er\\B’能匹配’verb’中的’er’,但不能匹配’never’中的’er’     |   \n| \\0        | 匹配非单词边界,’er\\查找NUL字符。    |   \n| \\n        | 匹配一个换行符    |   \n| \\f        | 匹配一个换页符    |   \n| \\r       | 匹配一个回车符    |   \n| \\t       | 匹配一个制表符    |   \n| \\v        | 匹配一个垂直制表符    |   \n| \\xxx        | 查找一个以八进制数xxx规定的字符    |   \n| \\xdd        | 查找以16进制数dd规定的字符    |   \n| \\uxxxx        | 查找以16进制数的xxxx规定的Unicode字符。    |   \n\n其实常用的几个可以简单记为下面的几个意思:\n\\s : 空格\n\\S : 非空格\n\\d : 数字\n\\D : 非数字\n\\w : 字符 ( 字母 ，数字，下划线_ )\n\\W : 非字符例子：是否有不是数字的字符\n\n##### 量词\n用于限定子模式出现在正则表达式的次数。\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| +       | 匹配一次或多次，相当于{1,}     |   \n| *        | 匹配零次或多次 ，相当于{0,}   |   \n| ?        | 匹配零次或一次 ，相当于{0,1}    |   \n| {n}   | 匹配n次     |   \n| {n,m}     | 匹配至少n个，最多m个某某的字符串      |   \n| {n,}     | 匹配至少n个某字符串   |   \n\n\n#### 位置符号\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| $     | 结束符号，例子：n$，匹配以n结尾的字符串  |   \n| ^    | 起始符号,例如^n,匹配以n开头的字符串  |   \n| ?=    | 肯定正向环视,例：?=n,匹配其后紧接指定的n字符串  |   \n| ?!    | 否定正向环视,例如：?!n,匹配其后没有紧接指定的n字符串  |\n| ?:    | 表示不匹配  |\n\n** 注意点： **  \n&ensp;&ensp;刚开始学习正则的时候，是比较容易混淆 `^` : 放在正则的最开始位置，就代表起始的意思,放在中括号里，表示排除的意思。也就是说，/[^a]/和/^[a]/是不一样的，前者是排除的意思，后者是代表首位\n&ensp;&ensp;$:正则的最后位置,就代表结束的意思.\n\n#### 分组\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| 竖线 | 选择(不是他就是她)  |   \n| (…)    | 分组  |   \n\n#### 字符类\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| [0-9] | 匹配 0 到 9 间的字符  |   \n| [a-zA-Z]    | 匹配任意字母  |\n| [^0-9]    | 不等于0到9的其它字符  |\n\n&ensp;&ensp;()分组符号可以理解为，数学运算中的括号，用于计算的分组使用。[]可以理解为，只要满足括号里面其中的某种条件即可。比如[abc],意思是满足abc中的某一个，这样比较好记。\n\n## 贪婪模式和非贪婪模式\n&ensp;&ensp;其实可以简单的理解，贪婪模式就是尽可能多的匹配，非贪婪模式就是尽可能少的匹配.\n** 贪婪模式量词：** `{x,y} ,  {x,} ,  ? ,  * , 和  +`\n** 非贪婪模式量词：** `{x,y}?，{x,}?，??，*?，和 +?`,所以非贪婪模式就是在贪婪模式后面加了一个问号\n\n我们用代码来理解一下贪婪模式和非贪婪模式的区别\n```javascript\nvar str = \"<p>这是第一段文本</p>text1<p>这是第二段文本</p>text2<p>xxx</p>text2again<p>end</p>\";\n// 非贪婪模式1\nconsole.log(str.match(/<p>.*?<\\/p>text2/)[0]); // <p>这是第一段文本</p>text1<p>这是第二段文本</p>text2\n\n// 贪婪模式\nconsole.log(str.match(/<p>.*<\\/p>text2/)[0]); // <p>这是第一段文本</p>text1<p>这是第二段文本</p>text2<p>xxx</p>text2\n\n```\n&ensp;&ensp;从上面的代码中，我们可以看到，非贪婪模式，当它匹配到它需要的第一个满足条件之后，他就会停止了。而贪婪模式则会继续向右边进行匹配下去。\n注意点：?号在一些量词后面才是指非贪婪模式，如果直接在一些字符串的后面，表示的是匹配0次或1次。如下所示\n```javascript\nvar str = 'abced';\nconsole.log(str.match(/ce?/g)); // [\"ce\"]\nconsole.log(reg.match(/cf?/g)); // [\"c\"]\n```\n## 零宽正向断言和负向断言\n* `(?=)`零宽正向断言: 括号内表示某个位置右边必须和=右边匹配上\n* `(?!)`负向断言: 括号内表示某个位置右边不和!后的字符匹配。\n概念很抽象，直接看代码：\n```javascript\nvar pattern=/str(?=ings)ing/;\n// 表示匹配 r 后面必须有ings的 string字符\nconsole.log(\"strings.a\".match(pattern)); //[\"string\", index: 0, input: \"strings.a\"]\n\n// 同理，匹配string后面必须有s的 string 字符串\nconsole.log(\"strings.a\".match(/string(?=s)/)); //[\"string\", index: 0, input: \"strings.a\"]\nconsole.log(\"string_x\".match(pattern)); // null\nconsole.log(\"string_x\".match(/string(?=s)/)); // null\n\n```\n如果理解了(?=),那么(?!)就很好理解了\n```javascript\nvar pattern=/string(?!s)/; // 匹配string后面不带s的string字符串\nconsole.log(\"strings\".match(pattern)); //null\nconsole.log(\"string.\".match(pattern)); //[\"string\", index: 0, input: \"string.\"]\n```\n\n## 正则表达式实战练习\n&ensp;&ensp;上面讲的基本都是理论，下面我们来实战一番，以此来巩固我们正则表达式的学习，学习的过程以demo的形式，对我们的知识点进行巩固。\n&ensp;&ensp;下面的实例是参考这篇文章，有兴趣可以看 [原文](http://blog.csdn.net/Mark_LQ/article/details/48999627?locationNum=2&fps=1),不过我整理了一下，个人觉得，把下面的例子都实践一遍，那么就基本掌握正则的使用了，满足平时的工作基本够了。\n\n** demo1: **\n要求：匹配结尾的数字，例如：取出字符串最后一组数字，如：30CACDVB0040 取出40\n分析：匹配数组字符为\\d,匹配1次或多次为 +，以什么结尾为 $,全局匹配为 g\n结果：\n```javascript\nconsole.log('30CACDVB0040'.match(/\\d+$/g)); // [\"0040\"]\n```\n如果我们只想要最后结尾的最后两个数字，则可以使用量词 {n,m},所以结果为：\n```javascript\nconsole.log('30CACDVB0040'.match(/\\d{1,2}$/g)); // [\"40\"]\n```\n\n** demo2: **\n要求:统一空格个数,例如：字符串内字符键有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。\n分析： 匹配空格的字符为 \\s\n结果：\n```javascript\nvar str ='学 习  正    则';\nconsole.log(str.replace(/\\s+/g,' ')); // 学 习 正 则\n```\n\n** demo3: **\n要求：判断字符串是不是由数字组成\n分析：我们可以这样匹配，以数字 \\d 开头^,以数字结尾 $,匹配零次或多次 *\n结果：\n```javascript\nvar str ='学 习  正    则';\nconsole.log(/^\\d*$/g.test('123789'));  // true\nconsole.log(/^\\d*$/g.test('12378b9')); // false\n```\n\n** demo4: **\n要求：验证是否为手机号\n分析：现在手机开头的范围比较多，第一位是【1】开头，第二位则则有【3,4,5,7,8】，第三位则是【0-9】并且匹配9个数字。\n结果：\n```javascript\nvar reg = /^1[3|4|5|7|8][0-9]{9}$/; //验证规则\nconsole.log(reg.test(15984591578)); //true\nconsole.log(reg.test(11984591578)); //false\n```\n\n** demo5: **\n要求：删除字符串两端的空格\n分析：跟demo2类似，匹配空格 ^\\s开头，空格结尾 \\s$\n结果：\n```javascript\nvar str = ' 学习正则  ';\nconsole.log(str.replace(/^\\s+|\\s+$/,''));  // 学习正则  \n```\n\n** demo6: **\n要求：只能输入数字和小数点\n分析：开头需要匹配为数字，结尾也应为数字，然后再加个点,点必须转义，匹配0次或一次\n结果：\n```javascript\nvar reg =/^\\d*\\.?\\d{0,2}$/;\nconsole.log(reg.test('125.1')); // true\nconsole.log(reg.test('125a')); // false\n```\n\n** demo7: **\n要求：只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./\\)\n分析：这几个要求组成一个分组，把他们放在一个分组里,点，正反斜杠，冒号需要转义\n结果：\n```javascript\nvar reg = /[a-z\\.\\/\\\\:]+/;\nconsole.log('79abncdc.ab123'.match(reg)); // [\"abncdc.ab\", index: 2, input: \"79abncdc.ab123\"]\n```\n\n** demo8: **\n要求：去掉所有的html标签\n分析：html标签的形式为<ul></ul>,所以我们可以匹配<开始，然后一些内容，再加上结束符 >\n结果：\n```javascript\nvar reg = /<[^>]+>/gi;\nvar str = '<ul><li>hello world</li></ul>';\nconsole.log(str.replace(reg,'')); // hello world\n```\n\n** demo9: **\n要求：绝对路径变相对路径\n分析： 比如: `<img src=\"http://m.163.com/images/163.gif\" />` 替换成 `<img src=\"/images/163.gif\" />`.\n我们要替换http:// 和后面的域名，第一个 / 为止，\n结果：\n```javascript\nvar reg = /http:\\/\\/[^\\/]+/g;\nvar str = 'http://m.163.com/images/163.gif';\nconsole.log(str.replace(reg,'')); // /images/163.gif\n```\n\n** demo10: **\n要求：用于用户名注册，户名只能用中文、英文、数字、下划线、4-16个字符。\n分析： 匹配中文的正则为 ` /[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/`,英文，数字的元字符为 \\w,量词 {4,16}\n结果：\n``` javascript\nvar reg = /^/[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]{4,16}$/;\nvar str1 = 'hellow_1230';\nvar str2 = 'hellow_1230*';\nvar str3 = 'hellow_12304549764654657456465756';\nconsole.log(reg.test(str1)); // true\nconsole.log(reg.test(str2)); //false\nconsole.log(reg.test(str3)); // false\n```\n\n** demo11 : **\n要求：匹配身份证号\n分析：身份证为15为或者18位，最后一位为数字或者x\n结果：\n```javascript\nvar reg = /^(\\d{14}|\\d{17})(\\d|[xX])$/;\nvar str = '44162119920547892X';\nconsole.log(reg.test(str));  // true\n```\n\n** demo12: **\n要求：验证邮箱\n分析：邮箱的形式可能为 234564@qq.com; fasdfja@163.com，可以看到，前面为字母或者数字，然后加@,@后面可能是数字或者是其他，然后再加 . 再然后是一些com或者其他字符，我们用()来进行分组；\n结果：\n```javascript\nvar reg = /^([\\w_-])+@([\\w_-])+([\\.\\w_-])+/;\nvar str1 = 'test@hotmail.com';\nvar str2 = 'test@sima.vip.com';\nvar str3 = 'te-st@qq.com.cn';  \nvar str4 = 'te_st@sima.vip.com';\nvar str5 = 'te.._st@sima.vip.com';\nconsole.log(reg.test(str1)); // true\nconsole.log(reg.test(str2)); // true\nconsole.log(reg.test(str3)); // true\nconsole.log(reg.test(str4)); // true\nconsole.log(reg.test(str5)); // false\n```\n\n** demo13: **\n要求：匹配源代码中的链接\n分析：a标签中有href，也可能有class ,id等其他属性，而且不确定a标签后面是否有空格，所以要考虑的东西比较多。\n结果：\n```javascript\nvar reg = /<a\\s(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*href\\s*=\\s*\".+?\")(\\s*\\w*?\\s*=\\s*\".+?\")*\\s*>[\\s\\S]*?<\\/a>/g;\nvar str = '<p>测试链接：<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a></p>';\nconsole.log(str.match(reg));  // [\"<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a>\"]\n```\n\n** demo14: **\n要求：匹配a标签里面的内容\n分析：上面的demo中，我们匹配到了a标签，这里的话我们匹配a标签里面的内容，这里要学习一个符号`?:`表示不匹配，所以我们在前面的括号中加上`?:`去掉a标签的匹配，然后再a标签内容里加个括号，表示分组。\n结果：\n```javascript\nvar reg =/<a\\s(?:\\s*\\w*?\\s*=\\s*\".+?\")*(?:\\s*href\\s*=\\s*\".+?\")(?:\\s*\\w*?\\s*=\\s*\".+?\")*\\s*>([\\s\\S]*?)<\\/a>/;;\nvar str = '<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a>';\nconsole.log(str.replace(reg,'$1'));  // 经典论坛    $1 表示的是括号里面的分组，由于前面的括号都是不获取，所以获取的第一个括号的内容就是a标签里面的内容\n```\n\n** demo15： **\n要求：获取url的指定参数的值\n分析： url带参数类似为这样：http://www.baicu.com?type=1&value=789; 所以，要获取的参数要么是在?或者&开头，到下一个&或者直接后面什么都不跟为止。这里我们用new RegExp的形式，因为这样可以传参。\n结果：\n```javascript\n// 获取url中的value值\nvar url = 'http://www.baicu.com?type=1&value=789';\nvar reg = new RegExp(\"(^|&|\\\\?)value=([^&]*)(&|$)\");\nconsole.log(url.match(reg)); //[\"&value=789\", \"&\", \"789\", \"\", index: 27, input: \"http://www.baicu.com?type=1&value=789\"]\n}\n```\n稍微改编一下，我们就可以弄一个获取指定参数值的函数了\n```javascript\nfunction getUrlParam(name) {\n  var reg = new RegExp(\"(^|&|\\\\?)\" + name + \"=([^&]*)(&|$)\");\n  var r = window.location.search.substr(1).match(reg);\n  if (r != null) return decodeURIComponent(r[2]);\n  return null;\n}\n```\n\n** demo16: **\n要求：将数字 15476465转变为15,476,465\n分析：我们可以这样，匹配一个数字，然后它的后面紧跟着三个数字，并且结尾也是要有三个数字，比如 12345689我们找到 1`2` 34`5` 689,符合条件的是数字2和5，因为它后面紧跟着三个数字，并且这样结尾也是三个数字。然后我们在2和5的后面加个`,`,就达到了我们的目的12,345,689;\n知识补充：这里我们需要介绍正则的一个知识点，断言`?=`,它只匹配一个位置。假如匹配一个“人”字，但是你只想匹配中国人的人字，不想匹配法国人的人`(?=中国)人`;\n结果：\n```javascript\nvar str = '15476465';\nvar reg =/(\\d)(?=(\\d{3})+$)/g;\nconsole.log(str.replace(reg,'$1,')); //15,476,465\n```\n进一步讲解：/(\\d)(?=(\\d{3})+$)/匹配的是一个数字，即(\\d),\n它后面的字符串必须是三的倍数，这个表达就是(?=(\\d{3})+$),且最后一次匹配以 3 个数字结尾\n$1,表示在第一个分组表达式匹配的字符后面加,，这里其实只有一个(\\d)，问号后面的可以看成它的定语。/(\\d)(?=(\\d{3})+$)/g\n这个表达式通俗来说是：要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加,\n\n** demo17： **\n要求：将阿拉伯数字替换为中文大写形式\n分析：我们可以用replace来弄这个，replace中的function可以获取到匹配的每一个内容，比如返回匹配数字188，那么就会依次返回1,8,8\n结果：\n```javascript\nvar reg = /\\d/g;\nvar arr=new Array(\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\");\nvar str = '189454';\nconsole.log(str.replace(reg,function(m) {\n  return arr[m];  //壹捌玖肆伍肆\n}));\n```\n","source":"_posts/正则表达式学习.md","raw":"---\ntitle: 正则表达式学习\ndate: 2017-05-30 09:04\ncategories:\ntags:\n     - 正则\n---\n\n&ensp;&ensp;&ensp;&ensp;正则表达式之前学习的时候，因为很久没怎么用，或者用的时候直接找网上现成的，所以都基本忘的差不多了。所以这篇文章即是笔记，也让自己再重新学习一遍正则表达式。\n&ensp;&ensp;&ensp;&ensp;其实平时在操作一些字符串的时候，用正则的机会还是挺多的，之前没怎么重视正则，这是一个错误。写完这篇文章后，发觉工作中很多地方都可以用到正则，而且用起来其实还是挺爽的。\n\n<!--more-->\n\n## 正则表达式作用\n&ensp;&ensp;&ensp;&ensp;正则表达式，又称规则表达式，它可以通过一些设定的规则来匹配一些字符串，是一个强大的`字符串`匹配工具。\n\n## 正则表达式方法\n\n#### 基本语法，正则声明\njs中，正则的声明有两种方式\n1. 直接量语法：\n```javascript  \n var reg = /d+/g/\n```\n2. 创建RegExp对象的语法\n```javascript  \nvar reg = new RegExp(\"\\\\d+\", \"g\");\n```\n这两种声明方式其实还是有区别的，平时的话我比较喜欢第一种，方便一点，如果需要给正则表达式传递参数的话，那么只能用第二种创建RegExp的形式\n格式：`var pattern = new RegExp('regexp','modifier')`;\n`regexp`： 匹配的模式，也就是上文指的正则规则。\n`modifier`: 正则实例的修饰符,可选值有：\ni : 表示区分大小写字母匹配。\nm ：表示多行匹配。\ng : 表示全局匹配。\n\n传参的形式如下：\n我们用构造函数来生成正则表达式\n```javascript\nvar re = new RegExp(\"^\\\\d+$\",\"gim\");\n```\n这里需要注意，反斜杠需要转义，所以，直接声明量中的语法为`\\d`，这里需要为 `\\\\d`\n那么，给它加变量，就和我们前面写的给字符串加变量一样了。\n```javascript\nvar v = \"bl\";\nvar re =new RegExp(\"^\\\\d+\" + v + \"$\",\"gim\");  // re为/^\\d+bl$/gim\n```\n<br />\n\n#### 支持正则的String对象方法\n1. search 方法\n** 作用： ** 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串\n** 基本语法：** `stringObject.search(regexp);`\n** 返回值：** 该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1；\n** 注意点：** search()方法不执行全局匹配，它将忽略标志g，\n```javascript\nvar str = \"hello world,hello world\";\n// 返回匹配到的第一个位置(使用的regexp对象检索)\nconsole.log(str.search(/hello/)); // 0\n// 没有全局的概念 总是返回匹配到的第一个位置\nconsole.log(str.search(/hello/g)); //0\n\nconsole.log(str.search(/world/)); // 6\n\n// 如果没有检索到的话，则返回-1\nconsole.log(str.search(/longen/)); // -1\n\n// 我们检索的时候 可以忽略大小写来检索\nvar str2 = \"Hello\";\nconsole.log(str2.search(/hello/i)); // 0\n```\n<br />\n2. match()方法\n** 作用：** 该方法用于在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。类似于indexOf()或者lastIndexOf();\n** 基本语法：** `stringObject.match(searchValue) 或者stringObject.match(regexp)`\n** 返回值：**\n&ensp;&ensp;存放匹配成功的数组; 它可以全局匹配模式，全局匹配的话，它返回的是一个数组。如果没有找到任何的一个匹配，那么它将返回的是null；\n&ensp;&ensp;返回的数组内有三个元素，第一个元素的存放的是匹配的文本，还有二个对象属性\n&ensp;&ensp;index属性表明的是匹配文本的起始字符在stringObject中的位置，input属性声明的是对stringObject对象的引用\n```javascript\nvar str = \"hello world\";\nconsole.log(str.match(\"hello\")); // [\"hello\", index: 0, input: \"hello world\"]\nconsole.log(str.match(\"Helloy\")); // null\nconsole.log(str.match(/hello/)); // [\"hello\", index: 0, input: \"hello world\"]\n// 全局匹配\nvar str2=\"1 plus 2 equal 3\"\nconsole.log(str2.match(/\\d+/g)); //[\"1\", \"2\", \"3\"]\n```\n<br />\n3. replace()方法\n** 作用：** 该方法用于在字符串中使用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子字符串；\n** 基本用法：** `stringObject.replace(regexp/substr,replacement);`\n** 返回值：** 返回替换后的新字符串\n** 注意：** 字符串的stringObject的replace()方法执行的是查找和替换操作，替换的模式有2种，既可以是字符串，也可以是正则匹配模式，如果是正则匹配模式的话，那么它可以加修饰符g,代表全局替换，否则的话，它只替换第一个匹配的字符串；\n\n* &ensp;&ensp;replacement 既可以是字符串，也可以是函数，如果它是字符串的话，那么匹配的将与字符串替换，replacement中的$有具体的含义，如下：\n* &ensp;&ensp;$1,$2,$3....$99 含义是：与regexp中的第1到第99个子表达式相匹配的文本。可以看下面的例子\n* &ensp;&ensp;$& 的含义是：与RegExp相匹配的子字符串。\n* &ensp;&ensp;lastMatch或RegExp[\"$_\"]的含义是：返回任何正则表达式搜索过程中的最后匹配的字符。\n* &ensp;&ensp;lastParen或 RegExp[\"$+\"]的含义是：返回任何正则表达式查找过程中最后括号的子匹配。\n* &ensp;&ensp;leftContext或RegExp[\"$`\"]的含义是：返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。\n* &ensp;&ensp;rightContext或RegExp[\"$'\"]的含义是：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。\n\n```javascript\nvar str = \"hello world\";\n// 替换字符串\nvar s1 = str.replace(\"hello\",\"a\");\nconsole.log(s1);// a world\n// 使用正则替换字符串\nvar s2 = str.replace(/hello/,\"b\");\nconsole.log(s2); // b world\n\n// 使用正则全局替换 字符串\nvar s3 = str.replace(/l/g,'');\nconsole.log(s3); // heo word\n\n// $1,$2 代表的是第一个和第二个子表达式相匹配的文本\n// 子表达式需要使用小括号括起来,代表的含义是分组\nvar name = \"longen,yunxi\";\nvar s4 = name.replace(/(\\w+)\\s*,\\s*(\\w+)/,\"$2 $1\");\nconsole.log(s4); // \"yunxi,longen\"\n\nvar str = '123-mm';\nvar strReg = str.replace(/(\\d+)-([A-Za-z]+)/g,'$2');\nconsole.log(strReg)//mm  上面那段$2这个就是表示正则第二组个匹配到的内容,也就是说$1,$2.. 表示的是第几个括号匹配到的内容\n\n// $& 是与RegExp相匹配的子字符串\nvar name = \"hello I am a chinese people\";\nvar regexp = /am/g;\nif(regexp.test(name)) {\n  //返回正则表达式匹配项的字符串\n  console.log(RegExp['$&']);  // am\n\n  //返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。\n  console.log(RegExp[\"$'\"]); // a chinese people\n\n  //返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。\n  console.log(RegExp['$`']);  // hello I\n\n  // 返回任何正则表达式查找过程中最后括号的子匹配。\n  console.log(RegExp['$+']); // 空字符串\n\n  //返回任何正则表达式搜索过程中的最后匹配的字符。\n  console.log(RegExp['$_']);  // hello I am a chinese people\n}\n\n// replace 第二个参数也可以是一个function 函数\nvar name2 = \"123sdasadsr44565dffghg987gff33234\";\nname2.replace(/\\d+/g,function(v){\n  console.log(v);\n   // 第一次打印123\n   // 第二次打印44565\n   // 第三次打印987\n   // 第四次打印 33234\n});\n```\n\n#### RegExp对象方法\n 1. test()方法\n** 作用：** 该方法用于检测一个字符串是否匹配某个模式；\n** 基本语法：** `RegExpObject.test(str);`\n** 返回：** 返回true，否则返回false；\n```javascript\nvar str = \"longen and yunxi\";\nconsole.log(/longen/.test(str)); // true\nconsole.log(/longlong/.test(str)); //false\n\n// 或者创建RegExp对象模式\nvar regexp = new RegExp(\"longen\");\nconsole.log(regexp.test(str)); // true\n```\n<br />\n 2. exec()方法\n ** 作用：** 该方法用于检索字符串中的正则表达式的匹配\n ** 基本语法：** `RegExpObject.exec(string)`\n ** 返回值：** 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null；\n ** 注意点：** 该返回的数组的第一个元素是与正则表达式相匹配的文本\n该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的。\n```javascript\nvar str = \"longen and yunxi\";\nconsole.log(/longen/.exec(str));\n// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]\n\n// 假如没有找到的话，则返回null\nconsole.log(/wo/.exec(str)); // null\n```\n\n\n## 正则表达式类型\n#### 元字符\n用于构建正则表达式的符号，常用的有\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| .        | 查找任意的单个字符，除换行符外      |   \n| \\w        | 任意一个字母或数字或下划线，A_Za_Z0_9,_中任意一个       |   \n| \\W        | 查找非单词的字符，等价于[^A_Za_z0_9_       |   \n| \\d         | 匹配一个数字字符，等价于[0-9]       |   \n| \\D       | 匹配一个非数字字符，等价于[^0-9]       |   \n| \\s       | 匹配任何空白字符，包括空格，制表符，换行符等等。等价于[\\f\\n\\r\\t\\v]       |   \n| \\S       | 匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]       |   \n| \\b       | 匹配一个单词边界，也就是指单词和空格间的位置，比如’er\\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er”      |   \n| \\B       | 匹配非单词边界,’er\\B’能匹配’verb’中的’er’,但不能匹配’never’中的’er’     |   \n| \\0        | 匹配非单词边界,’er\\查找NUL字符。    |   \n| \\n        | 匹配一个换行符    |   \n| \\f        | 匹配一个换页符    |   \n| \\r       | 匹配一个回车符    |   \n| \\t       | 匹配一个制表符    |   \n| \\v        | 匹配一个垂直制表符    |   \n| \\xxx        | 查找一个以八进制数xxx规定的字符    |   \n| \\xdd        | 查找以16进制数dd规定的字符    |   \n| \\uxxxx        | 查找以16进制数的xxxx规定的Unicode字符。    |   \n\n其实常用的几个可以简单记为下面的几个意思:\n\\s : 空格\n\\S : 非空格\n\\d : 数字\n\\D : 非数字\n\\w : 字符 ( 字母 ，数字，下划线_ )\n\\W : 非字符例子：是否有不是数字的字符\n\n##### 量词\n用于限定子模式出现在正则表达式的次数。\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| +       | 匹配一次或多次，相当于{1,}     |   \n| *        | 匹配零次或多次 ，相当于{0,}   |   \n| ?        | 匹配零次或一次 ，相当于{0,1}    |   \n| {n}   | 匹配n次     |   \n| {n,m}     | 匹配至少n个，最多m个某某的字符串      |   \n| {n,}     | 匹配至少n个某字符串   |   \n\n\n#### 位置符号\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| $     | 结束符号，例子：n$，匹配以n结尾的字符串  |   \n| ^    | 起始符号,例如^n,匹配以n开头的字符串  |   \n| ?=    | 肯定正向环视,例：?=n,匹配其后紧接指定的n字符串  |   \n| ?!    | 否定正向环视,例如：?!n,匹配其后没有紧接指定的n字符串  |\n| ?:    | 表示不匹配  |\n\n** 注意点： **  \n&ensp;&ensp;刚开始学习正则的时候，是比较容易混淆 `^` : 放在正则的最开始位置，就代表起始的意思,放在中括号里，表示排除的意思。也就是说，/[^a]/和/^[a]/是不一样的，前者是排除的意思，后者是代表首位\n&ensp;&ensp;$:正则的最后位置,就代表结束的意思.\n\n#### 分组\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| 竖线 | 选择(不是他就是她)  |   \n| (…)    | 分组  |   \n\n#### 字符类\n\n| 符号        | 描述    |  \n| --------   | -----  |\n| [0-9] | 匹配 0 到 9 间的字符  |   \n| [a-zA-Z]    | 匹配任意字母  |\n| [^0-9]    | 不等于0到9的其它字符  |\n\n&ensp;&ensp;()分组符号可以理解为，数学运算中的括号，用于计算的分组使用。[]可以理解为，只要满足括号里面其中的某种条件即可。比如[abc],意思是满足abc中的某一个，这样比较好记。\n\n## 贪婪模式和非贪婪模式\n&ensp;&ensp;其实可以简单的理解，贪婪模式就是尽可能多的匹配，非贪婪模式就是尽可能少的匹配.\n** 贪婪模式量词：** `{x,y} ,  {x,} ,  ? ,  * , 和  +`\n** 非贪婪模式量词：** `{x,y}?，{x,}?，??，*?，和 +?`,所以非贪婪模式就是在贪婪模式后面加了一个问号\n\n我们用代码来理解一下贪婪模式和非贪婪模式的区别\n```javascript\nvar str = \"<p>这是第一段文本</p>text1<p>这是第二段文本</p>text2<p>xxx</p>text2again<p>end</p>\";\n// 非贪婪模式1\nconsole.log(str.match(/<p>.*?<\\/p>text2/)[0]); // <p>这是第一段文本</p>text1<p>这是第二段文本</p>text2\n\n// 贪婪模式\nconsole.log(str.match(/<p>.*<\\/p>text2/)[0]); // <p>这是第一段文本</p>text1<p>这是第二段文本</p>text2<p>xxx</p>text2\n\n```\n&ensp;&ensp;从上面的代码中，我们可以看到，非贪婪模式，当它匹配到它需要的第一个满足条件之后，他就会停止了。而贪婪模式则会继续向右边进行匹配下去。\n注意点：?号在一些量词后面才是指非贪婪模式，如果直接在一些字符串的后面，表示的是匹配0次或1次。如下所示\n```javascript\nvar str = 'abced';\nconsole.log(str.match(/ce?/g)); // [\"ce\"]\nconsole.log(reg.match(/cf?/g)); // [\"c\"]\n```\n## 零宽正向断言和负向断言\n* `(?=)`零宽正向断言: 括号内表示某个位置右边必须和=右边匹配上\n* `(?!)`负向断言: 括号内表示某个位置右边不和!后的字符匹配。\n概念很抽象，直接看代码：\n```javascript\nvar pattern=/str(?=ings)ing/;\n// 表示匹配 r 后面必须有ings的 string字符\nconsole.log(\"strings.a\".match(pattern)); //[\"string\", index: 0, input: \"strings.a\"]\n\n// 同理，匹配string后面必须有s的 string 字符串\nconsole.log(\"strings.a\".match(/string(?=s)/)); //[\"string\", index: 0, input: \"strings.a\"]\nconsole.log(\"string_x\".match(pattern)); // null\nconsole.log(\"string_x\".match(/string(?=s)/)); // null\n\n```\n如果理解了(?=),那么(?!)就很好理解了\n```javascript\nvar pattern=/string(?!s)/; // 匹配string后面不带s的string字符串\nconsole.log(\"strings\".match(pattern)); //null\nconsole.log(\"string.\".match(pattern)); //[\"string\", index: 0, input: \"string.\"]\n```\n\n## 正则表达式实战练习\n&ensp;&ensp;上面讲的基本都是理论，下面我们来实战一番，以此来巩固我们正则表达式的学习，学习的过程以demo的形式，对我们的知识点进行巩固。\n&ensp;&ensp;下面的实例是参考这篇文章，有兴趣可以看 [原文](http://blog.csdn.net/Mark_LQ/article/details/48999627?locationNum=2&fps=1),不过我整理了一下，个人觉得，把下面的例子都实践一遍，那么就基本掌握正则的使用了，满足平时的工作基本够了。\n\n** demo1: **\n要求：匹配结尾的数字，例如：取出字符串最后一组数字，如：30CACDVB0040 取出40\n分析：匹配数组字符为\\d,匹配1次或多次为 +，以什么结尾为 $,全局匹配为 g\n结果：\n```javascript\nconsole.log('30CACDVB0040'.match(/\\d+$/g)); // [\"0040\"]\n```\n如果我们只想要最后结尾的最后两个数字，则可以使用量词 {n,m},所以结果为：\n```javascript\nconsole.log('30CACDVB0040'.match(/\\d{1,2}$/g)); // [\"40\"]\n```\n\n** demo2: **\n要求:统一空格个数,例如：字符串内字符键有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。\n分析： 匹配空格的字符为 \\s\n结果：\n```javascript\nvar str ='学 习  正    则';\nconsole.log(str.replace(/\\s+/g,' ')); // 学 习 正 则\n```\n\n** demo3: **\n要求：判断字符串是不是由数字组成\n分析：我们可以这样匹配，以数字 \\d 开头^,以数字结尾 $,匹配零次或多次 *\n结果：\n```javascript\nvar str ='学 习  正    则';\nconsole.log(/^\\d*$/g.test('123789'));  // true\nconsole.log(/^\\d*$/g.test('12378b9')); // false\n```\n\n** demo4: **\n要求：验证是否为手机号\n分析：现在手机开头的范围比较多，第一位是【1】开头，第二位则则有【3,4,5,7,8】，第三位则是【0-9】并且匹配9个数字。\n结果：\n```javascript\nvar reg = /^1[3|4|5|7|8][0-9]{9}$/; //验证规则\nconsole.log(reg.test(15984591578)); //true\nconsole.log(reg.test(11984591578)); //false\n```\n\n** demo5: **\n要求：删除字符串两端的空格\n分析：跟demo2类似，匹配空格 ^\\s开头，空格结尾 \\s$\n结果：\n```javascript\nvar str = ' 学习正则  ';\nconsole.log(str.replace(/^\\s+|\\s+$/,''));  // 学习正则  \n```\n\n** demo6: **\n要求：只能输入数字和小数点\n分析：开头需要匹配为数字，结尾也应为数字，然后再加个点,点必须转义，匹配0次或一次\n结果：\n```javascript\nvar reg =/^\\d*\\.?\\d{0,2}$/;\nconsole.log(reg.test('125.1')); // true\nconsole.log(reg.test('125a')); // false\n```\n\n** demo7: **\n要求：只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./\\)\n分析：这几个要求组成一个分组，把他们放在一个分组里,点，正反斜杠，冒号需要转义\n结果：\n```javascript\nvar reg = /[a-z\\.\\/\\\\:]+/;\nconsole.log('79abncdc.ab123'.match(reg)); // [\"abncdc.ab\", index: 2, input: \"79abncdc.ab123\"]\n```\n\n** demo8: **\n要求：去掉所有的html标签\n分析：html标签的形式为<ul></ul>,所以我们可以匹配<开始，然后一些内容，再加上结束符 >\n结果：\n```javascript\nvar reg = /<[^>]+>/gi;\nvar str = '<ul><li>hello world</li></ul>';\nconsole.log(str.replace(reg,'')); // hello world\n```\n\n** demo9: **\n要求：绝对路径变相对路径\n分析： 比如: `<img src=\"http://m.163.com/images/163.gif\" />` 替换成 `<img src=\"/images/163.gif\" />`.\n我们要替换http:// 和后面的域名，第一个 / 为止，\n结果：\n```javascript\nvar reg = /http:\\/\\/[^\\/]+/g;\nvar str = 'http://m.163.com/images/163.gif';\nconsole.log(str.replace(reg,'')); // /images/163.gif\n```\n\n** demo10: **\n要求：用于用户名注册，户名只能用中文、英文、数字、下划线、4-16个字符。\n分析： 匹配中文的正则为 ` /[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/`,英文，数字的元字符为 \\w,量词 {4,16}\n结果：\n``` javascript\nvar reg = /^/[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]{4,16}$/;\nvar str1 = 'hellow_1230';\nvar str2 = 'hellow_1230*';\nvar str3 = 'hellow_12304549764654657456465756';\nconsole.log(reg.test(str1)); // true\nconsole.log(reg.test(str2)); //false\nconsole.log(reg.test(str3)); // false\n```\n\n** demo11 : **\n要求：匹配身份证号\n分析：身份证为15为或者18位，最后一位为数字或者x\n结果：\n```javascript\nvar reg = /^(\\d{14}|\\d{17})(\\d|[xX])$/;\nvar str = '44162119920547892X';\nconsole.log(reg.test(str));  // true\n```\n\n** demo12: **\n要求：验证邮箱\n分析：邮箱的形式可能为 234564@qq.com; fasdfja@163.com，可以看到，前面为字母或者数字，然后加@,@后面可能是数字或者是其他，然后再加 . 再然后是一些com或者其他字符，我们用()来进行分组；\n结果：\n```javascript\nvar reg = /^([\\w_-])+@([\\w_-])+([\\.\\w_-])+/;\nvar str1 = 'test@hotmail.com';\nvar str2 = 'test@sima.vip.com';\nvar str3 = 'te-st@qq.com.cn';  \nvar str4 = 'te_st@sima.vip.com';\nvar str5 = 'te.._st@sima.vip.com';\nconsole.log(reg.test(str1)); // true\nconsole.log(reg.test(str2)); // true\nconsole.log(reg.test(str3)); // true\nconsole.log(reg.test(str4)); // true\nconsole.log(reg.test(str5)); // false\n```\n\n** demo13: **\n要求：匹配源代码中的链接\n分析：a标签中有href，也可能有class ,id等其他属性，而且不确定a标签后面是否有空格，所以要考虑的东西比较多。\n结果：\n```javascript\nvar reg = /<a\\s(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*href\\s*=\\s*\".+?\")(\\s*\\w*?\\s*=\\s*\".+?\")*\\s*>[\\s\\S]*?<\\/a>/g;\nvar str = '<p>测试链接：<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a></p>';\nconsole.log(str.match(reg));  // [\"<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a>\"]\n```\n\n** demo14: **\n要求：匹配a标签里面的内容\n分析：上面的demo中，我们匹配到了a标签，这里的话我们匹配a标签里面的内容，这里要学习一个符号`?:`表示不匹配，所以我们在前面的括号中加上`?:`去掉a标签的匹配，然后再a标签内容里加个括号，表示分组。\n结果：\n```javascript\nvar reg =/<a\\s(?:\\s*\\w*?\\s*=\\s*\".+?\")*(?:\\s*href\\s*=\\s*\".+?\")(?:\\s*\\w*?\\s*=\\s*\".+?\")*\\s*>([\\s\\S]*?)<\\/a>/;;\nvar str = '<a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\">经典论坛</a>';\nconsole.log(str.replace(reg,'$1'));  // 经典论坛    $1 表示的是括号里面的分组，由于前面的括号都是不获取，所以获取的第一个括号的内容就是a标签里面的内容\n```\n\n** demo15： **\n要求：获取url的指定参数的值\n分析： url带参数类似为这样：http://www.baicu.com?type=1&value=789; 所以，要获取的参数要么是在?或者&开头，到下一个&或者直接后面什么都不跟为止。这里我们用new RegExp的形式，因为这样可以传参。\n结果：\n```javascript\n// 获取url中的value值\nvar url = 'http://www.baicu.com?type=1&value=789';\nvar reg = new RegExp(\"(^|&|\\\\?)value=([^&]*)(&|$)\");\nconsole.log(url.match(reg)); //[\"&value=789\", \"&\", \"789\", \"\", index: 27, input: \"http://www.baicu.com?type=1&value=789\"]\n}\n```\n稍微改编一下，我们就可以弄一个获取指定参数值的函数了\n```javascript\nfunction getUrlParam(name) {\n  var reg = new RegExp(\"(^|&|\\\\?)\" + name + \"=([^&]*)(&|$)\");\n  var r = window.location.search.substr(1).match(reg);\n  if (r != null) return decodeURIComponent(r[2]);\n  return null;\n}\n```\n\n** demo16: **\n要求：将数字 15476465转变为15,476,465\n分析：我们可以这样，匹配一个数字，然后它的后面紧跟着三个数字，并且结尾也是要有三个数字，比如 12345689我们找到 1`2` 34`5` 689,符合条件的是数字2和5，因为它后面紧跟着三个数字，并且这样结尾也是三个数字。然后我们在2和5的后面加个`,`,就达到了我们的目的12,345,689;\n知识补充：这里我们需要介绍正则的一个知识点，断言`?=`,它只匹配一个位置。假如匹配一个“人”字，但是你只想匹配中国人的人字，不想匹配法国人的人`(?=中国)人`;\n结果：\n```javascript\nvar str = '15476465';\nvar reg =/(\\d)(?=(\\d{3})+$)/g;\nconsole.log(str.replace(reg,'$1,')); //15,476,465\n```\n进一步讲解：/(\\d)(?=(\\d{3})+$)/匹配的是一个数字，即(\\d),\n它后面的字符串必须是三的倍数，这个表达就是(?=(\\d{3})+$),且最后一次匹配以 3 个数字结尾\n$1,表示在第一个分组表达式匹配的字符后面加,，这里其实只有一个(\\d)，问号后面的可以看成它的定语。/(\\d)(?=(\\d{3})+$)/g\n这个表达式通俗来说是：要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加,\n\n** demo17： **\n要求：将阿拉伯数字替换为中文大写形式\n分析：我们可以用replace来弄这个，replace中的function可以获取到匹配的每一个内容，比如返回匹配数字188，那么就会依次返回1,8,8\n结果：\n```javascript\nvar reg = /\\d/g;\nvar arr=new Array(\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\");\nvar str = '189454';\nconsole.log(str.replace(reg,function(m) {\n  return arr[m];  //壹捌玖肆伍肆\n}));\n```\n","slug":"正则表达式学习","published":1,"updated":"2017-06-12T14:13:39.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5b4gr9b000s9gscmj52fjiw","content":"<p>&ensp;&ensp;&ensp;&ensp;正则表达式之前学习的时候，因为很久没怎么用，或者用的时候直接找网上现成的，所以都基本忘的差不多了。所以这篇文章即是笔记，也让自己再重新学习一遍正则表达式。<br>&ensp;&ensp;&ensp;&ensp;其实平时在操作一些字符串的时候，用正则的机会还是挺多的，之前没怎么重视正则，这是一个错误。写完这篇文章后，发觉工作中很多地方都可以用到正则，而且用起来其实还是挺爽的。</p>\n<a id=\"more\"></a>\n<h2 id=\"正则表达式作用\"><a href=\"#正则表达式作用\" class=\"headerlink\" title=\"正则表达式作用\"></a>正则表达式作用</h2><p>&ensp;&ensp;&ensp;&ensp;正则表达式，又称规则表达式，它可以通过一些设定的规则来匹配一些字符串，是一个强大的<code>字符串</code>匹配工具。</p>\n<h2 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h2><h4 id=\"基本语法，正则声明\"><a href=\"#基本语法，正则声明\" class=\"headerlink\" title=\"基本语法，正则声明\"></a>基本语法，正则声明</h4><p>js中，正则的声明有两种方式</p>\n<ol>\n<li><p>直接量语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/d+/g</span><span class=\"regexp\">/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>创建RegExp对象的语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"\\\\d+\"</span>, <span class=\"string\">\"g\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这两种声明方式其实还是有区别的，平时的话我比较喜欢第一种，方便一点，如果需要给正则表达式传递参数的话，那么只能用第二种创建RegExp的形式<br>格式：<code>var pattern = new RegExp(&#39;regexp&#39;,&#39;modifier&#39;)</code>;<br><code>regexp</code>： 匹配的模式，也就是上文指的正则规则。<br><code>modifier</code>: 正则实例的修饰符,可选值有：<br>i : 表示区分大小写字母匹配。<br>m ：表示多行匹配。<br>g : 表示全局匹配。</p>\n<p>传参的形式如下：<br>我们用构造函数来生成正则表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\\\\d+$\"</span>,<span class=\"string\">\"gim\"</span>);</div></pre></td></tr></table></figure></p>\n<p>这里需要注意，反斜杠需要转义，所以，直接声明量中的语法为<code>\\d</code>，这里需要为 <code>\\\\d</code><br>那么，给它加变量，就和我们前面写的给字符串加变量一样了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"bl\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> re =<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\\\\d+\"</span> + v + <span class=\"string\">\"$\"</span>,<span class=\"string\">\"gim\"</span>);  <span class=\"comment\">// re为/^\\d+bl$/gim</span></div></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"支持正则的String对象方法\"><a href=\"#支持正则的String对象方法\" class=\"headerlink\" title=\"支持正则的String对象方法\"></a>支持正则的String对象方法</h4><ol>\n<li>search 方法<br><strong> 作用： </strong> 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串<br><strong> 基本语法：</strong> <code>stringObject.search(regexp);</code><br><strong> 返回值：</strong> 该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1；<br><strong> 注意点：</strong> search()方法不执行全局匹配，它将忽略标志g，<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world,hello world\"</span>;</div><div class=\"line\"><span class=\"comment\">// 返回匹配到的第一个位置(使用的regexp对象检索)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/hello/</span>)); <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 没有全局的概念 总是返回匹配到的第一个位置</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/hello/g</span>)); <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/world/</span>)); <span class=\"comment\">// 6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果没有检索到的话，则返回-1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/longen/</span>)); <span class=\"comment\">// -1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们检索的时候 可以忽略大小写来检索</span></div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">\"Hello\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2.search(<span class=\"regexp\">/hello/i</span>)); <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br></p>\n<ol>\n<li>match()方法<br><strong> 作用：</strong> 该方法用于在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。类似于indexOf()或者lastIndexOf();<br><strong> 基本语法：</strong> <code>stringObject.match(searchValue) 或者stringObject.match(regexp)</code><br><strong> 返回值：</strong><br>&ensp;&ensp;存放匹配成功的数组; 它可以全局匹配模式，全局匹配的话，它返回的是一个数组。如果没有找到任何的一个匹配，那么它将返回的是null；<br>&ensp;&ensp;返回的数组内有三个元素，第一个元素的存放的是匹配的文本，还有二个对象属性<br>&ensp;&ensp;index属性表明的是匹配文本的起始字符在stringObject中的位置，input属性声明的是对stringObject对象的引用<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"string\">\"hello\"</span>)); <span class=\"comment\">// [\"hello\", index: 0, input: \"hello world\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"string\">\"Helloy\"</span>)); <span class=\"comment\">// null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/hello/</span>)); <span class=\"comment\">// [\"hello\", index: 0, input: \"hello world\"]</span></div><div class=\"line\"><span class=\"comment\">// 全局匹配</span></div><div class=\"line\"><span class=\"keyword\">var</span> str2=<span class=\"string\">\"1 plus 2 equal 3\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2.match(<span class=\"regexp\">/\\d+/g</span>)); <span class=\"comment\">//[\"1\", \"2\", \"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br></p>\n<ol>\n<li>replace()方法<br><strong> 作用：</strong> 该方法用于在字符串中使用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子字符串；<br><strong> 基本用法：</strong> <code>stringObject.replace(regexp/substr,replacement);</code><br><strong> 返回值：</strong> 返回替换后的新字符串<br><strong> 注意：</strong> 字符串的stringObject的replace()方法执行的是查找和替换操作，替换的模式有2种，既可以是字符串，也可以是正则匹配模式，如果是正则匹配模式的话，那么它可以加修饰符g,代表全局替换，否则的话，它只替换第一个匹配的字符串；</li>\n</ol>\n<ul>\n<li>&ensp;&ensp;replacement 既可以是字符串，也可以是函数，如果它是字符串的话，那么匹配的将与字符串替换，replacement中的$有具体的含义，如下：</li>\n<li>&ensp;&ensp;$1,$2,$3….$99 含义是：与regexp中的第1到第99个子表达式相匹配的文本。可以看下面的例子</li>\n<li>&ensp;&ensp;$&amp; 的含义是：与RegExp相匹配的子字符串。</li>\n<li>&ensp;&ensp;lastMatch或RegExp[“$_”]的含义是：返回任何正则表达式搜索过程中的最后匹配的字符。</li>\n<li>&ensp;&ensp;lastParen或 RegExp[“$+”]的含义是：返回任何正则表达式查找过程中最后括号的子匹配。</li>\n<li>&ensp;&ensp;leftContext或RegExp[“$`”]的含义是：返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。</li>\n<li>&ensp;&ensp;rightContext或RegExp[“$’”]的含义是：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\"><span class=\"comment\">// 替换字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s1 = str.replace(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"a\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s1);<span class=\"comment\">// a world</span></div><div class=\"line\"><span class=\"comment\">// 使用正则替换字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s2 = str.replace(<span class=\"regexp\">/hello/</span>,<span class=\"string\">\"b\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s2); <span class=\"comment\">// b world</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用正则全局替换 字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s3 = str.replace(<span class=\"regexp\">/l/g</span>,<span class=\"string\">''</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s3); <span class=\"comment\">// heo word</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $1,$2 代表的是第一个和第二个子表达式相匹配的文本</span></div><div class=\"line\"><span class=\"comment\">// 子表达式需要使用小括号括起来,代表的含义是分组</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"longen,yunxi\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s4 = name.replace(<span class=\"regexp\">/(\\w+)\\s*,\\s*(\\w+)/</span>,<span class=\"string\">\"$2 $1\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s4); <span class=\"comment\">// \"yunxi,longen\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'123-mm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> strReg = str.replace(<span class=\"regexp\">/(\\d+)-([A-Za-z]+)/g</span>,<span class=\"string\">'$2'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(strReg)<span class=\"comment\">//mm  上面那段$2这个就是表示正则第二组个匹配到的内容,也就是说$1,$2.. 表示的是第几个括号匹配到的内容</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $&amp; 是与RegExp相匹配的子字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"hello I am a chinese people\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"regexp\">/am/g</span>;</div><div class=\"line\"><span class=\"keyword\">if</span>(regexp.test(name)) &#123;</div><div class=\"line\">  <span class=\"comment\">//返回正则表达式匹配项的字符串</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$&amp;'</span>]);  <span class=\"comment\">// am</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">\"$'\"</span>]); <span class=\"comment\">// a chinese people</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$`'</span>]);  <span class=\"comment\">// hello I</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 返回任何正则表达式查找过程中最后括号的子匹配。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$+'</span>]); <span class=\"comment\">// 空字符串</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回任何正则表达式搜索过程中的最后匹配的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$_'</span>]);  <span class=\"comment\">// hello I am a chinese people</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// replace 第二个参数也可以是一个function 函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> name2 = <span class=\"string\">\"123sdasadsr44565dffghg987gff33234\"</span>;</div><div class=\"line\">name2.replace(<span class=\"regexp\">/\\d+/g</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">   <span class=\"comment\">// 第一次打印123</span></div><div class=\"line\">   <span class=\"comment\">// 第二次打印44565</span></div><div class=\"line\">   <span class=\"comment\">// 第三次打印987</span></div><div class=\"line\">   <span class=\"comment\">// 第四次打印 33234</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"RegExp对象方法\"><a href=\"#RegExp对象方法\" class=\"headerlink\" title=\"RegExp对象方法\"></a>RegExp对象方法</h4><ol>\n<li>test()方法<br><strong> 作用：</strong> 该方法用于检测一个字符串是否匹配某个模式；<br><strong> 基本语法：</strong> <code>RegExpObject.test(str);</code><br><strong> 返回：</strong> 返回true，否则返回false；<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"longen and yunxi\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longen/</span>.test(str)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longlong/</span>.test(str)); <span class=\"comment\">//false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者创建RegExp对象模式</span></div><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"longen\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(regexp.test(str)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br></p>\n<ol>\n<li>exec()方法<br><strong> 作用：</strong> 该方法用于检索字符串中的正则表达式的匹配<br><strong> 基本语法：</strong> <code>RegExpObject.exec(string)</code><br><strong> 返回值：</strong> 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null；<br><strong> 注意点：</strong> 该返回的数组的第一个元素是与正则表达式相匹配的文本<br>该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"longen and yunxi\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longen/</span>.exec(str));</div><div class=\"line\"><span class=\"comment\">// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 假如没有找到的话，则返回null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/wo/</span>.exec(str)); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"正则表达式类型\"><a href=\"#正则表达式类型\" class=\"headerlink\" title=\"正则表达式类型\"></a>正则表达式类型</h2><h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><p>用于构建正则表达式的符号，常用的有</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>查找任意的单个字符，除换行符外</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>任意一个字母或数字或下划线，A_Za_Z0<em>9,</em>中任意一个</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>查找非单词的字符，等价于[^A_Za_z0<em>9</em></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符，等价于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符，等价于[^0-9]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格，制表符，换行符等等。等价于[\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置，比如’er\\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er”</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界,’er\\B’能匹配’verb’中的’er’,但不能匹配’never’中的’er’</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>匹配非单词边界,’er\\查找NUL字符。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符</td>\n</tr>\n<tr>\n<td>\\xxx</td>\n<td>查找一个以八进制数xxx规定的字符</td>\n</tr>\n<tr>\n<td>\\xdd</td>\n<td>查找以16进制数dd规定的字符</td>\n</tr>\n<tr>\n<td>\\uxxxx</td>\n<td>查找以16进制数的xxxx规定的Unicode字符。</td>\n</tr>\n</tbody>\n</table>\n<p>其实常用的几个可以简单记为下面的几个意思:<br>\\s : 空格<br>\\S : 非空格<br>\\d : 数字<br>\\D : 非数字<br>\\w : 字符 ( 字母 ，数字，下划线_ )<br>\\W : 非字符例子：是否有不是数字的字符</p>\n<h5 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h5><p>用于限定子模式出现在正则表达式的次数。</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>匹配一次或多次，相当于{1,}</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配零次或多次 ，相当于{0,}</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配零次或一次 ，相当于{0,1}</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配至少n个，最多m个某某的字符串</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>匹配至少n个某字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"位置符号\"><a href=\"#位置符号\" class=\"headerlink\" title=\"位置符号\"></a>位置符号</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td>结束符号，例子：n$，匹配以n结尾的字符串</td>\n</tr>\n<tr>\n<td>^</td>\n<td>起始符号,例如^n,匹配以n开头的字符串</td>\n</tr>\n<tr>\n<td>?=</td>\n<td>肯定正向环视,例：?=n,匹配其后紧接指定的n字符串</td>\n</tr>\n<tr>\n<td>?!</td>\n<td>否定正向环视,例如：?!n,匹配其后没有紧接指定的n字符串</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>表示不匹配</td>\n</tr>\n</tbody>\n</table>\n<p><strong> 注意点： </strong><br>&ensp;&ensp;刚开始学习正则的时候，是比较容易混淆 <code>^</code> : 放在正则的最开始位置，就代表起始的意思,放在中括号里，表示排除的意思。也就是说，/[^a]/和/^[a]/是不一样的，前者是排除的意思，后者是代表首位<br>&ensp;&ensp;$:正则的最后位置,就代表结束的意思.</p>\n<h4 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>竖线</td>\n<td>选择(不是他就是她)</td>\n</tr>\n<tr>\n<td>(…)</td>\n<td>分组</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[0-9]</td>\n<td>匹配 0 到 9 间的字符</td>\n</tr>\n<tr>\n<td>[a-zA-Z]</td>\n<td>匹配任意字母</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>不等于0到9的其它字符</td>\n</tr>\n</tbody>\n</table>\n<p>&ensp;&ensp;()分组符号可以理解为，数学运算中的括号，用于计算的分组使用。[]可以理解为，只要满足括号里面其中的某种条件即可。比如[abc],意思是满足abc中的某一个，这样比较好记。</p>\n<h2 id=\"贪婪模式和非贪婪模式\"><a href=\"#贪婪模式和非贪婪模式\" class=\"headerlink\" title=\"贪婪模式和非贪婪模式\"></a>贪婪模式和非贪婪模式</h2><p>&ensp;&ensp;其实可以简单的理解，贪婪模式就是尽可能多的匹配，非贪婪模式就是尽可能少的匹配.<br><strong> 贪婪模式量词：</strong> <code>{x,y} ,  {x,} ,  ? ,  * , 和  +</code><br><strong> 非贪婪模式量词：</strong> <code>{x,y}?，{x,}?，??，*?，和 +?</code>,所以非贪婪模式就是在贪婪模式后面加了一个问号</p>\n<p>我们用代码来理解一下贪婪模式和非贪婪模式的区别<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"&lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2again&lt;p&gt;end&lt;/p&gt;\"</span>;</div><div class=\"line\"><span class=\"comment\">// 非贪婪模式1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/&lt;p&gt;.*?&lt;\\/p&gt;text2/</span>)[<span class=\"number\">0</span>]); <span class=\"comment\">// &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 贪婪模式</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/&lt;p&gt;.*&lt;\\/p&gt;text2/</span>)[<span class=\"number\">0</span>]); <span class=\"comment\">// &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;从上面的代码中，我们可以看到，非贪婪模式，当它匹配到它需要的第一个满足条件之后，他就会停止了。而贪婪模式则会继续向右边进行匹配下去。<br>注意点：?号在一些量词后面才是指非贪婪模式，如果直接在一些字符串的后面，表示的是匹配0次或1次。如下所示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abced'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/ce?/g</span>)); <span class=\"comment\">// [\"ce\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.match(<span class=\"regexp\">/cf?/g</span>)); <span class=\"comment\">// [\"c\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"零宽正向断言和负向断言\"><a href=\"#零宽正向断言和负向断言\" class=\"headerlink\" title=\"零宽正向断言和负向断言\"></a>零宽正向断言和负向断言</h2><ul>\n<li><code>(?=)</code>零宽正向断言: 括号内表示某个位置右边必须和=右边匹配上</li>\n<li><code>(?!)</code>负向断言: 括号内表示某个位置右边不和!后的字符匹配。<br>概念很抽象，直接看代码：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/str(?=ings)ing/</span>;</div><div class=\"line\"><span class=\"comment\">// 表示匹配 r 后面必须有ings的 string字符</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings.a\"</span>.match(pattern)); <span class=\"comment\">//[\"string\", index: 0, input: \"strings.a\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同理，匹配string后面必须有s的 string 字符串</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings.a\"</span>.match(<span class=\"regexp\">/string(?=s)/</span>)); <span class=\"comment\">//[\"string\", index: 0, input: \"strings.a\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string_x\"</span>.match(pattern)); <span class=\"comment\">// null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string_x\"</span>.match(<span class=\"regexp\">/string(?=s)/</span>)); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果理解了(?=),那么(?!)就很好理解了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/string(?!s)/</span>; <span class=\"comment\">// 匹配string后面不带s的string字符串</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings\"</span>.match(pattern)); <span class=\"comment\">//null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string.\"</span>.match(pattern)); <span class=\"comment\">//[\"string\", index: 0, input: \"string.\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"正则表达式实战练习\"><a href=\"#正则表达式实战练习\" class=\"headerlink\" title=\"正则表达式实战练习\"></a>正则表达式实战练习</h2><p>&ensp;&ensp;上面讲的基本都是理论，下面我们来实战一番，以此来巩固我们正则表达式的学习，学习的过程以demo的形式，对我们的知识点进行巩固。<br>&ensp;&ensp;下面的实例是参考这篇文章，有兴趣可以看 <a href=\"http://blog.csdn.net/Mark_LQ/article/details/48999627?locationNum=2&amp;fps=1\" target=\"_blank\" rel=\"external\">原文</a>,不过我整理了一下，个人觉得，把下面的例子都实践一遍，那么就基本掌握正则的使用了，满足平时的工作基本够了。</p>\n<p><strong> demo1: </strong><br>要求：匹配结尾的数字，例如：取出字符串最后一组数字，如：30CACDVB0040 取出40<br>分析：匹配数组字符为\\d,匹配1次或多次为 +，以什么结尾为 $,全局匹配为 g<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'30CACDVB0040'</span>.match(<span class=\"regexp\">/\\d+$/g</span>)); <span class=\"comment\">// [\"0040\"]</span></div></pre></td></tr></table></figure></p>\n<p>如果我们只想要最后结尾的最后两个数字，则可以使用量词 {n,m},所以结果为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'30CACDVB0040'</span>.match(<span class=\"regexp\">/\\d&#123;1,2&#125;$/g</span>)); <span class=\"comment\">// [\"40\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo2: </strong><br>要求:统一空格个数,例如：字符串内字符键有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。<br>分析： 匹配空格的字符为 \\s<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str =<span class=\"string\">'学 习  正    则'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(<span class=\"regexp\">/\\s+/g</span>,<span class=\"string\">' '</span>)); <span class=\"comment\">// 学 习 正 则</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo3: </strong><br>要求：判断字符串是不是由数字组成<br>分析：我们可以这样匹配，以数字 \\d 开头^,以数字结尾 $,匹配零次或多次 *<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str =<span class=\"string\">'学 习  正    则'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/^\\d*$/g</span>.test(<span class=\"string\">'123789'</span>));  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/^\\d*$/g</span>.test(<span class=\"string\">'12378b9'</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo4: </strong><br>要求：验证是否为手机号<br>分析：现在手机开头的范围比较多，第一位是【1】开头，第二位则则有【3,4,5,7,8】，第三位则是【0-9】并且匹配9个数字。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>; <span class=\"comment\">//验证规则</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"number\">15984591578</span>)); <span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"number\">11984591578</span>)); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo5: </strong><br>要求：删除字符串两端的空格<br>分析：跟demo2类似，匹配空格 ^\\s开头，空格结尾 \\s$<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">' 学习正则  '</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(<span class=\"regexp\">/^\\s+|\\s+$/</span>,<span class=\"string\">''</span>));  <span class=\"comment\">// 学习正则</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo6: </strong><br>要求：只能输入数字和小数点<br>分析：开头需要匹配为数字，结尾也应为数字，然后再加个点,点必须转义，匹配0次或一次<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/^\\d*\\.?\\d&#123;0,2&#125;$/</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">'125.1'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">'125a'</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo7: </strong><br>要求：只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./)<br>分析：这几个要求组成一个分组，把他们放在一个分组里,点，正反斜杠，冒号需要转义<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/[a-z\\.\\/\\\\:]+/</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'79abncdc.ab123'</span>.match(reg)); <span class=\"comment\">// [\"abncdc.ab\", index: 2, input: \"79abncdc.ab123\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo8: </strong><br>要求：去掉所有的html标签<br>分析：html标签的形式为<ul></ul>,所以我们可以匹配&lt;开始，然后一些内容，再加上结束符 &gt;<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/&lt;[^&gt;]+&gt;/gi</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;ul&gt;&lt;li&gt;hello world&lt;/li&gt;&lt;/ul&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">''</span>)); <span class=\"comment\">// hello world</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo9: </strong><br>要求：绝对路径变相对路径<br>分析： 比如: <code>&lt;img src=&quot;http://m.163.com/images/163.gif&quot; /&gt;</code> 替换成 <code>&lt;img src=&quot;/images/163.gif&quot; /&gt;</code>.<br>我们要替换http:// 和后面的域名，第一个 / 为止，<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/http:\\/\\/[^\\/]+/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'http://m.163.com/images/163.gif'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">''</span>)); <span class=\"comment\">// /images/163.gif</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo10: </strong><br>要求：用于用户名注册，户名只能用中文、英文、数字、下划线、4-16个字符。<br>分析： 匹配中文的正则为 <code>/[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/</code>,英文，数字的元字符为 \\w,量词 {4,16}<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^/</span>[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]&#123;<span class=\"number\">4</span>,<span class=\"number\">16</span>&#125;$/;</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">'hellow_1230'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'hellow_1230*'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str3 = <span class=\"string\">'hellow_12304549764654657456465756'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str1)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2)); <span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str3)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo11 : </strong><br>要求：匹配身份证号<br>分析：身份证为15为或者18位，最后一位为数字或者x<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'44162119920547892X'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str));  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo12: </strong><br>要求：验证邮箱<br>分析：邮箱的形式可能为 234564@qq.com; fasdfja@163.com，可以看到，前面为字母或者数字，然后加@,@后面可能是数字或者是其他，然后再加 . 再然后是一些com或者其他字符，我们用()来进行分组；<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^([\\w_-])+@([\\w_-])+([\\.\\w_-])+/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">'test@hotmail.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'test@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str3 = <span class=\"string\">'te-st@qq.com.cn'</span>;  </div><div class=\"line\"><span class=\"keyword\">var</span> str4 = <span class=\"string\">'te_st@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str5 = <span class=\"string\">'te.._st@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str1)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str3)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str4)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str5)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo13: </strong><br>要求：匹配源代码中的链接<br>分析：a标签中有href，也可能有class ,id等其他属性，而且不确定a标签后面是否有空格，所以要考虑的东西比较多。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/&lt;a\\s(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*href\\s*=\\s*\".+?\")(\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;[\\s\\S]*?&lt;\\/a&gt;/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;p&gt;测试链接：&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;&lt;/p&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(reg));  <span class=\"comment\">// [\"&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo14: </strong><br>要求：匹配a标签里面的内容<br>分析：上面的demo中，我们匹配到了a标签，这里的话我们匹配a标签里面的内容，这里要学习一个符号<code>?:</code>表示不匹配，所以我们在前面的括号中加上<code>?:</code>去掉a标签的匹配，然后再a标签内容里加个括号，表示分组。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/&lt;a\\s(?:\\s*\\w*?\\s*=\\s*\".+?\")*(?:\\s*href\\s*=\\s*\".+?\")(?:\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;([\\s\\S]*?)&lt;\\/a&gt;/</span>;;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">'$1'</span>));  <span class=\"comment\">// 经典论坛    $1 表示的是括号里面的分组，由于前面的括号都是不获取，所以获取的第一个括号的内容就是a标签里面的内容</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo15： </strong><br>要求：获取url的指定参数的值<br>分析： url带参数类似为这样：<a href=\"http://www.baicu.com?type=1&amp;value=789\" target=\"_blank\" rel=\"external\">http://www.baicu.com?type=1&amp;value=789</a>; 所以，要获取的参数要么是在?或者&amp;开头，到下一个&amp;或者直接后面什么都不跟为止。这里我们用new RegExp的形式，因为这样可以传参。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取url中的value值</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://www.baicu.com?type=1&amp;value=789'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|&amp;|\\\\?)value=([^&amp;]*)(&amp;|$)\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(url.match(reg)); <span class=\"comment\">//[\"&amp;value=789\", \"&amp;\", \"789\", \"\", index: 27, input: \"http://www.baicu.com?type=1&amp;value=789\"]</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>稍微改编一下，我们就可以弄一个获取指定参数值的函数了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUrlParam</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|&amp;|\\\\?)\"</span> + name + <span class=\"string\">\"=([^&amp;]*)(&amp;|$)\"</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"built_in\">window</span>.location.search.substr(<span class=\"number\">1</span>).match(reg);</div><div class=\"line\">  <span class=\"keyword\">if</span> (r != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(r[<span class=\"number\">2</span>]);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong> demo16: </strong><br>要求：将数字 15476465转变为15,476,465<br>分析：我们可以这样，匹配一个数字，然后它的后面紧跟着三个数字，并且结尾也是要有三个数字，比如 12345689我们找到 1<code>2</code> 34<code>5</code> 689,符合条件的是数字2和5，因为它后面紧跟着三个数字，并且这样结尾也是三个数字。然后我们在2和5的后面加个<code>,</code>,就达到了我们的目的12,345,689;<br>知识补充：这里我们需要介绍正则的一个知识点，断言<code>?=</code>,它只匹配一个位置。假如匹配一个“人”字，但是你只想匹配中国人的人字，不想匹配法国人的人<code>(?=中国)人</code>;<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'15476465'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/(\\d)(?=(\\d&#123;3&#125;)+$)/g</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">'$1,'</span>)); <span class=\"comment\">//15,476,465</span></div></pre></td></tr></table></figure></p>\n<p>进一步讲解：/(\\d)(?=(\\d{3})+$)/匹配的是一个数字，即(\\d),<br>它后面的字符串必须是三的倍数，这个表达就是(?=(\\d{3})+$),且最后一次匹配以 3 个数字结尾<br>$1,表示在第一个分组表达式匹配的字符后面加,，这里其实只有一个(\\d)，问号后面的可以看成它的定语。/(\\d)(?=(\\d{3})+$)/g<br>这个表达式通俗来说是：要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加,</p>\n<p><strong> demo17： </strong><br>要求：将阿拉伯数字替换为中文大写形式<br>分析：我们可以用replace来弄这个，replace中的function可以获取到匹配的每一个内容，比如返回匹配数字188，那么就会依次返回1,8,8<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/\\d/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> arr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">\"零\"</span>,<span class=\"string\">\"壹\"</span>,<span class=\"string\">\"贰\"</span>,<span class=\"string\">\"叁\"</span>,<span class=\"string\">\"肆\"</span>,<span class=\"string\">\"伍\"</span>,<span class=\"string\">\"陆\"</span>,<span class=\"string\">\"柒\"</span>,<span class=\"string\">\"捌\"</span>,<span class=\"string\">\"玖\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'189454'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> arr[m];  <span class=\"comment\">//壹捌玖肆伍肆</span></div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>&ensp;&ensp;&ensp;&ensp;正则表达式之前学习的时候，因为很久没怎么用，或者用的时候直接找网上现成的，所以都基本忘的差不多了。所以这篇文章即是笔记，也让自己再重新学习一遍正则表达式。<br>&ensp;&ensp;&ensp;&ensp;其实平时在操作一些字符串的时候，用正则的机会还是挺多的，之前没怎么重视正则，这是一个错误。写完这篇文章后，发觉工作中很多地方都可以用到正则，而且用起来其实还是挺爽的。</p>","more":"<h2 id=\"正则表达式作用\"><a href=\"#正则表达式作用\" class=\"headerlink\" title=\"正则表达式作用\"></a>正则表达式作用</h2><p>&ensp;&ensp;&ensp;&ensp;正则表达式，又称规则表达式，它可以通过一些设定的规则来匹配一些字符串，是一个强大的<code>字符串</code>匹配工具。</p>\n<h2 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h2><h4 id=\"基本语法，正则声明\"><a href=\"#基本语法，正则声明\" class=\"headerlink\" title=\"基本语法，正则声明\"></a>基本语法，正则声明</h4><p>js中，正则的声明有两种方式</p>\n<ol>\n<li><p>直接量语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/d+/g</span><span class=\"regexp\">/</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>创建RegExp对象的语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"\\\\d+\"</span>, <span class=\"string\">\"g\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这两种声明方式其实还是有区别的，平时的话我比较喜欢第一种，方便一点，如果需要给正则表达式传递参数的话，那么只能用第二种创建RegExp的形式<br>格式：<code>var pattern = new RegExp(&#39;regexp&#39;,&#39;modifier&#39;)</code>;<br><code>regexp</code>： 匹配的模式，也就是上文指的正则规则。<br><code>modifier</code>: 正则实例的修饰符,可选值有：<br>i : 表示区分大小写字母匹配。<br>m ：表示多行匹配。<br>g : 表示全局匹配。</p>\n<p>传参的形式如下：<br>我们用构造函数来生成正则表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\\\\d+$\"</span>,<span class=\"string\">\"gim\"</span>);</div></pre></td></tr></table></figure></p>\n<p>这里需要注意，反斜杠需要转义，所以，直接声明量中的语法为<code>\\d</code>，这里需要为 <code>\\\\d</code><br>那么，给它加变量，就和我们前面写的给字符串加变量一样了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"bl\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> re =<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"^\\\\d+\"</span> + v + <span class=\"string\">\"$\"</span>,<span class=\"string\">\"gim\"</span>);  <span class=\"comment\">// re为/^\\d+bl$/gim</span></div></pre></td></tr></table></figure></p>\n<p><br /></p>\n<h4 id=\"支持正则的String对象方法\"><a href=\"#支持正则的String对象方法\" class=\"headerlink\" title=\"支持正则的String对象方法\"></a>支持正则的String对象方法</h4><ol>\n<li>search 方法<br><strong> 作用： </strong> 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串<br><strong> 基本语法：</strong> <code>stringObject.search(regexp);</code><br><strong> 返回值：</strong> 该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1；<br><strong> 注意点：</strong> search()方法不执行全局匹配，它将忽略标志g，<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world,hello world\"</span>;</div><div class=\"line\"><span class=\"comment\">// 返回匹配到的第一个位置(使用的regexp对象检索)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/hello/</span>)); <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 没有全局的概念 总是返回匹配到的第一个位置</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/hello/g</span>)); <span class=\"comment\">//0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/world/</span>)); <span class=\"comment\">// 6</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果没有检索到的话，则返回-1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.search(<span class=\"regexp\">/longen/</span>)); <span class=\"comment\">// -1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们检索的时候 可以忽略大小写来检索</span></div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">\"Hello\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2.search(<span class=\"regexp\">/hello/i</span>)); <span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br /></p>\n<ol>\n<li>match()方法<br><strong> 作用：</strong> 该方法用于在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。类似于indexOf()或者lastIndexOf();<br><strong> 基本语法：</strong> <code>stringObject.match(searchValue) 或者stringObject.match(regexp)</code><br><strong> 返回值：</strong><br>&ensp;&ensp;存放匹配成功的数组; 它可以全局匹配模式，全局匹配的话，它返回的是一个数组。如果没有找到任何的一个匹配，那么它将返回的是null；<br>&ensp;&ensp;返回的数组内有三个元素，第一个元素的存放的是匹配的文本，还有二个对象属性<br>&ensp;&ensp;index属性表明的是匹配文本的起始字符在stringObject中的位置，input属性声明的是对stringObject对象的引用<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"string\">\"hello\"</span>)); <span class=\"comment\">// [\"hello\", index: 0, input: \"hello world\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"string\">\"Helloy\"</span>)); <span class=\"comment\">// null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/hello/</span>)); <span class=\"comment\">// [\"hello\", index: 0, input: \"hello world\"]</span></div><div class=\"line\"><span class=\"comment\">// 全局匹配</span></div><div class=\"line\"><span class=\"keyword\">var</span> str2=<span class=\"string\">\"1 plus 2 equal 3\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str2.match(<span class=\"regexp\">/\\d+/g</span>)); <span class=\"comment\">//[\"1\", \"2\", \"3\"]</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br /></p>\n<ol>\n<li>replace()方法<br><strong> 作用：</strong> 该方法用于在字符串中使用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子字符串；<br><strong> 基本用法：</strong> <code>stringObject.replace(regexp/substr,replacement);</code><br><strong> 返回值：</strong> 返回替换后的新字符串<br><strong> 注意：</strong> 字符串的stringObject的replace()方法执行的是查找和替换操作，替换的模式有2种，既可以是字符串，也可以是正则匹配模式，如果是正则匹配模式的话，那么它可以加修饰符g,代表全局替换，否则的话，它只替换第一个匹配的字符串；</li>\n</ol>\n<ul>\n<li>&ensp;&ensp;replacement 既可以是字符串，也可以是函数，如果它是字符串的话，那么匹配的将与字符串替换，replacement中的$有具体的含义，如下：</li>\n<li>&ensp;&ensp;$1,$2,$3….$99 含义是：与regexp中的第1到第99个子表达式相匹配的文本。可以看下面的例子</li>\n<li>&ensp;&ensp;$&amp; 的含义是：与RegExp相匹配的子字符串。</li>\n<li>&ensp;&ensp;lastMatch或RegExp[“$_”]的含义是：返回任何正则表达式搜索过程中的最后匹配的字符。</li>\n<li>&ensp;&ensp;lastParen或 RegExp[“$+”]的含义是：返回任何正则表达式查找过程中最后括号的子匹配。</li>\n<li>&ensp;&ensp;leftContext或RegExp[“$`”]的含义是：返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。</li>\n<li>&ensp;&ensp;rightContext或RegExp[“$’”]的含义是：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\"><span class=\"comment\">// 替换字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s1 = str.replace(<span class=\"string\">\"hello\"</span>,<span class=\"string\">\"a\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s1);<span class=\"comment\">// a world</span></div><div class=\"line\"><span class=\"comment\">// 使用正则替换字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s2 = str.replace(<span class=\"regexp\">/hello/</span>,<span class=\"string\">\"b\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s2); <span class=\"comment\">// b world</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用正则全局替换 字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> s3 = str.replace(<span class=\"regexp\">/l/g</span>,<span class=\"string\">''</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s3); <span class=\"comment\">// heo word</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $1,$2 代表的是第一个和第二个子表达式相匹配的文本</span></div><div class=\"line\"><span class=\"comment\">// 子表达式需要使用小括号括起来,代表的含义是分组</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"longen,yunxi\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> s4 = name.replace(<span class=\"regexp\">/(\\w+)\\s*,\\s*(\\w+)/</span>,<span class=\"string\">\"$2 $1\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(s4); <span class=\"comment\">// \"yunxi,longen\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'123-mm'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> strReg = str.replace(<span class=\"regexp\">/(\\d+)-([A-Za-z]+)/g</span>,<span class=\"string\">'$2'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(strReg)<span class=\"comment\">//mm  上面那段$2这个就是表示正则第二组个匹配到的内容,也就是说$1,$2.. 表示的是第几个括号匹配到的内容</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// $&amp; 是与RegExp相匹配的子字符串</span></div><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"hello I am a chinese people\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"regexp\">/am/g</span>;</div><div class=\"line\"><span class=\"keyword\">if</span>(regexp.test(name)) &#123;</div><div class=\"line\">  <span class=\"comment\">//返回正则表达式匹配项的字符串</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$&amp;'</span>]);  <span class=\"comment\">// am</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">\"$'\"</span>]); <span class=\"comment\">// a chinese people</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$`'</span>]);  <span class=\"comment\">// hello I</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 返回任何正则表达式查找过程中最后括号的子匹配。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$+'</span>]); <span class=\"comment\">// 空字符串</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//返回任何正则表达式搜索过程中的最后匹配的字符。</span></div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">RegExp</span>[<span class=\"string\">'$_'</span>]);  <span class=\"comment\">// hello I am a chinese people</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// replace 第二个参数也可以是一个function 函数</span></div><div class=\"line\"><span class=\"keyword\">var</span> name2 = <span class=\"string\">\"123sdasadsr44565dffghg987gff33234\"</span>;</div><div class=\"line\">name2.replace(<span class=\"regexp\">/\\d+/g</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">   <span class=\"comment\">// 第一次打印123</span></div><div class=\"line\">   <span class=\"comment\">// 第二次打印44565</span></div><div class=\"line\">   <span class=\"comment\">// 第三次打印987</span></div><div class=\"line\">   <span class=\"comment\">// 第四次打印 33234</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"RegExp对象方法\"><a href=\"#RegExp对象方法\" class=\"headerlink\" title=\"RegExp对象方法\"></a>RegExp对象方法</h4><ol>\n<li>test()方法<br><strong> 作用：</strong> 该方法用于检测一个字符串是否匹配某个模式；<br><strong> 基本语法：</strong> <code>RegExpObject.test(str);</code><br><strong> 返回：</strong> 返回true，否则返回false；<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"longen and yunxi\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longen/</span>.test(str)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longlong/</span>.test(str)); <span class=\"comment\">//false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 或者创建RegExp对象模式</span></div><div class=\"line\"><span class=\"keyword\">var</span> regexp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"longen\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(regexp.test(str)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br /></p>\n<ol>\n<li>exec()方法<br><strong> 作用：</strong> 该方法用于检索字符串中的正则表达式的匹配<br><strong> 基本语法：</strong> <code>RegExpObject.exec(string)</code><br><strong> 返回值：</strong> 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null；<br><strong> 注意点：</strong> 该返回的数组的第一个元素是与正则表达式相匹配的文本<br>该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"longen and yunxi\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/longen/</span>.exec(str));</div><div class=\"line\"><span class=\"comment\">// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 假如没有找到的话，则返回null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/wo/</span>.exec(str)); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"正则表达式类型\"><a href=\"#正则表达式类型\" class=\"headerlink\" title=\"正则表达式类型\"></a>正则表达式类型</h2><h4 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h4><p>用于构建正则表达式的符号，常用的有</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>查找任意的单个字符，除换行符外</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>任意一个字母或数字或下划线，A_Za_Z0<em>9,</em>中任意一个</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>查找非单词的字符，等价于[^A_Za_z0<em>9</em></td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符，等价于[0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符，等价于[^0-9]</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格，制表符，换行符等等。等价于[\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v]</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置，比如’er\\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er”</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界,’er\\B’能匹配’verb’中的’er’,但不能匹配’never’中的’er’</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>匹配非单词边界,’er\\查找NUL字符。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符</td>\n</tr>\n<tr>\n<td>\\xxx</td>\n<td>查找一个以八进制数xxx规定的字符</td>\n</tr>\n<tr>\n<td>\\xdd</td>\n<td>查找以16进制数dd规定的字符</td>\n</tr>\n<tr>\n<td>\\uxxxx</td>\n<td>查找以16进制数的xxxx规定的Unicode字符。</td>\n</tr>\n</tbody>\n</table>\n<p>其实常用的几个可以简单记为下面的几个意思:<br>\\s : 空格<br>\\S : 非空格<br>\\d : 数字<br>\\D : 非数字<br>\\w : 字符 ( 字母 ，数字，下划线_ )<br>\\W : 非字符例子：是否有不是数字的字符</p>\n<h5 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h5><p>用于限定子模式出现在正则表达式的次数。</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>匹配一次或多次，相当于{1,}</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配零次或多次 ，相当于{0,}</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配零次或一次 ，相当于{0,1}</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>匹配至少n个，最多m个某某的字符串</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>匹配至少n个某字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"位置符号\"><a href=\"#位置符号\" class=\"headerlink\" title=\"位置符号\"></a>位置符号</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td>结束符号，例子：n$，匹配以n结尾的字符串</td>\n</tr>\n<tr>\n<td>^</td>\n<td>起始符号,例如^n,匹配以n开头的字符串</td>\n</tr>\n<tr>\n<td>?=</td>\n<td>肯定正向环视,例：?=n,匹配其后紧接指定的n字符串</td>\n</tr>\n<tr>\n<td>?!</td>\n<td>否定正向环视,例如：?!n,匹配其后没有紧接指定的n字符串</td>\n</tr>\n<tr>\n<td>?:</td>\n<td>表示不匹配</td>\n</tr>\n</tbody>\n</table>\n<p><strong> 注意点： </strong><br>&ensp;&ensp;刚开始学习正则的时候，是比较容易混淆 <code>^</code> : 放在正则的最开始位置，就代表起始的意思,放在中括号里，表示排除的意思。也就是说，/[^a]/和/^[a]/是不一样的，前者是排除的意思，后者是代表首位<br>&ensp;&ensp;$:正则的最后位置,就代表结束的意思.</p>\n<h4 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>竖线</td>\n<td>选择(不是他就是她)</td>\n</tr>\n<tr>\n<td>(…)</td>\n<td>分组</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h4><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[0-9]</td>\n<td>匹配 0 到 9 间的字符</td>\n</tr>\n<tr>\n<td>[a-zA-Z]</td>\n<td>匹配任意字母</td>\n</tr>\n<tr>\n<td>[^0-9]</td>\n<td>不等于0到9的其它字符</td>\n</tr>\n</tbody>\n</table>\n<p>&ensp;&ensp;()分组符号可以理解为，数学运算中的括号，用于计算的分组使用。[]可以理解为，只要满足括号里面其中的某种条件即可。比如[abc],意思是满足abc中的某一个，这样比较好记。</p>\n<h2 id=\"贪婪模式和非贪婪模式\"><a href=\"#贪婪模式和非贪婪模式\" class=\"headerlink\" title=\"贪婪模式和非贪婪模式\"></a>贪婪模式和非贪婪模式</h2><p>&ensp;&ensp;其实可以简单的理解，贪婪模式就是尽可能多的匹配，非贪婪模式就是尽可能少的匹配.<br><strong> 贪婪模式量词：</strong> <code>{x,y} ,  {x,} ,  ? ,  * , 和  +</code><br><strong> 非贪婪模式量词：</strong> <code>{x,y}?，{x,}?，??，*?，和 +?</code>,所以非贪婪模式就是在贪婪模式后面加了一个问号</p>\n<p>我们用代码来理解一下贪婪模式和非贪婪模式的区别<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"&lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2again&lt;p&gt;end&lt;/p&gt;\"</span>;</div><div class=\"line\"><span class=\"comment\">// 非贪婪模式1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/&lt;p&gt;.*?&lt;\\/p&gt;text2/</span>)[<span class=\"number\">0</span>]); <span class=\"comment\">// &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 贪婪模式</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/&lt;p&gt;.*&lt;\\/p&gt;text2/</span>)[<span class=\"number\">0</span>]); <span class=\"comment\">// &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2</span></div></pre></td></tr></table></figure></p>\n<p>&ensp;&ensp;从上面的代码中，我们可以看到，非贪婪模式，当它匹配到它需要的第一个满足条件之后，他就会停止了。而贪婪模式则会继续向右边进行匹配下去。<br>注意点：?号在一些量词后面才是指非贪婪模式，如果直接在一些字符串的后面，表示的是匹配0次或1次。如下所示<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'abced'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(<span class=\"regexp\">/ce?/g</span>)); <span class=\"comment\">// [\"ce\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.match(<span class=\"regexp\">/cf?/g</span>)); <span class=\"comment\">// [\"c\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"零宽正向断言和负向断言\"><a href=\"#零宽正向断言和负向断言\" class=\"headerlink\" title=\"零宽正向断言和负向断言\"></a>零宽正向断言和负向断言</h2><ul>\n<li><code>(?=)</code>零宽正向断言: 括号内表示某个位置右边必须和=右边匹配上</li>\n<li><code>(?!)</code>负向断言: 括号内表示某个位置右边不和!后的字符匹配。<br>概念很抽象，直接看代码：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/str(?=ings)ing/</span>;</div><div class=\"line\"><span class=\"comment\">// 表示匹配 r 后面必须有ings的 string字符</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings.a\"</span>.match(pattern)); <span class=\"comment\">//[\"string\", index: 0, input: \"strings.a\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 同理，匹配string后面必须有s的 string 字符串</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings.a\"</span>.match(<span class=\"regexp\">/string(?=s)/</span>)); <span class=\"comment\">//[\"string\", index: 0, input: \"strings.a\"]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string_x\"</span>.match(pattern)); <span class=\"comment\">// null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string_x\"</span>.match(<span class=\"regexp\">/string(?=s)/</span>)); <span class=\"comment\">// null</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果理解了(?=),那么(?!)就很好理解了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> pattern=<span class=\"regexp\">/string(?!s)/</span>; <span class=\"comment\">// 匹配string后面不带s的string字符串</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"strings\"</span>.match(pattern)); <span class=\"comment\">//null</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string.\"</span>.match(pattern)); <span class=\"comment\">//[\"string\", index: 0, input: \"string.\"]</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"正则表达式实战练习\"><a href=\"#正则表达式实战练习\" class=\"headerlink\" title=\"正则表达式实战练习\"></a>正则表达式实战练习</h2><p>&ensp;&ensp;上面讲的基本都是理论，下面我们来实战一番，以此来巩固我们正则表达式的学习，学习的过程以demo的形式，对我们的知识点进行巩固。<br>&ensp;&ensp;下面的实例是参考这篇文章，有兴趣可以看 <a href=\"http://blog.csdn.net/Mark_LQ/article/details/48999627?locationNum=2&amp;fps=1\">原文</a>,不过我整理了一下，个人觉得，把下面的例子都实践一遍，那么就基本掌握正则的使用了，满足平时的工作基本够了。</p>\n<p><strong> demo1: </strong><br>要求：匹配结尾的数字，例如：取出字符串最后一组数字，如：30CACDVB0040 取出40<br>分析：匹配数组字符为\\d,匹配1次或多次为 +，以什么结尾为 $,全局匹配为 g<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'30CACDVB0040'</span>.match(<span class=\"regexp\">/\\d+$/g</span>)); <span class=\"comment\">// [\"0040\"]</span></div></pre></td></tr></table></figure></p>\n<p>如果我们只想要最后结尾的最后两个数字，则可以使用量词 {n,m},所以结果为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'30CACDVB0040'</span>.match(<span class=\"regexp\">/\\d&#123;1,2&#125;$/g</span>)); <span class=\"comment\">// [\"40\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo2: </strong><br>要求:统一空格个数,例如：字符串内字符键有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。<br>分析： 匹配空格的字符为 \\s<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str =<span class=\"string\">'学 习  正    则'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(<span class=\"regexp\">/\\s+/g</span>,<span class=\"string\">' '</span>)); <span class=\"comment\">// 学 习 正 则</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo3: </strong><br>要求：判断字符串是不是由数字组成<br>分析：我们可以这样匹配，以数字 \\d 开头^,以数字结尾 $,匹配零次或多次 *<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str =<span class=\"string\">'学 习  正    则'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/^\\d*$/g</span>.test(<span class=\"string\">'123789'</span>));  <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"regexp\">/^\\d*$/g</span>.test(<span class=\"string\">'12378b9'</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo4: </strong><br>要求：验证是否为手机号<br>分析：现在手机开头的范围比较多，第一位是【1】开头，第二位则则有【3,4,5,7,8】，第三位则是【0-9】并且匹配9个数字。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>; <span class=\"comment\">//验证规则</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"number\">15984591578</span>)); <span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"number\">11984591578</span>)); <span class=\"comment\">//false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo5: </strong><br>要求：删除字符串两端的空格<br>分析：跟demo2类似，匹配空格 ^\\s开头，空格结尾 \\s$<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">' 学习正则  '</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(<span class=\"regexp\">/^\\s+|\\s+$/</span>,<span class=\"string\">''</span>));  <span class=\"comment\">// 学习正则</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo6: </strong><br>要求：只能输入数字和小数点<br>分析：开头需要匹配为数字，结尾也应为数字，然后再加个点,点必须转义，匹配0次或一次<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/^\\d*\\.?\\d&#123;0,2&#125;$/</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">'125.1'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(<span class=\"string\">'125a'</span>)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo7: </strong><br>要求：只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./)<br>分析：这几个要求组成一个分组，把他们放在一个分组里,点，正反斜杠，冒号需要转义<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/[a-z\\.\\/\\\\:]+/</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'79abncdc.ab123'</span>.match(reg)); <span class=\"comment\">// [\"abncdc.ab\", index: 2, input: \"79abncdc.ab123\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo8: </strong><br>要求：去掉所有的html标签<br>分析：html标签的形式为<ul></ul>,所以我们可以匹配&lt;开始，然后一些内容，再加上结束符 &gt;<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/&lt;[^&gt;]+&gt;/gi</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;ul&gt;&lt;li&gt;hello world&lt;/li&gt;&lt;/ul&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">''</span>)); <span class=\"comment\">// hello world</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo9: </strong><br>要求：绝对路径变相对路径<br>分析： 比如: <code>&lt;img src=&quot;http://m.163.com/images/163.gif&quot; /&gt;</code> 替换成 <code>&lt;img src=&quot;/images/163.gif&quot; /&gt;</code>.<br>我们要替换http:// 和后面的域名，第一个 / 为止，<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/http:\\/\\/[^\\/]+/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'http://m.163.com/images/163.gif'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">''</span>)); <span class=\"comment\">// /images/163.gif</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo10: </strong><br>要求：用于用户名注册，户名只能用中文、英文、数字、下划线、4-16个字符。<br>分析： 匹配中文的正则为 <code>/[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/</code>,英文，数字的元字符为 \\w,量词 {4,16}<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^/</span>[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]&#123;<span class=\"number\">4</span>,<span class=\"number\">16</span>&#125;$/;</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">'hellow_1230'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'hellow_1230*'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str3 = <span class=\"string\">'hellow_12304549764654657456465756'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str1)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2)); <span class=\"comment\">//false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str3)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo11 : </strong><br>要求：匹配身份证号<br>分析：身份证为15为或者18位，最后一位为数字或者x<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'44162119920547892X'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str));  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo12: </strong><br>要求：验证邮箱<br>分析：邮箱的形式可能为 234564@qq.com; fasdfja@163.com，可以看到，前面为字母或者数字，然后加@,@后面可能是数字或者是其他，然后再加 . 再然后是一些com或者其他字符，我们用()来进行分组；<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/^([\\w_-])+@([\\w_-])+([\\.\\w_-])+/</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str1 = <span class=\"string\">'test@hotmail.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">'test@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str3 = <span class=\"string\">'te-st@qq.com.cn'</span>;  </div><div class=\"line\"><span class=\"keyword\">var</span> str4 = <span class=\"string\">'te_st@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str5 = <span class=\"string\">'te.._st@sima.vip.com'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str1)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str2)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str3)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str4)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(reg.test(str5)); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo13: </strong><br>要求：匹配源代码中的链接<br>分析：a标签中有href，也可能有class ,id等其他属性，而且不确定a标签后面是否有空格，所以要考虑的东西比较多。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/&lt;a\\s(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*href\\s*=\\s*\".+?\")(\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;[\\s\\S]*?&lt;\\/a&gt;/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;p&gt;测试链接：&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;&lt;/p&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.match(reg));  <span class=\"comment\">// [\"&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;\"]</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo14: </strong><br>要求：匹配a标签里面的内容<br>分析：上面的demo中，我们匹配到了a标签，这里的话我们匹配a标签里面的内容，这里要学习一个符号<code>?:</code>表示不匹配，所以我们在前面的括号中加上<code>?:</code>去掉a标签的匹配，然后再a标签内容里加个括号，表示分组。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/&lt;a\\s(?:\\s*\\w*?\\s*=\\s*\".+?\")*(?:\\s*href\\s*=\\s*\".+?\")(?:\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;([\\s\\S]*?)&lt;\\/a&gt;/</span>;;</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">'$1'</span>));  <span class=\"comment\">// 经典论坛    $1 表示的是括号里面的分组，由于前面的括号都是不获取，所以获取的第一个括号的内容就是a标签里面的内容</span></div></pre></td></tr></table></figure></p>\n<p><strong> demo15： </strong><br>要求：获取url的指定参数的值<br>分析： url带参数类似为这样：<a href=\"http://www.baicu.com?type=1&amp;value=789\">http://www.baicu.com?type=1&amp;value=789</a>; 所以，要获取的参数要么是在?或者&amp;开头，到下一个&amp;或者直接后面什么都不跟为止。这里我们用new RegExp的形式，因为这样可以传参。<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 获取url中的value值</span></div><div class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://www.baicu.com?type=1&amp;value=789'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|&amp;|\\\\?)value=([^&amp;]*)(&amp;|$)\"</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(url.match(reg)); <span class=\"comment\">//[\"&amp;value=789\", \"&amp;\", \"789\", \"\", index: 27, input: \"http://www.baicu.com?type=1&amp;value=789\"]</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>稍微改编一下，我们就可以弄一个获取指定参数值的函数了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getUrlParam</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> reg = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">\"(^|&amp;|\\\\?)\"</span> + name + <span class=\"string\">\"=([^&amp;]*)(&amp;|$)\"</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> r = <span class=\"built_in\">window</span>.location.search.substr(<span class=\"number\">1</span>).match(reg);</div><div class=\"line\">  <span class=\"keyword\">if</span> (r != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(r[<span class=\"number\">2</span>]);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong> demo16: </strong><br>要求：将数字 15476465转变为15,476,465<br>分析：我们可以这样，匹配一个数字，然后它的后面紧跟着三个数字，并且结尾也是要有三个数字，比如 12345689我们找到 1<code>2</code> 34<code>5</code> 689,符合条件的是数字2和5，因为它后面紧跟着三个数字，并且这样结尾也是三个数字。然后我们在2和5的后面加个<code>,</code>,就达到了我们的目的12,345,689;<br>知识补充：这里我们需要介绍正则的一个知识点，断言<code>?=</code>,它只匹配一个位置。假如匹配一个“人”字，但是你只想匹配中国人的人字，不想匹配法国人的人<code>(?=中国)人</code>;<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'15476465'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> reg =<span class=\"regexp\">/(\\d)(?=(\\d&#123;3&#125;)+$)/g</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"string\">'$1,'</span>)); <span class=\"comment\">//15,476,465</span></div></pre></td></tr></table></figure></p>\n<p>进一步讲解：/(\\d)(?=(\\d{3})+$)/匹配的是一个数字，即(\\d),<br>它后面的字符串必须是三的倍数，这个表达就是(?=(\\d{3})+$),且最后一次匹配以 3 个数字结尾<br>$1,表示在第一个分组表达式匹配的字符后面加,，这里其实只有一个(\\d)，问号后面的可以看成它的定语。/(\\d)(?=(\\d{3})+$)/g<br>这个表达式通俗来说是：要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加,</p>\n<p><strong> demo17： </strong><br>要求：将阿拉伯数字替换为中文大写形式<br>分析：我们可以用replace来弄这个，replace中的function可以获取到匹配的每一个内容，比如返回匹配数字188，那么就会依次返回1,8,8<br>结果：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/\\d/g</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> arr=<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">\"零\"</span>,<span class=\"string\">\"壹\"</span>,<span class=\"string\">\"贰\"</span>,<span class=\"string\">\"叁\"</span>,<span class=\"string\">\"肆\"</span>,<span class=\"string\">\"伍\"</span>,<span class=\"string\">\"陆\"</span>,<span class=\"string\">\"柒\"</span>,<span class=\"string\">\"捌\"</span>,<span class=\"string\">\"玖\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">'189454'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(str.replace(reg,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> arr[m];  <span class=\"comment\">//壹捌玖肆伍肆</span></div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj5b4gr7n000j9gsc39fcyvpk","category_id":"cj5b4gr87000n9gscg96vz4ws","_id":"cj5b4gr9n000v9gsc4o3fvyht"}],"PostTag":[{"post_id":"cj5b4gr3n00009gsc593vfjq9","tag_id":"cj5b4gr5300049gscmedtz2yv","_id":"cj5b4gr73000e9gsceggkq5le"},{"post_id":"cj5b4gr3n00009gsc593vfjq9","tag_id":"cj5b4gr6j00099gsc6y1jaj1p","_id":"cj5b4gr7b000g9gscnq0tt402"},{"post_id":"cj5b4gr7f000i9gscsogyfmmq","tag_id":"cj5b4gr5300049gscmedtz2yv","_id":"cj5b4gr7v000k9gscciulsr5w"},{"post_id":"cj5b4gr4j00029gscs53ybbwd","tag_id":"cj5b4gr6v000c9gsceqnkdis3","_id":"cj5b4gr8v000o9gsc8be1aakv"},{"post_id":"cj5b4gr4j00029gscs53ybbwd","tag_id":"cj5b4gr7f000h9gscdqfndkqc","_id":"cj5b4gr97000q9gsco1ppk59m"},{"post_id":"cj5b4gr5b00059gscxke46v1e","tag_id":"cj5b4gr6v000c9gsceqnkdis3","_id":"cj5b4gr9n000u9gscp6xvg479"},{"post_id":"cj5b4gr5b00059gscxke46v1e","tag_id":"cj5b4gr7f000h9gscdqfndkqc","_id":"cj5b4gr9n000w9gsc1eu6j352"},{"post_id":"cj5b4gr5v00079gscpsno978p","tag_id":"cj5b4gr9j000t9gsc6i482hix","_id":"cj5b4gr9v000y9gsc9gzh3ng6"},{"post_id":"cj5b4gr6700089gscba5rxndr","tag_id":"cj5b4gr9r000x9gsc3yaiwz5a","_id":"cj5b4gra700119gscrda6gqre"},{"post_id":"cj5b4gr6700089gscba5rxndr","tag_id":"cj5b4gr9z000z9gsc7y8fieou","_id":"cj5b4gra700129gscg79jjkk5"},{"post_id":"cj5b4gr6n000a9gscmadpn3b7","tag_id":"cj5b4gra300109gscx64pfyx3","_id":"cj5b4graj00159gscq4e5lfvr"},{"post_id":"cj5b4gr6n000a9gscmadpn3b7","tag_id":"cj5b4gr9z000z9gsc7y8fieou","_id":"cj5b4grar00169gsca5me76ju"},{"post_id":"cj5b4gr6r000b9gsc416lrzo0","tag_id":"cj5b4graj00149gsck8m03il4","_id":"cj5b4graz00199gsc0w29qdqt"},{"post_id":"cj5b4gr6r000b9gsc416lrzo0","tag_id":"cj5b4gr9z000z9gsc7y8fieou","_id":"cj5b4graz001a9gscetfv5ym3"},{"post_id":"cj5b4gr6z000d9gscacxtneb2","tag_id":"cj5b4grav00189gsc94tl2wcd","_id":"cj5b4grbb001d9gsca8q1f43i"},{"post_id":"cj5b4gr6z000d9gscacxtneb2","tag_id":"cj5b4graz001b9gscxbaqnf5q","_id":"cj5b4grbf001e9gscijeum2us"},{"post_id":"cj5b4gr77000f9gscu2nvdll9","tag_id":"cj5b4grb3001c9gsc2flassd0","_id":"cj5b4grbj001g9gsci7vbf4rb"},{"post_id":"cj5b4gr77000f9gscu2nvdll9","tag_id":"cj5b4gr6v000c9gsceqnkdis3","_id":"cj5b4grbj001h9gsckwclicpa"},{"post_id":"cj5b4gr7n000j9gsc39fcyvpk","tag_id":"cj5b4grbf001f9gscxqqn7aup","_id":"cj5b4grbr001l9gsctqvvzs5f"},{"post_id":"cj5b4gr7n000j9gsc39fcyvpk","tag_id":"cj5b4grbj001i9gscvl6lv0lj","_id":"cj5b4grbr001m9gscx359cky8"},{"post_id":"cj5b4gr7n000j9gsc39fcyvpk","tag_id":"cj5b4grbn001j9gsc5gkyuppz","_id":"cj5b4grbv001o9gscu75trkob"},{"post_id":"cj5b4gr7z000m9gscliu94fjv","tag_id":"cj5b4grbr001k9gscui8fy8nf","_id":"cj5b4grbv001p9gscs7qjc2o7"},{"post_id":"cj5b4gr93000p9gscmucyb6wh","tag_id":"cj5b4gr5300049gscmedtz2yv","_id":"cj5b4grc3001s9gscjdd0azjy"},{"post_id":"cj5b4gr93000p9gscmucyb6wh","tag_id":"cj5b4grbr001n9gsckj45nu1y","_id":"cj5b4grc3001t9gscm021yggb"},{"post_id":"cj5b4gr93000p9gscmucyb6wh","tag_id":"cj5b4grbz001q9gscot896g26","_id":"cj5b4grc7001u9gscw9avadur"},{"post_id":"cj5b4gr9b000s9gscmj52fjiw","tag_id":"cj5b4grbz001r9gscytst811m","_id":"cj5b4grc7001v9gscyeo4ee0u"}],"Tag":[{"name":"博客园迁移","_id":"cj5b4gr5300049gscmedtz2yv"},{"name":"cookie","_id":"cj5b4gr6j00099gsc6y1jaj1p"},{"name":"js","_id":"cj5b4gr6v000c9gsceqnkdis3"},{"name":"高阶函数","_id":"cj5b4gr7f000h9gscdqfndkqc"},{"name":"git","_id":"cj5b4gr9j000t9gsc6i482hix"},{"name":"path","_id":"cj5b4gr9r000x9gsc3yaiwz5a"},{"name":"node","_id":"cj5b4gr9z000z9gsc7y8fieou"},{"name":"fs","_id":"cj5b4gra300109gscx64pfyx3"},{"name":"mongoose","_id":"cj5b4graj00149gsck8m03il4"},{"name":"hexo","_id":"cj5b4grav00189gsc94tl2wcd"},{"name":"github","_id":"cj5b4graz001b9gscxbaqnf5q"},{"name":"router","_id":"cj5b4grb3001c9gsc2flassd0"},{"name":"vue","_id":"cj5b4grbf001f9gscxqqn7aup"},{"name":"vuex","_id":"cj5b4grbj001i9gscvl6lv0lj"},{"name":"vue-router","_id":"cj5b4grbn001j9gsc5gkyuppz"},{"name":"css","_id":"cj5b4grbr001k9gscui8fy8nf"},{"name":"setTimeout","_id":"cj5b4grbr001n9gsckj45nu1y"},{"name":"Eventloop","_id":"cj5b4grbz001q9gscot896g26"},{"name":"正则","_id":"cj5b4grbz001r9gscytst811m"}]}}