[{"title":"手写一个router","date":"2017-06-18T15:05:00.000Z","path":"2017/06/18/手写一个router/","text":"最近在玩vue,之前玩的react等，都有涉及到router的概念，router的入门不难，本着好奇的心态，想自己用js写一个router，纯属娱乐，应该不可用于实际项目 前期知识准备 HTML5提供了一个新的API HistoryHistory: 接口允许操作浏览器的曾经在标签页或者框架里访问的历史记录。 window中有个hashchange事件，当 url 的 hash 发生变化时，会触发该事件 先来个简单版本我们的ruoter先来个简单点的，暂时不用H5的新api，而是通过url中的hashg改变，触发hashchange事件来执行。 思路： 首先我们需要一个容器来存储我们更新url时的回调函数。 当执行当前url对应的回调函数时，我们需要更新我们的页面 我们需要监听url中hash的改变 根据我们上面的思路，我们可以构思出下面的代码1234567891011121314151617181920function Router() &#123; this.routers = &#123;&#125;; //存储路由回调函数,以传入的路径为key,callback为value this.currentUrl = ''; //当前路由&#125;// 注册路由路径和存储回调函数Router.prototype.route = function(path,callback) &#123; this.routers[path] = callback || function() &#123;&#125;&#125;// 更新页面，其实就是执行注册的回调函数Router.prototype.refresh = function() &#123; this.currentUrl = location.hash.slice(1) || '/'; this.routers[this.currentUrl]();&#125;Router.prototype.init = function() &#123; window.addEventListener('load',this.refresh.bind(this),false); window.addEventListener('hashchange',this.refresh.bind(this),false);&#125;window.Router = new Router();window.Router.init(); 经过上面的代买，我们搭建起了一个简单的路由，接下来我们来实战一下12345678910111213141516171819&lt;ul&gt; &lt;li&gt;&lt;a href=\"#/\"&gt;index&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/page1\"&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/page2\"&gt;page2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p class=\"text\"&gt;&lt;/p&gt;&lt;script&gt;var text = document.querySelector('.text');Router.route('/', function() &#123; text.innerHTML = '这里是首页';&#125;);Router.route('/page1', function() &#123; text.innerHTML = '这里是page1';&#125;);Router.route('/page2', function() &#123; text.innerHTML = '这里是page2';&#125;);&lt;/script&gt; 这样，我们点击不同路由，显示不同路由对应的文字 ,点击查看demo 再来个复杂版本通过上面的代码，我们完成了一个简单的js Router,接下来我们再来一个稍微高级一点的版本，真正实现一个router库我们封装一下我们的代码， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109;(function (global, factory) &#123; if (typeof define === 'function' &amp;&amp; (define.amd || define.cmd)) &#123; //AMD/CMD define(function (global) &#123; return factory(global); &#125;); &#125; else if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') &#123; //CommonJS module.exports = factory(global); &#125; else &#123; //Browser global.Router = factory(global); &#125;&#125;(typeof window !== 'undefined' ? window : this, function (window) &#123;var Router = &#123; /** * 注册的所有路由对象 */ hashList: &#123;&#125;, /** * 当前路由 */ index: null, /** * Add router * 注册路由对象 **/ add: function (path,callback) &#123; this.hashList[path] = callback; &#125;, /** * 跳转到指定路由 */ go: function(path) &#123; window.location.hash = '#' + path; &#125;, /** * 删除路由 */ remove: function(path) &#123; delete this.hashList[path]; &#125;, /** * 重新加载页面 */ reload:function() &#123; var self = this; var hash = window.location.hash.replace('#', ''); var addr = hash.split('/')[0]; var cb = self.getCb(addr, self.hashList); if(cb != false) &#123; var arr = hash.split('/'); arr.shift(); cb.apply(self, arr); &#125; else &#123; self.index &amp;&amp; self.go(self.index); &#125; &#125;, /** * 设置主页地址 * @param index: 主页地址 */ setIndex: function(index) &#123; this.index = index; &#125;, /** * 获取callback * @return false or callback */ getCb: function(addr, hashList) &#123; for(var key in hashList) &#123; if(key == addr) &#123; return hashList[key] &#125; &#125; return false; &#125;, /** * 初始化路由 */ init: function (options) &#123; var self = this; window.onhashchange = function() &#123; self.reload(); &#125;; &#125;, start: function() &#123; this.reload(); &#125;&#125;;return Router; &#125;)); 使用方法：1234567891011121314&lt;a href=\"#index\"&gt;首页&lt;/a&gt;&lt;a href=\"#detail/1654499\"&gt;详情页&lt;/a&gt;&lt;script&gt;Router.init();Router.add('index', function() &#123; alert('这里是首页的内容'); &#125;); Router.add('detail', function(id) &#123; alert('这里是详情页，id为'+id);&#125;);Router.setIndex('index'); //设置首页Router.start();&lt;/script&gt; 这里查看demo &ensp;&ensp;&ensp;这样，我们的简单的路由器就完成了，后面我们将HTML5的history API搞进来，弄成一个即可用hash，也可以用history的版本","tags":[{"name":"router","slug":"router","permalink":"https://xianyulaodi.github.io/tags/router/"},{"name":"js","slug":"js","permalink":"https://xianyulaodi.github.io/tags/js/"}]},{"title":"正则表达式学习","date":"2017-05-30T01:04:00.000Z","path":"2017/05/30/正则表达式学习/","text":"&ensp;&ensp;&ensp;&ensp;正则表达式之前学习的时候，因为很久没怎么用，或者用的时候直接找网上现成的，所以都基本忘的差不多了。所以这篇文章即是笔记，也让自己再重新学习一遍正则表达式。&ensp;&ensp;&ensp;&ensp;其实平时在操作一些字符串的时候，用正则的机会还是挺多的，之前没怎么重视正则，这是一个错误。写完这篇文章后，发觉工作中很多地方都可以用到正则，而且用起来其实还是挺爽的。 正则表达式作用&ensp;&ensp;&ensp;&ensp;正则表达式，又称规则表达式，它可以通过一些设定的规则来匹配一些字符串，是一个强大的字符串匹配工具。 正则表达式方法基本语法，正则声明js中，正则的声明有两种方式 直接量语法： 1var reg = /d+/g/ 创建RegExp对象的语法 1var reg = new RegExp(\"\\\\d+\", \"g\"); 这两种声明方式其实还是有区别的，平时的话我比较喜欢第一种，方便一点，如果需要给正则表达式传递参数的话，那么只能用第二种创建RegExp的形式格式：var pattern = new RegExp(&#39;regexp&#39;,&#39;modifier&#39;);regexp： 匹配的模式，也就是上文指的正则规则。modifier: 正则实例的修饰符,可选值有：i : 表示区分大小写字母匹配。m ：表示多行匹配。g : 表示全局匹配。 传参的形式如下：我们用构造函数来生成正则表达式1var re = new RegExp(\"^\\\\d+$\",\"gim\"); 这里需要注意，反斜杠需要转义，所以，直接声明量中的语法为\\d，这里需要为 \\\\d那么，给它加变量，就和我们前面写的给字符串加变量一样了。12var v = \"bl\";var re =new RegExp(\"^\\\\d+\" + v + \"$\",\"gim\"); // re为/^\\d+bl$/gim 支持正则的String对象方法 search 方法 作用： 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的字符串 基本语法： stringObject.search(regexp); 返回值： 该字符串中第一个与regexp对象相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回-1； 注意点： search()方法不执行全局匹配，它将忽略标志g，1234567891011121314var str = \"hello world,hello world\";// 返回匹配到的第一个位置(使用的regexp对象检索)console.log(str.search(/hello/)); // 0// 没有全局的概念 总是返回匹配到的第一个位置console.log(str.search(/hello/g)); //0console.log(str.search(/world/)); // 6// 如果没有检索到的话，则返回-1console.log(str.search(/longen/)); // -1// 我们检索的时候 可以忽略大小写来检索var str2 = \"Hello\";console.log(str2.search(/hello/i)); // 0 match()方法 作用： 该方法用于在字符串内检索指定的值，或找到一个或者多个正则表达式的匹配。类似于indexOf()或者lastIndexOf(); 基本语法： stringObject.match(searchValue) 或者stringObject.match(regexp) 返回值：&ensp;&ensp;存放匹配成功的数组; 它可以全局匹配模式，全局匹配的话，它返回的是一个数组。如果没有找到任何的一个匹配，那么它将返回的是null；&ensp;&ensp;返回的数组内有三个元素，第一个元素的存放的是匹配的文本，还有二个对象属性&ensp;&ensp;index属性表明的是匹配文本的起始字符在stringObject中的位置，input属性声明的是对stringObject对象的引用1234567var str = \"hello world\";console.log(str.match(\"hello\")); // [\"hello\", index: 0, input: \"hello world\"]console.log(str.match(\"Helloy\")); // nullconsole.log(str.match(/hello/)); // [\"hello\", index: 0, input: \"hello world\"]// 全局匹配var str2=\"1 plus 2 equal 3\"console.log(str2.match(/\\d+/g)); //[\"1\", \"2\", \"3\"] replace()方法 作用： 该方法用于在字符串中使用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子字符串； 基本用法： stringObject.replace(regexp/substr,replacement); 返回值： 返回替换后的新字符串 注意： 字符串的stringObject的replace()方法执行的是查找和替换操作，替换的模式有2种，既可以是字符串，也可以是正则匹配模式，如果是正则匹配模式的话，那么它可以加修饰符g,代表全局替换，否则的话，它只替换第一个匹配的字符串； &ensp;&ensp;replacement 既可以是字符串，也可以是函数，如果它是字符串的话，那么匹配的将与字符串替换，replacement中的$有具体的含义，如下： &ensp;&ensp;$1,$2,$3….$99 含义是：与regexp中的第1到第99个子表达式相匹配的文本。可以看下面的例子 &ensp;&ensp;$&amp; 的含义是：与RegExp相匹配的子字符串。 &ensp;&ensp;lastMatch或RegExp[“$_”]的含义是：返回任何正则表达式搜索过程中的最后匹配的字符。 &ensp;&ensp;lastParen或 RegExp[“$+”]的含义是：返回任何正则表达式查找过程中最后括号的子匹配。 &ensp;&ensp;leftContext或RegExp[“$`”]的含义是：返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。 &ensp;&ensp;rightContext或RegExp[“$’”]的含义是：返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var str = \"hello world\";// 替换字符串var s1 = str.replace(\"hello\",\"a\");console.log(s1);// a world// 使用正则替换字符串var s2 = str.replace(/hello/,\"b\");console.log(s2); // b world// 使用正则全局替换 字符串var s3 = str.replace(/l/g,'');console.log(s3); // heo word// $1,$2 代表的是第一个和第二个子表达式相匹配的文本// 子表达式需要使用小括号括起来,代表的含义是分组var name = \"longen,yunxi\";var s4 = name.replace(/(\\w+)\\s*,\\s*(\\w+)/,\"$2 $1\");console.log(s4); // \"yunxi,longen\"var str = '123-mm';var strReg = str.replace(/(\\d+)-([A-Za-z]+)/g,'$2');console.log(strReg)//mm 上面那段$2这个就是表示正则第二组个匹配到的内容,也就是说$1,$2.. 表示的是第几个括号匹配到的内容// $&amp; 是与RegExp相匹配的子字符串var name = \"hello I am a chinese people\";var regexp = /am/g;if(regexp.test(name)) &#123; //返回正则表达式匹配项的字符串 console.log(RegExp['$&amp;']); // am //返回被搜索的字符串中从最后一个匹配位置开始到字符串结尾之间的字符。 console.log(RegExp[\"$'\"]); // a chinese people //返回被查找的字符串从字符串开始的位置到最后匹配之前的位置之间的字符。 console.log(RegExp['$`']); // hello I // 返回任何正则表达式查找过程中最后括号的子匹配。 console.log(RegExp['$+']); // 空字符串 //返回任何正则表达式搜索过程中的最后匹配的字符。 console.log(RegExp['$_']); // hello I am a chinese people&#125;// replace 第二个参数也可以是一个function 函数var name2 = \"123sdasadsr44565dffghg987gff33234\";name2.replace(/\\d+/g,function(v)&#123; console.log(v); // 第一次打印123 // 第二次打印44565 // 第三次打印987 // 第四次打印 33234&#125;); RegExp对象方法 test()方法 作用： 该方法用于检测一个字符串是否匹配某个模式； 基本语法： RegExpObject.test(str); 返回： 返回true，否则返回false；1234567var str = \"longen and yunxi\";console.log(/longen/.test(str)); // trueconsole.log(/longlong/.test(str)); //false// 或者创建RegExp对象模式var regexp = new RegExp(\"longen\");console.log(regexp.test(str)); // true exec()方法 作用： 该方法用于检索字符串中的正则表达式的匹配 基本语法： RegExpObject.exec(string) 返回值： 返回一个数组，存放匹配的结果，如果未找到匹配，则返回值为null； 注意点： 该返回的数组的第一个元素是与正则表达式相匹配的文本该方法还返回2个属性，index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string；该方法如果不是全局的话，返回的数组与match()方法返回的数组是相同的。123456var str = \"longen and yunxi\";console.log(/longen/.exec(str));// 打印 [\"longen\", index: 0, input: \"longen and yunxi\"]// 假如没有找到的话，则返回nullconsole.log(/wo/.exec(str)); // null 正则表达式类型元字符用于构建正则表达式的符号，常用的有 符号 描述 . 查找任意的单个字符，除换行符外 \\w 任意一个字母或数字或下划线，A_Za_Z09,中任意一个 \\W 查找非单词的字符，等价于[^A_Za_z09 \\d 匹配一个数字字符，等价于[0-9] \\D 匹配一个非数字字符，等价于[^0-9] \\s 匹配任何空白字符，包括空格，制表符，换行符等等。等价于[\\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，等价于[^\\f\\n\\r\\t\\v] \\b 匹配一个单词边界，也就是指单词和空格间的位置，比如’er\\b’可以匹配”never”中的”er”,但是不能匹配”verb”中的”er” \\B 匹配非单词边界,’er\\B’能匹配’verb’中的’er’,但不能匹配’never’中的’er’ \\0 匹配非单词边界,’er\\查找NUL字符。 \\n 匹配一个换行符 \\f 匹配一个换页符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\xxx 查找一个以八进制数xxx规定的字符 \\xdd 查找以16进制数dd规定的字符 \\uxxxx 查找以16进制数的xxxx规定的Unicode字符。 其实常用的几个可以简单记为下面的几个意思:\\s : 空格\\S : 非空格\\d : 数字\\D : 非数字\\w : 字符 ( 字母 ，数字，下划线_ )\\W : 非字符例子：是否有不是数字的字符 量词用于限定子模式出现在正则表达式的次数。 符号 描述 + 匹配一次或多次，相当于{1,} * 匹配零次或多次 ，相当于{0,} ? 匹配零次或一次 ，相当于{0,1} {n} 匹配n次 {n,m} 匹配至少n个，最多m个某某的字符串 {n,} 匹配至少n个某字符串 位置符号 符号 描述 $ 结束符号，例子：n$，匹配以n结尾的字符串 ^ 起始符号,例如^n,匹配以n开头的字符串 ?= 肯定正向环视,例：?=n,匹配其后紧接指定的n字符串 ?! 否定正向环视,例如：?!n,匹配其后没有紧接指定的n字符串 ?: 表示不匹配 注意点： &ensp;&ensp;刚开始学习正则的时候，是比较容易混淆 ^ : 放在正则的最开始位置，就代表起始的意思,放在中括号里，表示排除的意思。也就是说，/[^a]/和/^[a]/是不一样的，前者是排除的意思，后者是代表首位&ensp;&ensp;$:正则的最后位置,就代表结束的意思. 分组 符号 描述 竖线 选择(不是他就是她) (…) 分组 字符类 符号 描述 [0-9] 匹配 0 到 9 间的字符 [a-zA-Z] 匹配任意字母 [^0-9] 不等于0到9的其它字符 &ensp;&ensp;()分组符号可以理解为，数学运算中的括号，用于计算的分组使用。[]可以理解为，只要满足括号里面其中的某种条件即可。比如[abc],意思是满足abc中的某一个，这样比较好记。 贪婪模式和非贪婪模式&ensp;&ensp;其实可以简单的理解，贪婪模式就是尽可能多的匹配，非贪婪模式就是尽可能少的匹配. 贪婪模式量词： {x,y} , {x,} , ? , * , 和 + 非贪婪模式量词： {x,y}?，{x,}?，??，*?，和 +?,所以非贪婪模式就是在贪婪模式后面加了一个问号 我们用代码来理解一下贪婪模式和非贪婪模式的区别123456var str = \"&lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2again&lt;p&gt;end&lt;/p&gt;\";// 非贪婪模式1console.log(str.match(/&lt;p&gt;.*?&lt;\\/p&gt;text2/)[0]); // &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2// 贪婪模式console.log(str.match(/&lt;p&gt;.*&lt;\\/p&gt;text2/)[0]); // &lt;p&gt;这是第一段文本&lt;/p&gt;text1&lt;p&gt;这是第二段文本&lt;/p&gt;text2&lt;p&gt;xxx&lt;/p&gt;text2 &ensp;&ensp;从上面的代码中，我们可以看到，非贪婪模式，当它匹配到它需要的第一个满足条件之后，他就会停止了。而贪婪模式则会继续向右边进行匹配下去。注意点：?号在一些量词后面才是指非贪婪模式，如果直接在一些字符串的后面，表示的是匹配0次或1次。如下所示123var str = 'abced';console.log(str.match(/ce?/g)); // [\"ce\"]console.log(reg.match(/cf?/g)); // [\"c\"] 零宽正向断言和负向断言 (?=)零宽正向断言: 括号内表示某个位置右边必须和=右边匹配上 (?!)负向断言: 括号内表示某个位置右边不和!后的字符匹配。概念很抽象，直接看代码：12345678var pattern=/str(?=ings)ing/;// 表示匹配 r 后面必须有ings的 string字符console.log(\"strings.a\".match(pattern)); //[\"string\", index: 0, input: \"strings.a\"]// 同理，匹配string后面必须有s的 string 字符串console.log(\"strings.a\".match(/string(?=s)/)); //[\"string\", index: 0, input: \"strings.a\"]console.log(\"string_x\".match(pattern)); // nullconsole.log(\"string_x\".match(/string(?=s)/)); // null 如果理解了(?=),那么(?!)就很好理解了123var pattern=/string(?!s)/; // 匹配string后面不带s的string字符串console.log(\"strings\".match(pattern)); //nullconsole.log(\"string.\".match(pattern)); //[\"string\", index: 0, input: \"string.\"] 正则表达式实战练习&ensp;&ensp;上面讲的基本都是理论，下面我们来实战一番，以此来巩固我们正则表达式的学习，学习的过程以demo的形式，对我们的知识点进行巩固。&ensp;&ensp;下面的实例是参考这篇文章，有兴趣可以看 原文,不过我整理了一下，个人觉得，把下面的例子都实践一遍，那么就基本掌握正则的使用了，满足平时的工作基本够了。 demo1: 要求：匹配结尾的数字，例如：取出字符串最后一组数字，如：30CACDVB0040 取出40分析：匹配数组字符为\\d,匹配1次或多次为 +，以什么结尾为 $,全局匹配为 g结果：1console.log('30CACDVB0040'.match(/\\d+$/g)); // [\"0040\"] 如果我们只想要最后结尾的最后两个数字，则可以使用量词 {n,m},所以结果为：1console.log('30CACDVB0040'.match(/\\d&#123;1,2&#125;$/g)); // [\"40\"] demo2: 要求:统一空格个数,例如：字符串内字符键有空格，但是空格的数量可能不一致，通过正则将空格的个数统一变为一个。分析： 匹配空格的字符为 \\s结果：12var str ='学 习 正 则';console.log(str.replace(/\\s+/g,' ')); // 学 习 正 则 demo3: 要求：判断字符串是不是由数字组成分析：我们可以这样匹配，以数字 \\d 开头^,以数字结尾 $,匹配零次或多次 *结果：123var str ='学 习 正 则';console.log(/^\\d*$/g.test('123789')); // trueconsole.log(/^\\d*$/g.test('12378b9')); // false demo4: 要求：验证是否为手机号分析：现在手机开头的范围比较多，第一位是【1】开头，第二位则则有【3,4,5,7,8】，第三位则是【0-9】并且匹配9个数字。结果：123var reg = /^1[3|4|5|7|8][0-9]&#123;9&#125;$/; //验证规则console.log(reg.test(15984591578)); //trueconsole.log(reg.test(11984591578)); //false demo5: 要求：删除字符串两端的空格分析：跟demo2类似，匹配空格 ^\\s开头，空格结尾 \\s$结果：12var str = ' 学习正则 ';console.log(str.replace(/^\\s+|\\s+$/,'')); // 学习正则 demo6: 要求：只能输入数字和小数点分析：开头需要匹配为数字，结尾也应为数字，然后再加个点,点必须转义，匹配0次或一次结果：123var reg =/^\\d*\\.?\\d&#123;0,2&#125;$/;console.log(reg.test('125.1')); // trueconsole.log(reg.test('125a')); // false demo7: 要求：只能输入小写的英文字母和小数点，和冒号，正反斜杠(：./)分析：这几个要求组成一个分组，把他们放在一个分组里,点，正反斜杠，冒号需要转义结果：12var reg = /[a-z\\.\\/\\\\:]+/;console.log('79abncdc.ab123'.match(reg)); // [\"abncdc.ab\", index: 2, input: \"79abncdc.ab123\"] demo8: 要求：去掉所有的html标签分析：html标签的形式为,所以我们可以匹配&lt;开始，然后一些内容，再加上结束符 &gt;结果：123var reg = /&lt;[^&gt;]+&gt;/gi;var str = '&lt;ul&gt;&lt;li&gt;hello world&lt;/li&gt;&lt;/ul&gt;';console.log(str.replace(reg,'')); // hello world demo9: 要求：绝对路径变相对路径分析： 比如: &lt;img src=&quot;http://m.163.com/images/163.gif&quot; /&gt; 替换成 &lt;img src=&quot;/images/163.gif&quot; /&gt;.我们要替换http:// 和后面的域名，第一个 / 为止，结果：123var reg = /http:\\/\\/[^\\/]+/g;var str = 'http://m.163.com/images/163.gif';console.log(str.replace(reg,'')); // /images/163.gif demo10: 要求：用于用户名注册，户名只能用中文、英文、数字、下划线、4-16个字符。分析： 匹配中文的正则为 /[\\u4E00-\\u9FA5\\uf900-\\ufa2d]/,英文，数字的元字符为 \\w,量词 {4,16}结果：1234567var reg = /^/[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\w]&#123;4,16&#125;$/;var str1 = 'hellow_1230';var str2 = 'hellow_1230*';var str3 = 'hellow_12304549764654657456465756';console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); //falseconsole.log(reg.test(str3)); // false demo11 : 要求：匹配身份证号分析：身份证为15为或者18位，最后一位为数字或者x结果：123var reg = /^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$/;var str = '44162119920547892X';console.log(reg.test(str)); // true demo12: 要求：验证邮箱分析：邮箱的形式可能为 234564@qq.com; fasdfja@163.com，可以看到，前面为字母或者数字，然后加@,@后面可能是数字或者是其他，然后再加 . 再然后是一些com或者其他字符，我们用()来进行分组；结果：1234567891011var reg = /^([\\w_-])+@([\\w_-])+([\\.\\w_-])+/;var str1 = 'test@hotmail.com';var str2 = 'test@sima.vip.com';var str3 = 'te-st@qq.com.cn'; var str4 = 'te_st@sima.vip.com';var str5 = 'te.._st@sima.vip.com';console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); // trueconsole.log(reg.test(str3)); // trueconsole.log(reg.test(str4)); // trueconsole.log(reg.test(str5)); // false demo13: 要求：匹配源代码中的链接分析：a标签中有href，也可能有class ,id等其他属性，而且不确定a标签后面是否有空格，所以要考虑的东西比较多。结果：123var reg = /&lt;a\\s(\\s*\\w*?\\s*=\\s*\".+?\")*(\\s*href\\s*=\\s*\".+?\")(\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;[\\s\\S]*?&lt;\\/a&gt;/g;var str = '&lt;p&gt;测试链接：&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;&lt;/p&gt;';console.log(str.match(reg)); // [\"&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;\"] demo14: 要求：匹配a标签里面的内容分析：上面的demo中，我们匹配到了a标签，这里的话我们匹配a标签里面的内容，这里要学习一个符号?:表示不匹配，所以我们在前面的括号中加上?:去掉a标签的匹配，然后再a标签内容里加个括号，表示分组。结果：123var reg =/&lt;a\\s(?:\\s*\\w*?\\s*=\\s*\".+?\")*(?:\\s*href\\s*=\\s*\".+?\")(?:\\s*\\w*?\\s*=\\s*\".+?\")*\\s*&gt;([\\s\\S]*?)&lt;\\/a&gt;/;;var str = '&lt;a id = \"test\" href=\"http://bbs.blueidea.com\" title=\"无敌\"&gt;经典论坛&lt;/a&gt;';console.log(str.replace(reg,'$1')); // 经典论坛 $1 表示的是括号里面的分组，由于前面的括号都是不获取，所以获取的第一个括号的内容就是a标签里面的内容 demo15： 要求：获取url的指定参数的值分析： url带参数类似为这样：http://www.baicu.com?type=1&amp;value=789; 所以，要获取的参数要么是在?或者&amp;开头，到下一个&amp;或者直接后面什么都不跟为止。这里我们用new RegExp的形式，因为这样可以传参。结果：12345// 获取url中的value值var url = 'http://www.baicu.com?type=1&amp;value=789';var reg = new RegExp(\"(^|&amp;|\\\\?)value=([^&amp;]*)(&amp;|$)\");console.log(url.match(reg)); //[\"&amp;value=789\", \"&amp;\", \"789\", \"\", index: 27, input: \"http://www.baicu.com?type=1&amp;value=789\"]&#125; 稍微改编一下，我们就可以弄一个获取指定参数值的函数了123456function getUrlParam(name) &#123; var reg = new RegExp(\"(^|&amp;|\\\\?)\" + name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return decodeURIComponent(r[2]); return null;&#125; demo16: 要求：将数字 15476465转变为15,476,465分析：我们可以这样，匹配一个数字，然后它的后面紧跟着三个数字，并且结尾也是要有三个数字，比如 12345689我们找到 12 345 689,符合条件的是数字2和5，因为它后面紧跟着三个数字，并且这样结尾也是三个数字。然后我们在2和5的后面加个,,就达到了我们的目的12,345,689;知识补充：这里我们需要介绍正则的一个知识点，断言?=,它只匹配一个位置。假如匹配一个“人”字，但是你只想匹配中国人的人字，不想匹配法国人的人(?=中国)人;结果：123var str = '15476465';var reg =/(\\d)(?=(\\d&#123;3&#125;)+$)/g;console.log(str.replace(reg,'$1,')); //15,476,465 进一步讲解：/(\\d)(?=(\\d{3})+$)/匹配的是一个数字，即(\\d),它后面的字符串必须是三的倍数，这个表达就是(?=(\\d{3})+$),且最后一次匹配以 3 个数字结尾$1,表示在第一个分组表达式匹配的字符后面加,，这里其实只有一个(\\d)，问号后面的可以看成它的定语。/(\\d)(?=(\\d{3})+$)/g这个表达式通俗来说是：要找到所有的单个字符，这些字符的后面跟随的字符的个数必须是3的倍数，并在符合条件的单个字符后面添加, demo17： 要求：将阿拉伯数字替换为中文大写形式分析：我们可以用replace来弄这个，replace中的function可以获取到匹配的每一个内容，比如返回匹配数字188，那么就会依次返回1,8,8结果：123456var reg = /\\d/g;var arr=new Array(\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\");var str = '189454';console.log(str.replace(reg,function(m) &#123; return arr[m]; //壹捌玖肆伍肆&#125;));","tags":[{"name":"正则","slug":"正则","permalink":"https://xianyulaodi.github.io/tags/正则/"}]},{"title":"老生常谈，css实现左侧固定右侧自适应","date":"2017-05-25T02:20:00.000Z","path":"2017/05/25/老生常谈css实现左侧固定，右侧自适应/","text":"&ensp;&ensp;这是一个在项目中经常使用的一个功能，而且实现方式也比较多，所以我们今天来总结以下几种实现方法 我们的所有html布局都一样，都为下面的布局 1234&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;左边内容&lt;/div&gt; &lt;div class=\"right\"&gt;右边内容&lt;/div&gt;&lt;/div&gt; 方法1：position + margin方法：父集相对定位，左侧绝对定位，右侧margin-left123456789101112131415161718.parent &#123; width: 300px; height: 100px; margin: 100px auto; position: relative;&#125;.left &#123; width: 100px; height: 100px; position: absolute; left: 0; background: red;&#125;.right &#123; height: 100px; margin-left: 100px; background: blue;&#125; 方法2 ： 左测浮动，右侧overflow12345678910111213141516.parent &#123; width: 300px; height: 100px; margin: 100px auto;&#125;.left &#123; width: 100px; height: 100px; float: left; background: red;&#125;.right &#123; height: 100px; overflow: hidden; background: blue;&#125; 方法3：左侧浮动，右侧margin-left跟方法2类似，只是将右侧overflow改为margin-left1234567891011121314151617.parent &#123; width: 300px; height: 100px; margin: 100px auto; position: relative;&#125;.left &#123; width: 100px; height: 100px; float: left; background: red;&#125;.right &#123; height: 100px; margin-left: 100px; background: blue;&#125; 方法4; css3 flex方法： 利用css3的flex属性，右边设置为占比1，填充满剩余空间 12345678910111213141516.parent &#123; width: 300px; height: 100px; margin: 100px auto; display: flex;&#125;.left &#123; width: 100px; height: 100px; background: red;&#125;.right &#123; height: 100px; flex: 1; background: blue;&#125; 方法五：使用CSS3属性calc()进行计算。注意：calc()里的运算符两边必须有空格123456789101112131415161718.parent &#123; width: 300px; height: 100px; margin: 100px auto; position:relative;&#125;.left &#123; width: 100px; height: 100px; float:left; background: red;&#125;.right &#123; height: 100px; float:left; width:calc(100% - 100px); background: blue;&#125; 方法六 左右两边 absolute1234567891011121314151617181920.parent &#123; width: 300px; height: 100px; margin: 100px auto; position:relative;&#125;.left &#123; width: 100px; height: 100px; position: absolute; left: 0; background: red;&#125;.right &#123; height: 100px; position: absolute; left: 100px; right: 0; background: blue;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://xianyulaodi.github.io/tags/css/"}]},{"title":"nodejs之path模块","date":"2017-05-07T10:50:00.000Z","path":"2017/05/07/nodejs之path模块/","text":"&ensp;&ensp;&ensp;&ensp;path 模块是 node 用于整理、转换、合并路径的神器，只要是路径问题，都可以交给它处理。但它仅仅是处理路径字符串，而不会去坚持或处理文件。 格式化路径 path.normalize(p);作用：将不符合规范的路径格式化，简化开发人员中处理各种复杂的路径判断123var path = require('path');path.normalize('/foo/bar//baz/asdf/quux/..'); //==&gt; '/foo/bar/baz/asdf' 路径合并 path.join([path1], [path2], […]);作用：将所有名称用path.seq串联起来，然后用normailze格式化，规范化的路径字符串。12path.join('///foo', 'bar', '//baz/asdf', 'quux', '..');//==&gt; '/foo/bar/baz/asdf' 绝对路径 path.resolve([from …], to);作用：相当于不断的调用系统的cd命令1234567path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')//相当于：// cd foo/bar// cd /tmp/file/// cd ..// cd a/../subfile// pwd 相对路径 path.relative(from, to);作用： 返回某个路径下相对于另一个路径的相对位置串.12345678/** * from 当前路径，并且方法返回值是基于from指定到to的相对路径 * to 到哪路径， */var from = 'c:\\\\from\\\\a\\\\', to = 'c:/test/b';var _path = path.relative(from, to);console.log(_path); //..\\..\\test\\b; 表示从from到to的相对路径 文件路径 path.dirname作用： 根据一个文件或目录得到它所在的目录路径，这个很常用。12var myPath = path.dirname(__dirname + '/test/util you.mp3');console.log(myPath); // E:/doc/test/util you.mp3 文件名称 path.basename(p, [ext]);作用： 返回最后一个路径分割后面的文件名，不论是文件还是目录，第二个参数可以忽略文件后缀。1234var str = path.basename('path/upload/file/123.jpg');console.log(str); // 123.jpgvar str = path.basename('path/upload/file/123.jpg', '.jpg');console.log(str); // 123 文件扩展名 path.extname(path);作用：返回最后一个 . 之后的字符串，没有则返回空。12345678var str = path.extname('path/file/abc.txt');console.log(str); // '.txt'var str = path.extname('path/file/abc.');console.log(str); // '.'var str = path.extname('path/upload/file/');console.log(str); // '' 解析路径 path.parse作用：把一个路径解析为一个 {root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;} 这样的对象。12345678910111213141516171819path.parse('/home/user/dir/file.txt')// returns&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125;// windowspath.parse('C:\\\\path\\\\dir\\\\index.html')// returns&#123; root : \"C:\\\\\", dir : \"C:\\\\path\\\\dir\", base : \"index.html\", ext : \".html\", name : \"index\"&#125; 生成路径 path.format作用：跟 path.parse 相反，这个则是根据 {root:&#39;&#39;, dir:&#39;&#39;, base:&#39;&#39;, ext:&#39;&#39;, name:&#39;&#39;} 这样的对象来生成字符串123456789path.format(&#123; root : \"/\", dir : \"/home/user/dir\", base : \"file.txt\", ext : \".txt\", name : \"file\"&#125;)// returns'/home/user/dir/file.txt'","tags":[{"name":"path","slug":"path","permalink":"https://xianyulaodi.github.io/tags/path/"},{"name":"node","slug":"node","permalink":"https://xianyulaodi.github.io/tags/node/"}]},{"title":"mongoose的一些操作命令","date":"2017-05-06T03:50:00.000Z","path":"2017/05/06/mongoose的一些操作命令/","text":"&ensp;&ensp;&ensp;&ensp;最近在用express+mongoose写一个网站，因为经常要用到mongoose的一些操作命令，经常去查还挺麻烦的，所以总结一篇mongoose的使用以及一些操作命令。mongoose里面有三个概念，schemal、model、entity。先来对其三者做个小小的总结概括。Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库&ensp;&ensp;&ensp;&ensp;Schema、Model、Entity的关系请牢记，Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。&ensp;&ensp;&ensp;&ensp;你可以使用Model来创建Entity，Entity实体是一个特有Model具体对象，但是他并不具备Model的方法，只能用自己的方法。 1.Schemaschema是mongoose里会用到的一种数据模式，可以理解为表结构的定义；每个schema会映射到mongodb中的一个collection，它不具备操作数据库的能力.仅仅只是一段代码，无法通往数据库端, 仅仅只是数据库模型在程序片段中的一种表现 定义Schema12345678var mongoose = require('./db.js'),var UserSchema = new mongoose.Schema(&#123; username : &#123; type: String &#125;, userpwd: &#123;type: String&#125;, userage: &#123;type: Number&#125;, logindate : &#123; type: Date&#125; &#125;); Schema Types的内置类型 String Number Boolean | Bool Array Buffer Date ObjectId | Oid Mixed 2. Model模型Model模型，是经过Schema构造来的，是Schema的编译版本。一个model的实例直接映射为数据库中的一个文档。基于这种关系， 以后的增删改查（CURD）都要通过这个Model实现。 下面我们来定义我们的model123456789101112var mongoose = require('./db.js');var ObjectId = mongoose.Schema.ObjectId;var UserSchema = new mongoose.Schema(&#123; name : &#123; type: String &#125;, age: &#123;type: Number&#125;, updated:&#123;type:new Date&#125;, binary:&#123; type:Buffer &#125;, _id : &#123; type:ObjectId &#125;, mixed : &#123; type: Mixed &#125;, isMerried :&#123; type : Boolean &#125; &#125;);module.exports = mongoose.model('User',UserSchema); 定义好model之后，就可以往里面进行一些增删查改的操作了。 3. model - 文档操作 增加数据 如果是Entity，使用save方法，如果是Model，使用create方法Model.create(data, callback))1234User.create(data,function(err, doc) &#123; if (err) return console.log(err); console.log(doc); &#125;); 查询 model.find({}, callback); 参数1忽略,或为空对象则返回所有集合文档model.find({},field,callback); 过滤查询,参数2: {‘name’:1, ‘age’:0} 查询文档的返回结果包含name , field的值中,1为包括，0为不包括model.find({},null,{limit:20}); 过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.model.findOne({}, callback); 查询找到的第一个文档model.findById(&#39;obj._i&#39;, callback); 查询找到的第一个文档,同上. 但是只接 _id 的值查询123456789101112131415//findUser.find(&#123;&#125;,function(err, data)&#123; if (err) console.log(err); console.log(data);&#125;)//findOneUser.findOne(&#123;name: '张三'&#125;, function(err, data)&#123; if (err) console.log(err); console.log(data);&#125;)//findByID 与 findOne 相同，但它接收文档的 _id 作为参数，返回单个文档。_id //可以是字符串或 ObjectId 对象。User.findById(id, function(err, data)&#123; if (err) consoel.log(err); console.log(data);&#125;); 更新 Model.update(conditions, data, [options], [callback])conditions 更新条件data 更新内容option 更新选项&ensp;&ensp;safe (boolean) 安全模式，默认选项，值为true&ensp;&ensp;upsert (boolean) 条件不匹配时是否创建新文档，默认值为false&ensp;&ensp;multi (boolean) 是否更新多个文件，默认值为false&ensp;&ensp;strict (boolean) 严格模式，只更新一条数据&ensp;&ensp;overwrite (boolean) 覆盖数据，默认为falsecallback回调123User.update(&#123;name: '张三'&#125;, &#123;age: '6'&#125;, &#123;multi : true&#125;, function(err, numberAffected, raw)&#123; if (err) return console.log(err);&#125;); 删除 Model.remove(conditions,callback);参数1:查询条件123User.remove(&#123;age: 6&#125;, function(err)&#123; if (err) console.log(err);&#125;) 4. Entity - 文档操作由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性创建123456//使用Entity来增加一条数据var krouky = new PersonModel(&#123;name:'krouky'&#125;);krouky.save(callback);//对比使用Model来增加一条数据var MDragon = &#123;name:'MDragon'&#125;;PersonModel.create(MDragon,callback); 5. 修改器和更新器 更新修改器 $inc 增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增11Model.update(&#123;'age':22&#125;, &#123;'$inc':&#123;'age':1&#125; &#125; ); // 执行后: age=23 $set 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.1Model.update(&#123;'age':22&#125;, &#123;'$set':&#123;'age':'haha'&#125; &#125; ); // 执行后: age='haha' $unset 同上取反,删除一个键1Model.update(&#123;'age':22&#125;, &#123;'$unset':&#123;'age':'haha'&#125; &#125; ); //执行后: age键不存在` 数组修改器: $push给一个键push一个数组成员,键不存在会创建1Model.update(&#123;'age':22&#125;, &#123;'$push':&#123;'array':10&#125; &#125; ); //执行后: 增加一个 array 键,类型为数组, 有一个成员 10` $addToSet 向数组中添加一个元素,如果存在就不添加1Model.update(&#123;'age':22&#125;, &#123;'$addToSet':&#123;'array':10&#125; &#125; ); // 执行后: array中有10所以不会添加 $each 遍历数组, 和 $push 修改器配合可以插入多个值1Model.update(&#123;'age':22&#125;, &#123;'$push':&#123;'array':&#123;'$each': [1,2,3,4,5]&#125;&#125; &#125; ); //执行后: array : [10,1,2,3,4,5] $pop 向数组中尾部删除一个元素1Model.update(&#123;'age':22&#125;, &#123;'$pop':&#123;'array':1&#125; &#125; ); //执行后: array : [10,1,2,3,4] tips: 将1改成-1可以删除数组首部元素 $pull 向数组中删除指定元素1Model.update(&#123;'age':22&#125;, &#123;'$pull':&#123;'array':10&#125; &#125; ); // 执行后: array : [1,2,3,4] 匹配到array中的10后将其删除 条件查询: $lt小于$lte 小于等于$gt 大于$gte 大于等于$ne 不等于1Model.find(&#123;'age':&#123; '$get':18 , '$lte':30 &#125; &#125; ); //查询 age 大于等于18并小于等于30的文档 或查询 OR: $in 一个键对应多个值$nin 同上取反, 一个键不对应指定值$or 多个条件匹配, 可以嵌套 $in 使用$not 同上取反, 查询与特定模式不匹配的文档12Model.find(&#123;'age':&#123; '$in':[20,21,22.'haha']&#125; &#125; ); //查询 age等于20或21或21或'haha'的文档Model.find(&#123;'$or' : [ &#123;'age':18&#125; , &#123;'name':'xueyou'&#125; ] &#125;); //查询 age等于18 或 name等于'xueyou' 的文档 类型查询: null 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过 ‘$exists’ 条件判定键值已经存在 “$exists” (表示是否存在的意思)1Model.find('age' : &#123; '$in' : [null] , 'exists' : true &#125; ); // 查询 age值为null的文档 123456Model.find(&#123;name:&#123;$exists:true&#125;&#125;,function(error,docs)&#123; //查询所有存在name属性的文档&#125;);Model.find(&#123;telephone:&#123;$exists:false&#125;&#125;,function(error,docs)&#123; //查询所有不存在telephone属性的文档&#125;); 正则表达式: MongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式12find( &#123;'name' : /joe/i &#125; ); //查询name为 joe 的文档, 并忽略大小写find( &#123;'name' : /joe?/i &#125; ); //查询匹配各种大小写组合 查询数组: Model.find({&#39;array&#39;:10} ); 查询 array(数组类型)键中有10的文档, array : [1,2,3,4,5,10] 会匹配到Model.find({&#39;array[5]&#39;:10} ); 查询 array(数组类型)键中下标5对应的值是10, array : [1,2,3,4,5,10] 会匹配到$all 匹配数组中多个元素Model.find({&#39;array&#39;:[5,10]} ); 查询 匹配array数组中 既有5又有10的文档$size 匹配数组长度Model.find({&#39;array&#39;:{&quot;$size&quot; : 3} } ); 查询 匹配array数组长度为3 的文档$slice 查询子集合返回Model.find({&#39;array&#39;:{&quot;$skice&quot; : 10} } ); 查询 匹配array数组的前10个元素Model.find({&#39;array&#39;:{&quot;$skice&quot; : [5,10] } } ); 查询 匹配array数组的第5个到第10个元素 where 用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回1234567891011121314//where//查询数据类型是字符串时，可支持正则User.where('age', '2').exec(function(err, data)&#123; if (err) console.log(err); console.log(data);&#125;);User .where('age').gte(1).lte(10) .where('name', '张三') .exec(function(err, data)&#123; if (err) console.log(err); console.log(data); &#125;); 游标: limit(3) 限制返回结果的数量,skip(3) 跳过前3个文档,返回其余的sort( {&#39;username&#39;:1 , &#39;age&#39;:-1 } ) 排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序 6.其他 数量查询 12345// //返回数量User.count(&#123;age: 2&#125;, function(err, data)&#123; if (err) console.log(err); console.log(data);&#125;) 分页查询 1234567891011121314151617var User = require(\"./user.js\");function getByPager()&#123; var pageSize = 5; //一页多少条 var currentPage = 1; //当前第几页 var sort = &#123;'logindate':-1&#125;; //排序（按登录时间倒序） var condition = &#123;&#125;; //条件 var skipnum = (currentPage - 1) * pageSize; //跳过数 User.find(condition).skip(skipnum).limit(pageSize).sort(sort).exec(function (err, res) &#123; if (err) &#123; console.log(\"Error:\" + err); &#125; else &#123; console.log(\"Res:\" + res); &#125; &#125;)&#125;getByPager();","tags":[{"name":"node","slug":"node","permalink":"https://xianyulaodi.github.io/tags/node/"},{"name":"mongoose","slug":"mongoose","permalink":"https://xianyulaodi.github.io/tags/mongoose/"}]},{"title":"node核心模块--fs","date":"2017-04-18T15:17:00.000Z","path":"2017/04/18/node核心模块--fs/","text":"文件系统fs-简介 fs模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。与其它模块不同的是，fs模块中所有的操作都提供了异步和同步的两个版本。 一、文件读取–完整性读写 1、fs.readFile fs.readFile(filename,[encoding],[callback(error,data)]是最简单的文件读取函数，它接受一个必选参数filename，表示读取的文件名。 第二个参数encoding是可选的，表示文件字符编码。callback是回调函数，用于接收文件的内容。如果不指定encoding，则callback就是第二个参数。 回调函数提供两个参数err和data，err表示有没有错误发生，data是文件内容。 如果指定encoding，data是一个解析后的字符串，否则将会以Buffer形式表示的二进制数据。 demo11234567891011const fs = require('fs');fs.readFile('./file/readFile.txt','utf8', function(err, data) &#123; if (err) &#123; throw err; &#125; // 读取文件成功 console.log('异步测试： --&gt;'+data);&#125;);//同步var data=fs.readFileSync('./file/readFile.txt','utf-8');console.log('同步测试：--&gt;'+data); 2、fs.writeFilefs.writeFile(filename,data,[options],callback)用来写文件，其中options为对象，有以下几个值：123encoding &#123;String | null&#125; default='utf-8'mode &#123;Number&#125; default=438(aka 0666 in Octal)flag &#123;String&#125; default='w' 这里主要flag值，默认为w,会清空文件，然后再写。flag值，r代表读取文件，w代表写文件，a代表追加。 demo212345678910111213141516171819202122232425const fs = require('fs');// 写入文件内容（如果文件不存在会创建一个文件）// 写入时会先清空文件fs.writeFile('./file/writeFile.txt', '写入成功：hello world', function(err) &#123; if (err) &#123; throw err; &#125; // 写入成功后读取测试 var data=fs.readFileSync('./file/writeFile.txt', 'utf-8'); console.log('new data --&gt;'+data);&#125;);// 数据追加setTimeout(function()&#123; // 追加 fs.writeFile('./file/writeFile.txt', '这里是追加的数据', &#123;'flag':'a'&#125;,function(err) &#123; if (err) &#123; throw err; &#125; console.log('success'); var data=fs.readFileSync('./file/writeFile.txt', 'utf-8') // 写入成功后读取测试 console.log('追加后的数据 --&gt;'+data); &#125;);&#125;,1000); 3、fs.appendFilefs.appendFile(filename, data, [options], callback)该方法以异步的方式将 data 插入到文件里，如果文件不存在会自动创建。data可以是任意字符串或者缓存。与fs.writeFile 方法差别就是 [options]的flag默认值是”a”，所以它以追加方式写入数据.demo312345678910const fs = require('fs');// 写入文件内容（如果文件不存在会创建一个文件）fs.appendFile('./file/appendFile.txt', '新数据456', function(err) &#123; if (err) &#123; throw err; &#125; // 写入成功后读取测试 var data=fs.readFileSync('./file/appendFile.txt', 'utf-8'); console.log(data);&#125;); 4、删除文件 unlink比较简单，没啥好说的，直接上demo demo412345const fs =require('fs');fs.unlink('./file/unlink.txt',function(err)&#123; if(err) return; console.log('成功删除了unlink.txt这个文件');&#125;); 二、文件读取-指定位置读写 &ensp;&ensp;这个跟上面的过程相比，流程稍微麻烦一点点，要先用fs.open来打开文件，然后才可以用fs.read去读，或者用fs.write去写文件，最后，你需要用fs.close去关掉文件。 1、fs.open用法：fs.open(path,flags,[mode],callback) path 文件路径 flags打开文件的方式flags部分值为(没全部列出，需要的话去查即可)：r:以读取模式打开文件r+：以读写模式w：以写入模式打开，如果不存在则创建w+：以读写模式打开，如果不存在则创建a:以追加模式打开文件，如果不存在则创建a+:以读取追加模式打开文件，如果文件不存在则创建。 [mode] 是文件的权限（可选参数，默认值是0666） callback 回调函数demo51234const fs = require('fs');fs.open('./file/open.txt','r','0666',function(err,fd)&#123; console.log(fd); //返回的第二个参数为一个整数，表示打开文件返回的文件描述符，window中又称文件句柄&#125;) 2、fs.read用法fs.read(fd, buffer, offset, length, position, callback); fd, 使用fs.open打开成功后返回的文件描述符 buffer, 一个Buffer对象，v8引擎分配的一段内存 offset, 整数，向缓存区中写入时的初始位置，以字节为单位 length, 整数，读取文件的长度 position, 整数，读取文件初始位置；文件大小以字节为单位 callback(err, bytesRead, buffer), 读取执行完成后回调函数，bytesRead:实际读取字节数，buffer:被读取的缓存区对象 demo61234567891011121314151617181920212223fs.open('./file/open.txt', 'r', function (err, fd) &#123; if(err) &#123; return; &#125; else &#123; var buffer = new Buffer(255); //每一个汉字utf8编码是3个字节，英文是1个字节 fs.read(fd, buffer, 0, 9, 0, function (err, bytesRead, buffer) &#123; if(err) &#123; throw err; &#125; else &#123; console.log(bytesRead); console.log(buffer.slice(0, bytesRead).toString()); //读取完后，再使用fd读取时，基点是基于上次读取位置计算； fs.read(fd, buffer, 0, 20, null, function (err, bytesRead, buffer) &#123; console.log(bytesRead); console.log(buffer.slice(0, bytesRead).toString()); &#125;); &#125; &#125;); &#125;&#125;); 3、fs.write用法fs.write(fd, buffer, offset, length, position, callback); fd, 使用fs.open打开成功后返回的文件描述符 buffer, 一个Buffer对象，v8引擎分配的一段内存 offset, 整数，从缓存区中读取时的初始位置，以字节为单位 length, 整数，从缓存区中读取数据的字节数 position, 整数，写入文件初始位置； callback(err, written, buffer), 写入操作执行完成后回调函数，written实际写入字节数，buffer被读取的缓存区对象 demo7123456789101112131415161718192021222324const fs = require('fs');fs.open(__dirname + '/file/open.txt', 'a', function (err, fd) &#123; if(err) &#123; console.error(err); return; &#125; else &#123; var buffer = new Buffer('写入文件数据内容'); //写入'入文件'三个字 fs.write(fd, buffer, 3, 9, 12, function (err, written, buffer) &#123; if(err) &#123; console.log('写入文件失败'); console.error(err); return; &#125; else &#123; console.log(buffer.toString()); //写入'数据内'三个字 fs.write(fd, buffer, 12, 9, null, function (err, written, buffer) &#123; console.log(buffer.toString()); &#125;) &#125; &#125;); &#125;&#125;); fs.close用法fs.close(fd,callback) fd 文件open时传递的文件描述符 callback 回调函数 三、目录操作 1、fs.mkdir创建目录 demo512345const fs = require('fs');fs.mkdir('./mkdir',function(err)&#123; if(err) return; console.log('创建目录成功');&#125;) 2、fs.rmdir删除目录demo812345const fs = require('fs');fs.rmdir('./mkdir',function(err)&#123; if(err) return; console.log('删除目录成功');&#125;) 3、fs.readdir读取目录返回的data为一个数组，包含该文件夹的所有文件 demo9123456const fs = require('fs');fs.readdir('./file',function(err,data)&#123; if(err) return; //data为一个数组 console.log('读取的数据为：'+data[0]);&#125;); 四、链接文件操作 1、fs.link 创建一个链接fs.link(srcpath, dstpath, [callback(err)]) srcpath为源文件目录或文件的路径 dstpath为转换后的路径 可以理解为复制了一份文件到另一个文件，比如下面的demo8,我们在file文件有一个link.txt，执行后，file文件里面生成了linkFile文件，而且两者的内容是一样的,或者说是源文件的备份 进一步理解fs.link(srcpath, dstpath, [callback])、和 fs.symlink(linkdata, path, [callback])建立文件链接，除非回调函数执行过程出现了异常，否则不会传递任何参数。link和symlink的区别是： link 创建的是hard link 所谓硬链接; symlink创建的是symbolic link 所谓符号链接 硬链接就是备份，软连接就是快捷方式 demo101234const fs = require('fs');fs.link('./file/link.txt','./file/linkFile.txt',function(err)&#123; if(err) return;&#125;) fs.readlink、fs.realpath、fs.unlink fs.readlink(path, [callback]) 读取链接源地址,注意：读取的是软连接中的实际中文名，也就是symlink设置的软连接 fs.realpath(path, [callback]) 获取当前目录或者文件的绝对路径 fs.unlink(path, [callback]) 删除某一个文件链接(删除的是硬链接) demo11123456789101112const fs = require('fs');// readlinkfs.readlink('./file/link2.txt',function(err,data)&#123; console.log(data); //.\\file\\link.txt 返回创建它的软链接,这里，link2是由link创建的软链接&#125;);// realpathfs.realpath('./file/linkFile.txt', function (err, resolvedPath) &#123; if (err) throw err; console.log(resolvedPath); //F:\\myFile\\express\\express-study\\fs\\fsTest\\file\\linkFile.txt 返回绝对路径&#125;); 五、watchfile()，unwatchfile()watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 demo12123456789101112var fs = require('fs');fs.watchFile('./testFile.txt', function (curr, prev) &#123; console.log('the current mtime is: ' + curr.mtime); console.log('the previous mtime was: ' + prev.mtime);&#125;);fs.writeFile('./testFile.txt', \"changed\", function (err) &#123; if (err) throw err; console.log(\"file write complete\"); &#125;); unwatchfile方法用于解除对文件的监听。&ensp;&ensp;&ensp;后记,当然,fs的方法不止上面我列的这些，其他需要用到的话还需要去查。另外，有一个 fs-extra模块也不错，扩展了fs的一些方法。可以去查查","tags":[{"name":"node","slug":"node","permalink":"https://xianyulaodi.github.io/tags/node/"},{"name":"fs","slug":"fs","permalink":"https://xianyulaodi.github.io/tags/fs/"}]},{"title":"hexo+github搭建自己的博客","date":"2017-04-08T07:08:32.000Z","path":"2017/04/08/hexo+github搭建自己的博客/","text":"之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。 前期准备工作 安装hexo npm install -g hexo 创建一个文件夹，如：myBog，cd到myBog里执行hexo init命令 执行hexo generate （hexo g 也可以） 执行hexo server hexo写博客的步骤新建一篇博客: 方法1： 1hexo new &quot;文章标题&quot; 方法2：在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件 两者的效果是一样的 进行本地发布 执行命令 hexo server 浏览器打开：http://localhost:4000/ 部署到线上，执行三个命令 hexo clean hexo generate 也可以 hexo g hexo deploy或者直接执行 hexo c &amp;&amp; hexo g &amp;&amp; hexo d 一些常用命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 小tips 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。 如何更换主题分为以下个步骤： 选择主题:哪里选呢，可以在这里官方主题 安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 themes/yilia 打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 yilia(你要安装的主题的文件夹名字) 。 验证主题是否启用: 运行 hexo s --debug ，并访问 http://localhost:4000 ，确保站点正确运行。 部署和发布到文章的步骤一样 头像设置在主题文件夹下的_config.yml中：avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460.比如我的是themes/yilia/_config.yml由于我用的是yilia主题，或者直接修改layout/_partial/left-col.ejs的第六行和第八行为：12&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\"&gt;&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\" style=\"width: 100%;height: 100%;opacity: 1;\"&gt; 添加阅读量计划使用 Lean Cloud 可以参考 这里 添加评论模块可以参考这篇文章：评论模块本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄","tags":[{"name":"hexo","slug":"hexo","permalink":"https://xianyulaodi.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://xianyulaodi.github.io/tags/github/"}]},{"title":"git常用命令总结","date":"2017-03-31T07:50:00.000Z","path":"2017/03/31/git常用命令总结/","text":"平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅 正常的开发流程命令1、在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息)1Git clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu 2、进入项目目录，创建分支 git branch 看看当前的分支 git checkout -b develop 切换到develop分支. 3、在自己的分支上进行代码的修改，修改好后，可以提交到远程分支上,提交方法看步骤4 4、每次提交代码时候，需要先同步项目主分支代码 git status 是哪些文件有所修改 git diff 可以查询所修改的代码(git diff 文件名可以查看指定文件修改的内容) git add -A . 添加所有文件到暂缓区(git add 文件名文添加指定的文件) git commit -a -m &quot;这里是注释的内容&quot; 提交所有修改的代码到当前分支上 git push origin develop 提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面 5、发布测试的时候可能用的是分支的代码，测试完了，没问题，要上线了，这时候需要将代码merge到主分支上 6、首先需要切换到主分支master上git checkout master,然后合并分支git merge name这里的name为分支名字。 7、删除分支git branch -d name,然后推送到远程master git push origin master; 有时候可能会是在别人的分支上进行代码的修改，此时，步骤3之后插多一个步骤：将自己的项目分支同步项目主分支（我们项目分支为develop分支）1git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 若代码有冲突，可以这样解决1、git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 先同步一下会出现以上的错误2、pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u,3、在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码4、git commit 之后才能成功 添加修改1、添加文件到暂缓区： git add -A .一次添加所有改变的文件 git add xx将xx文件添加到暂存区 git add . 添加新文件和编辑过的文件不包括删除的文件 git add -u 添加编辑或者删除的文件，不包括新添加的文件。 2、commit文件 git commit -m &quot;这里是注释&quot; 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。 git commit -a -m &quot;这里是注释&quot; 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。 git commit --amend有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。 git commit --amend -a用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交 撤销修改1、撤销commit方法1:&ensp;&ensp;执行git log查看 commit日志，然后git reset --hard commit_idcommit_id是控制台上的hash值方法2:&ensp;&ensp;git reset –hard HEAD^,如果是上上一个版本git reset –hard HEAD^^,如果是上一百个版本git reset –hard HEAD~100;方法3:&ensp;&ensp;git checkout —-文件名 撤销对某个文件的修改,例：git checkout —-readme.txt；&ensp;&ensp;git checkout -- .撤销对所有文件的修改 ！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：git push -f origin 分支名 2、恢复到某一版本现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:git reflog查看历史版本；git reset --hard 版本号 3、撤销add&ensp;&ensp;git reset head &lt;文件名&gt; 撤销对某个文件的add命令&ensp;&ensp;git reset head . 撤销所有文件的add命令 创建与合并分支命令如下： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name.比如将dev分支合并到master下，那么在master分支下执行git merge dev 删除分支：git branch –d name github提交时想忽略某些文件比如我提交的时候，不想提交node_modules这个文件夹或者想忽略掉更多的文件夹，可以在github上或者在你的文件中添加.gitignore这个文件.gitignore里面的内容参考如下：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 本地文件想提交到远程1、如果本地没有初始化git,在本地执行 git init2、git add -A .添加所有文件到暂缓区3、git commit -a -m &quot;添加所有文件&quot;4、git remote add origin https://github.com/xianyulaodi/blogBackups.git。注意需要将origin后面换成自己的Git地址。5、将本地仓库推送到远程仓库git push -u origin master第一次需要这样，以后只要执行git push origin master6、关键！！在执行该命令时有时候会出错，原因是远程的文件未同步下来。此时可以先执行：git pull --rebase origin master将远程文件同步下来。然后在执行推送即可。 完成后在后续的推送文件到远程仓库中可直接执行git push origin master可以看看这里 git常用命令 创建一个空目录 XX指目录名mkdir XX 显示当前目录的路径pwd 把当前的目录变成可以管理的git仓库，生成隐藏.git文件git init 把xx文件添加到暂存区去git add XX 提交文件 –m 后面的是注释git commit –m &quot;XX&quot; 查看仓库状态 git status 查看XX文件修改了那些内容 git diff XX 查看历史记录 git log 回退到上一个版本 git reset –hard HEAD^ 或者 git reset –hard HEAD~如果想回退到100个版本，使用git reset –hard HEAD~100 查看XX文件内容 cat XX 查看历史记录的版本号id git reflog 把XX文件在工作区的修改全部撤销 git checkout --XX 删除XX文件 git rm XX 关联一个远程库 git remote add origin https://github.com/xx 把当前master分支推送到远程库 git push –u(第一次要用-u 以后不需要) origin master 从远程库中克隆 git clone https://github.com/xx 创建dev分支 并切换到dev分支上 git checkout –b dev 查看当前所有的分支 git branch 切换回master分支 git checkout master 在当前的分支上合并dev分支 git merge dev 删除dev分支 git branch –d dev 创建分支 git branch name 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash 查看所有被隐藏的文件列表git stash list 恢复被隐藏的文件，但是内容不删除git stash apply 删除被隐藏文件 git stash drop 恢复文件的同时 也删除文件 git stash pop 查看远程库的信息git remote 查看远程库的详细信息 git remote –v 把master分支推送到远程库对应的远程分支上 git push origin master 把分支推送到远程的分支git push origin develop或者git push origin 本地分支名:远程分支名 常见问题(持续更新)问题1解决方法：执行rm .git/index.lock 问题2在git pull代码的时候，可能会遇到这个问题1234error: Your local changes to the following files would be overwritten by merge: xxx/xxx/xxx.phpPlease, commit your changes or stash them before you can merge.Aborting 出现这个问题的原因是其他人修改了xxx.php并提交到版本库中去了，而你本地也修改了xxx.php，这时候你进行git pull操作就好出现冲突了，解决方法，在上面的提示中也说的很明确了。 保留本地的修改 的改法1）直接commit本地的修改2）通过git stash123git stashgit pullgit stash pop &ensp;&ensp;&ensp;&ensp;通过git stash将工作区恢复到上次提交的内容，同时备份本地所做的修改，之后就可以正常git pull了，git pull完成后，执行git stash pop将之前本地做的修改应用到当前工作区。&ensp;&ensp;&ensp;&ensp;git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。&ensp;&ensp;&ensp;&ensp;git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。&ensp;&ensp;&ensp;&ensp;git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 放弃本地修改 的改法git reset --hardgit pull 问题3git 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:1.按键盘字母 i 进入insert模式2.修改最上面那行黄色合并信息,可以不修改3.按键盘左上角”Esc”4.输入”:wq”,注意是冒号+wq,按回车键即可 问题4git pull的时候，可能会遇到下面的报错1234remote: Counting objects: 369, done. efrror: RPC failed; result=56, HTTP code = 200 atal: The remote end hung up unexpectedly fatal: protocol error: bad pack header 解决方法依次输入以下命令123git config --global pack.windowMemory \"100m\" git config --global pack.SizeLimit \"100m\" git config --global pack.threads \"1\" 问题5git clone的时候，可能会遇到这个报错，很烦人 12345678910akagi201@akgentoo ~/a20-kernel (master*) $ git config http.postBuffer 5024288000akagi201@akgentoo ~/a20-kernel (master*) $ git submodule updateCloning into 'linux-sunxi'...remote: Counting objects: 4022357, done.remote: Compressing objects: 100% (682462/682462), done.error: RPC failed; result=18, HTTP code = 200.31 MiB | 654.00 KiB/sfatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failedClone of 'https://github.com/linux-sunxi/linux-sunxi.git' into submodule path 'linux-sunxi' failed 解决方法：亲测有效 1git clone url --depth 1 比如：1git clone https://github.com/xianyulaodi/express-study.git --depth 1 问题6git pull的时候，可能会遇到如下报错 1234$ git pullerror: You have not concluded your merge (MERGE_HEAD exists).hint: Please, commit your changes before merging.fatal: Exiting because of unfinished merge. 错误可能是因为在你以前pull下来的代码没有自动合并导致的.有2个解决办法: 保留你本地的修改git merge --abortgit reset --mergegit commit xxx -m &quot;注释&quot; 合并后记得一定要提交这个本地的合并git pull 抛弃本地的修改不建议这样做,但是如果你本地修改不大,或者自己有一份备份留存,可以直接用线上最新版本覆盖到本地git fetch --allgit reset --hard origin/mastergit fetch","tags":[{"name":"git","slug":"git","permalink":"https://xianyulaodi.github.io/tags/git/"}]},{"title":"使用vue2+vue-router+vuex写一个cnode的脚手架","date":"2017-03-29T12:46:00.000Z","path":"2017/03/29/使用vue2+vue-router+vuex写一个cnode的脚手架/","text":"&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。 本项目github地址 点击这里 &ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。 &ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑) 首页&ensp;&ensp;详情页 项目简介基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含： 基础库：vue.js、 vue-router2.0版本、vuex、axios 编译/打包工具：webpack、babel、node-sass 单元测试工具：karma、mocha、sinon-chai 本地服务器：express 运行方式 开发环境 npm install 点击start.sh、或者直接cmd里面输入 npm run dev 配置构建项目，构建好的文件会输出到 “dist” 目录， npm run build 服务器，可以查看构建的页面 npm run build-server 单元测试 npm run unit 项目说明&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者 vue组件的生命周期&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下： 如何写一个组件&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例 我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"item-list-wrap\"&gt; &lt;ul class=\"item-list\"&gt; &lt;li v-for=\"item in itemList\"&gt; &lt;router-link :to=\"&#123;name:'detail',params:&#123;id:item.id&#125;&#125;\" &gt;&#123;&#123; item.title &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['itemList'], mounted: function () &#123; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" rel=\"stylesheet/scss\"&gt;.item-list-wrap&#123; background: #fff; .item-list li&#123; height: 45px; line-height: 45px; text-align: left; padding:0 10px; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space:nowrap; border-bottom: 1px solid #ccc; &#125;&#125;&lt;/style&gt; &ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.那么父组件如何调用这些组件呢，使用方法如下：views/index.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;c-header :hTitle=\"title\"&gt;&lt;/c-header&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import cHeader from 'components/header'; import indexItem from 'components/indexItem'; export default &#123; data () &#123; return &#123; title: 'node中文网', tabId:0 &#125; &#125;, computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; components: &#123;cHeader,indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。 &ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过 1&lt;index-item :item-list=传入的数据&gt;&lt;/index-item&gt; &ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码 1components: &#123;cHeader,indexItem&#125; vur-router 我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。 传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取1this.$route.params.id 关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大 vuex2.0&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。 这里稍作解释：(个人理解，有误之处，欢迎指出) vuex也是跟redux一样，有且只能由一个store 在vuex中，状态的改变只能是通过mutations 用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations 触发action用dispatch、触发mutations用commit 这里介绍一下vuex异步的操作&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？1234567891011121314151617181920212223242526272829303132333435363738import Vue from 'vue';import axios from 'axios';import * as types from '../../constants/constants';const state = &#123; topicsList:[]&#125;;const getters = &#123; getTopicsListData: state =&gt; state.topicsList&#125;;const actions = &#123; /** * @name 获取主页数据 * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去 * * # 注意点： * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定 */ [types.GET_TOPICS](&#123;commit&#125;,obj) &#123; axios.get(`https://cnodejs.org/api/v1/topics?page=$&#123;obj.pageNo&#125;&amp;limit=20&amp;tab=$&#123;obj.tab&#125;`) .then((response) =&gt; &#123; commit(types.SET_TOPICS, &#123; list: response.data.data &#125;) &#125;, (err) =&gt; &#123; console.log(err) &#125;) &#125; &#125;const mutations = &#123; // 获取首页的数据 [types.SET_TOPICS](state,&#123;list&#125;) &#123; state.topicsList=list; //再次记住，mutations是唯一允许更新应用状态的地方 &#125;&#125;;export default&#123; state, getters, actions, mutations&#125; &ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下： 我们定义了一个默认的状态topicsList，并赋值为一个空数组 我们定义了一个action来获取后端数据， [types.GET_TOPICS]({commit},obj) {},其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成getTopics({commit},obj) {}这种形式的。action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。 我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态 在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。 页面是如何使用传回来的数据的？ 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;template&gt; &lt;div&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue'; import &#123;mapState&#125; from 'vuex'; import &#123;mapGetters&#125; from 'vuex'; import indexItem from 'components/indexItem'; import * as types from '../constants/constants'; export default &#123; data () &#123; return &#123; title: 'node中文网' &#125; &#125;, // computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新 computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; /* * @获取内容 */ getTopics (page,tab,index) &#123; // 触发action this.$store.dispatch(&#123; type:types.GET_TOPICS, pageNo:page, tab:tab &#125;); this.tabId=index; &#125;, &#125;, /* * @初始化(组件挂载完成)，相当于react中的componentWillamount */ mounted () &#123; this.getTopics(1,'all'); &#125;, components: &#123;indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 getTopics，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：&ensp;&ensp;123computed: mapGetters(&#123; topicsListData :'getTopicsListData'&#125;), &ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式： topicsListData :&#39;getTopicsListData &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。 &ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示 &lt;index-item :item-list=&#39;topicsListData&#39;&gt;&lt;/index-item&gt;; 在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 后记 对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。 后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。 当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出","tags":[{"name":"vue","slug":"vue","permalink":"https://xianyulaodi.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://xianyulaodi.github.io/tags/vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"https://xianyulaodi.github.io/tags/vue-router/"}]},{"title":"老生常谈-从输入url到页面展示到底发生了什么","date":"2017-03-22T12:07:00.000Z","path":"2017/03/22/老生常谈-从输入url到页面展示到底发生了什么/","text":"&ensp;&ensp;&ensp;&ensp; 刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。 &ensp;&ensp;&ensp;&ensp;最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。 总的过程大概如下: 1、输入地址 &ensp;&ensp;&ensp;&ensp;当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。 2、浏览器查找域名的 IP 地址 &ensp;&ensp;&ensp;&ensp; 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。&ensp;&ensp;&ensp;&ensp; 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。&ensp;&ensp;&ensp;&ensp; 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。&ensp;&ensp;&ensp;&ensp;4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。&ensp;&ensp;&ensp;&ensp;5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。&ensp;&ensp;&ensp;&ensp;6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。下面这张图很完美的解释了这一过程： —-知识扩展—- 1)什么是DNS？ DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。 2)DNS查询的两种方式：递归查询和迭代查询 1、递归解析 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2、迭代解析 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 3)DNS域名称空间的组织方式 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例 4)DNS负载均衡 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 3、浏览器向 web 服务器发送一个 HTTP 请求 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。 TCP连接如图所示: 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 请求方法URI协议/版本 请求头(Request Header) 请求正文： 下面是一个完整的HTTP请求例子：123456789GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 （1）请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1（2）请求头(Request Header) 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。123456Accept:image/gif.image/jpeg.*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)Accept-Encoding:gzip,deflate. （3）请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息： username=jinqiao&amp;password=1234 —- 知识扩展—- 1）TCP三次握手 第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 如图所示： 2）为什需要三次握手？&ensp;&ensp;&ensp;&ensp;《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”&ensp;&ensp;&ensp;&ensp;书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。&ensp;&ensp;&ensp;&ensp;假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。 3）TCP四次挥手 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与- SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 4）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 4、服务器的永久重定向响应 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问http://www.google.com/ 而非http://google.com/。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 —-扩展知识—- 1）301和302的区别。 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 2）重定向原因：（1）网站调整（如改变网页目录结构）；（2）网页被移到一个新地址；（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 3）什么时候进行301或者302跳转呢？&ensp;&ensp;&ensp;&ensp;当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。清晰明确而言：使用301跳转的大概场景如下： 域名到期不想续费（或者发现了更适合网站的域名），想换个域名。 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 空间服务器不稳定，换空间的时候。 5、浏览器跟踪重定向地址 现在浏览器知道了 &quot;http://www.google.com/&quot;才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的 6、服务器处理请求 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？ 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 如图所示： 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。 —-扩展阅读—- 1）什么是反向代理？&ensp;&ensp;&ensp;&ensp;客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 7、服务器返回一个 HTTP 响应 经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文12345678910111213HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ 状态行： 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。格式: HTTP-Version Status-Code Reason-Phrase CRLF例如: HTTP/1.1 200 OK \\r\\n| -协议版本：是用http1.0还是其他版本| -状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok| -态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue 101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功 204 No Content 成功，但不返回任何实体的主体部分 206 Partial Content 成功执行了一个范围（Range）请求 3xx： 重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 响应头： 响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有： 响应正文包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文： 8、浏览器显示 HTML 在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括： 解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。具体的过程可以看我这篇文章：点击这里 9、浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接：图片：http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gifCSS式样表：http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.cssJavaScript 文件：http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中 ————————————————-分割线—————————————————– 至此，从输入url到页面展示的过程终于整理完了。本文前前后后整理了差不多一个星期，当然，网上有很多文章的顺序可能跟本文不太一样，也是可以的。 如今已离开呆了一年的大YY，进入了另一家公司，有很多东西在后面等着学习，有点小压力的同时也有很强烈的兴奋，哈哈。愿你在金三银四里找到满意的工作，干巴爹。 当然，文笔有限，有误之处，欢迎指出，本文参考了很多的文章，不过很多文章的链接不记得了，所以只列出了下面三个参考链接。 参考文献：https://segmentfault.com/a/1190000006879700http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/http://zrj.me/archives/589","tags":[{"name":"博客园迁移","slug":"博客园迁移","permalink":"https://xianyulaodi.github.io/tags/博客园迁移/"}]},{"title":"cookie小结","date":"2017-03-12T04:18:00.000Z","path":"2017/03/12/cookie小结/","text":"前记：前段时间搞一个活动，开发的时间被严重压缩，忙到飞起，以致于都没怎么写文章了，内疚. 2月份参加了一场面试，有一些关于cookie的问题回答的不是很好，所以这篇文章我们来对cooKie做一个探讨和总结，查漏补缺。其实本文很早之前都写的差不多了，不过关于cookie跨域方面，查了比较多的资料，始终没有一个太好的结果，所以本文一直没有发布。 本文的很多内容都是参考网上的资料，可以说是好几篇资料的集合，毕竟是总结嘛，就是将自己觉得有用的东西集合在一起。 什么是cookie 官方定义：Netscape官方文档中的定义为，Cookie是指在HTTP协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站Web服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie文件则是指在浏览某个网站时，由Web服务器的CGI脚本创建的存储在浏览器客户端计算机上的一个小文本文件，其格式为：用户名@网站地址 ［数字］.txt。 再通俗一点的讲，由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。 cookie的作用 HTTP协议是一种无状态、无连接的协议，不能在服务器上保持一次会话的连续状态信息。Cookie的作用是记录用户的有关信息，它最根本的用途是帮助Web站点保存有关访问者的信息。如身份识别号码ID、密码、浏览过的网页、停留的时间、用户在Web站点购物的方式或用户访问该站点的次数等，当用户再次链接Web服务器时，浏览器读取Cookie信息并传递给Web站点。 cookie的属性我们先来看一张图： 在谷歌浏览器开发者模式中，我们可以看到网站的cookie，所以，相应的，我们就可以知道cookie的一些属性了，接下来介绍Cookie中的一些属性 如图所示，cookie具有的属性有 Name、value、Domain、path、Expires/Max-Age、Size、HTTP、Secure等等，我们接下来详细了解了解Name：该Cookie的名称，一旦创建，名称便不可更改value:该Cookie的值，如果值为Unicode字符，需要为字符编码,如果值为二进制数据，则需要使用BASE64编码domain：可以访问该Cookie的域名。如果设置为”.google.com”,则所有以”google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”这个domain稍作解释： 非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。 顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。 二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。Path: path字段为可以访问此cookie的页面路径。 比如domain是abc.com, path是/detail，那么只有/detail 路径下的页面可以读取此cookie。Expires/Max-Age: 该Cookie失效时间，单位秒。如果为正数，则Cookie在maxAge秒之后失效。 如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存Cookie. 如果为0，表示删除Cookie。默认是-1Size:cookie的大小http： cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。比如截图中的__jsluidsecure： 设置是否只能通过https来传递此条cookie cookie的特性1、一个浏览器针对一个网站最多存20个Cookie，浏览器一般只允许存放300个Cookie2、每个Cookie的长度不能超过4KB（稀缺）。但不同的浏览器实现的不同3、Cookie的不可跨域名性。 例如：Cookie在客户端是由浏览器来管理的，浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。 cookie的分类cookie有两种类型： 临时Cookie（会话Cookie） 永久Cookie 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。可以类比于本地存储的sessionstore 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。可以类比于本地存储的localstore cookie的操作1、 cookie的发送： 服务器端像客户端发送Cookie是通过HTTP响应报文实现的，在Set-Cookie中设置需要像客户端发送的cookie，cookie格式如下：1·Set-Cookie: &quot;name=value;domain=.domain.com;path=/;expires=Sat, 11 Jun 2016 11:29:42 GMT;HttpOnly;secure&quot; 其中name=value是必选项，其它都是可选项。 客户端的话用js即可操作，由于现在客户端设置大部分用H5的本地存储localstore和sessionstore多一点，所以客户端的这里不做介绍 2、cookie的读取 这里介绍的js来读取cookie，可以直接使用下面的方法，其实就是用document.cookie：12345678910111213function getCookie(name)&#123; var cookieName=encodeURIComponent(name)+\"=\", cookieStart=document.cookie.indexOf(cookieName), cookieValue=null; if(cookieStart&gt;-1)&#123; var cookieEnd=document.cookie.indexOf(\";\",cookieStart); if(cookieEnd==-1)&#123; cookieEnd=document.cookie.Length; &#125; cookieValue=decodeURIComponent(document.cookie.substring(cookieStart+document.cookie.length,cookieEnd)); &#125; return cookieValue;&#125; 3、cookie的修改与删除 Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。 Cookie的实现原理 Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。如下图所示： 这个跟其实跟浏览器你器缓存有点类似，具体的过程我们可以分解分解：（1）客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。（2）服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。（3）客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookie.txt文件储存在客户端计算机里。（4）当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookie.txt文件。如果找到，则根据此Cookie.txt产生Cookie报头，放在HTTP请求报文中发给服务器。（5）服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件，例如，浏览器的打开或刷新网页操作。 Cookie的安全问题 通常cookie信息都是使用http连接传递数据，这种传递方式很容易被查看，而且js里面直接有一个document.cookie方法，可以直接获取到用户的cooie,所以cookie存储的信息容易被窃取。假如cookie中所传递的内容比较重要，那么就要求使用加密的数据传输。 如何来防范cookie的安全呢？有以下几种方法： HttpOnly属性 如果在Cookie中设置了”HttpOnly”属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。 secure属性 当设置为true时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该信息，所以不会被盗取到Cookie 的具体内容。 我们再来看看一道经典的面试题：登录时候用cookie的话，安全性问题怎么解决？这个问题，网上找了比较久的答案，比较满意的有两种答案（答案是网上找的） 第1种是：把用户对象（包含了用户ID、用户名、是否登录..）序列化成字符串再加密存入Cookie。密钥是：客户端IP+浏览器Agent+用户标识+固定的私有密钥当cookie被窃取后，只要任一信息不匹配，就无法解密cookie，进而也就不能登录了。这样做的缺点是IP不能变动、频繁加密解密会加重CPU负担 第2种是：将用户的认证信息保存在一个cookie中，具体如下： cookie名：uid。推荐进行加密，比如MD5(‘站点名称’)等。 cookie值：登录名|有效时间Expires|hash值。hash值可以由”登录名+有效时间Expires+用户密码（加密后的）的前几位 +salt” (salt是保证在服务器端站点配置文件中的随机数)这样子设计有以下几个优点：1.即使数据库被盗了，盗用者还是无法登录到系统，因为组成cookie值的salt是保证在服务器站点配置文件中而非数据 库。2.如果账户被盗了，用户修改密码，可以使盗用者的cookie值无效。3.如果服务器端的数据库被盗了，通过修改salt值可以使所有用户的cookie值无效，迫使用户重新登录系统。4.有效时间Expires可以设置为当前时间+过去时间（比如2天），这样可以保证每次登录的cookie值都不一样，防止盗用者 窥探到自己的cookie值后作为后门，长期登录。 cookie跨地址，跨域问题以及解决方案 cookie是不能跨域访问的，那么，假如需要跨域来进行cookie的访问和传递，该怎么办呢？查找了比较多的资料，比较少这方面的资料， 在cookie跨域这个问题上，前端能做的不多，很多都是需要和后端一起配合来完成。 总结了下面的几种方法，具体的实现过程这里没有写，可以点击我提供的链接自己看看。 前2种具体的实现方法可以点击看这里:点我1、nginx方向代理： 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 反向代理服务器对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理 的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。2、jsonp方法： 这个方法和我们平时处理js跨域的jsonp方法一样。具体实现方法可以看看淘宝的解决方法，点我 3、nodejs的superagent4、iframe方法：比如有个www.a.com/index.html的页面，往www.b.com/index.html的页面传递cookiewww.a.com/index.html这样写：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我是a页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;script type=\"text/javascript\"&gt;document.cookie = \"name=\" + \"value;\" + \"expires=\" + \"datatime;\" + \"domain=\" + \"\" + \"path=\" + \"/path\" + \"; secure\";//name Cookie名字//value Cookie值//expires 有效期截至(单位毫秒)//path 子目录//domain 有效域//secure 是否安全window.location = \"http://www.b.com/index.html?\" + document.cookie; //跳转到b页面&lt;/script&gt;&lt;/html&gt; www.b.com/index.html 这样写： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;我是b页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src='http://www.a.com/index.html' width='100' height='100' style=\"display:none\"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;script type=\"text/javascript\"&gt; var url = window.location.toString();//获取地址 var get = url.substring(url.indexOf(\"abc\"));//获取变量和变量值 var idx = get.indexOf(\"=\");//获取变量名长度 if (idx != -1) { var name = get.substring(0, idx);//获取变量名 var val = get.substring(idx + 1);//获取变量值 setCookie(name, val, 1);//创建Cookie } &lt;/script&gt; &lt;/html&gt; 备注：本文主要是查找了网上比较多的资料来总结cookie的一些知识，文笔有限，有误之处，欢迎指出","tags":[{"name":"博客园迁移","slug":"博客园迁移","permalink":"https://xianyulaodi.github.io/tags/博客园迁移/"},{"name":"cookie","slug":"cookie","permalink":"https://xianyulaodi.github.io/tags/cookie/"}]},{"title":"以setTimeout来聊聊Event Loop","date":"2017-02-26T05:35:00.000Z","path":"2017/02/26/以setTimeout来聊聊Event Loop/","text":"平时的工作中，也许你会经常用到setTimeout这个方法，可是你真的了解setTimeout吗？本文想通过总结setTimeout的用法，顺便来探索javascript里面的事件执行机制。 1、setTimeout基本用法 1、setTimeout(code,millisec) setTimeout函数接受两个参数，第一个参数code是将要推迟执行的函数名或者一段代码，第二个参数millisec是推迟执行的毫秒数。例如：12setTimeout('console.log(2)',100);setTimeout(function()&#123;console.log(2)&#125;,100); 如果直接在setTimeout中直接执行代码， 需要以字符串的形式去写，引擎内部会将字符串转为可执行的代码 2、再来一些简单些的代码123console.log(1);setTimeout('console.log(2)',1000);console.log(3); 是的，如你所愿，依次输出的是 // 1 3 2 3、代码升级版12345678910111213141516console.log(1);setTimeout(function()&#123; console.log(2);&#125;,300);setTimeout(function()&#123; console.log(3)&#125;,400);for (var i = 0;i&lt;10000;i++) &#123; console.log(4);&#125;setTimeout(function()&#123; console.log(5);&#125;,100); 这个时候的输入顺序是怎样的呢？这里先埋个伏笔，因为我们是以setTimeout来聊Event Loop 2、Event Loop简介 什么是Event Loop呢？&ensp;&ensp;&ensp;&ensp;因为javascript是单线程的，所谓的单线程是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个，可以叫它为主线程。&ensp;&ensp;&ensp;&ensp;除了主线程，还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。我们以setTimeout为例，当在代码中调用setTimeout()方法时，注册的延时方法会交由浏览器内核其他模块（以webkit为例，是webcore模块）处理，当延时方法到达触发条件，即到达设置的延时时间时，这一延时方法被添加至任务队列里。这一过程由浏览器内核其他模块处理，与执行引擎主线程独立，执行引擎在主线程方法执行完毕，到达空闲状态时，会从任务队列中顺序获取任务来执行，这一过程是一个不断循环的过程，称为事件循环模型。 Javascript执行引擎的主线程运行的时候，产生堆（heap）和栈（stack）。程序中代码依次进入栈中等待执行，当调用setTimeout()方法时，即图中右侧WebAPIs方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列，依次执行那些满足触发条件的回调函数。 在上图中的callback queue中指的是 “任务队列”，也可以理解为消息的队列，“消息“我们可以简单理解为是：注册异步任务时添加的回调函数。 例如：123setTimeout(function()&#123; console.log(‘hello’);&#125;,100); &ensp;&ensp;&ensp;&ensp;其中里面的function(){console.log(‘hello’)}就是一个消息，任务队列里面保存的就是这些回调函数 3、理解js代码的执行 我们以一段代码的运行来进行理解，代码如下：12345678910111213console.log('start');//Timer1setTimeout(function()&#123; console.log('hello');&#125;,200);//Timer2setTimeout(function()&#123; console.log('world');&#125;,100);console.log('end'); 代码运行的gif图如下： 我们分步骤来进行这个过程解答 1、js执行引擎开始执行上述代码时，会先讲一个main()方法加入执行栈。首先第一个console.log(‘start’)入栈，console.log方法是一个webkit内核支持的普通方法，而不是前面图中WebAPIs涉及的方法，所以这里log(‘start’)方法立即出栈被引擎执行。 2、引擎继续往下，将setTimeout(callback,200)添加到执行栈。setTimeout()方法属于事件循环模型中WebAPIs中的方法，引擎在将setTimeout()方法出栈执行时，将延时执行的函数交给了相应模块，即图右方的timer模块来处理。 3、然后主线程继续向下执行，紧接着将第二个定时器也交给Timer模块，然后执行到第二个console.log()，控制台打印’end’， 4、执行完毕后清空执行栈。但是并没有结束，在主线程执行的同时，Timer模块会检查其中的异步代码，一旦满足触发条件，就会将它添加到任务队列中。Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束,程序处理完毕，main()方法也出栈。 5、在这里再次强调一下，不是setTimeout加入了事件队列，而是setTimeout里面的回调函数加入了事件队列 4、setTimeout问题的解答 回到我们文章之初的那倒题：1234567891011121314151617console.log(1);//Time1setTimeout(function()&#123; console.log(2);&#125;,300);//Time2setTimeout(function()&#123; console.log(3)&#125;,400);for (var i = 0;i&lt;10000;i++) &#123; console.log(4);&#125;//Time3setTimeout(function()&#123; console.log(5);&#125;,100); 如果理解了上面的内容，那么这道题理解起来就比较容易了。 首先是打印出 1，然后是10000个4，那么Time1、Time2、Time3是顺序是如何的呢？ 在这个代码中，for循环比较耗时，在Time1和Timer加入到执行队列中后，主线程依然还在执行for循环中的代码，处于阻塞状态。队列中的Time1和Time2并不会得以执行。当for循环结束，这时才将Time3交由Timer模块去管理，清空执行栈。虽然在这里Time3的延迟时间最短，但是加入任务队列后还是会排在Time1和Time2的后面，所以此时按顺序执行任务队列中的代码，依次打印2、3、5。所以执行结果为： 5、关于setTimeout新的问题1234567891011121314151617console.log(1);//Time1setTimeout(function()&#123; console.log(2);&#125;,300);//Time2setTimeout(function()&#123; console.log(3)&#125;,400);for (var i = 0;i&lt;10000;i++) &#123; console.log(4);&#125;//Time3setTimeout(function()&#123; console.log(5);&#125;,100); 上面这个问题中，Time3加入任务队列的时间比Time2,Time1晚，所以它是最后才执行的。那么问题来了，请看下面代码：12345678910111213141516171819console.log(1);//Time2setTimeout(function()&#123; console.log(3)&#125;,400);//Time1setTimeout(function()&#123; console.log(2);&#125;,300);for (var i = 0;i&lt;10000;i++) &#123; console.log(4);&#125;//Time3setTimeout(function()&#123; console.log(5);&#125;,100); &ensp;&ensp;&ensp;&ensp;我们将Time1和Time2的顺序对换一下，按照前面的说法，Time2先加入任务队列，然后是Time1，再然后是Time3。可是执行的结果还是1、4、2、3、5，这是为什么呢？虽然Time1的执行时间短，可是它比Time2晚加入任务队列啊。&ensp;&ensp;&ensp;&ensp;为了验证这个问题，我们可以提出这样的一个假设：如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大 可能假设听起来比较拗口，我们可以用代码来理解一下： 代码1： 12345678910111213141516//Time2setTimeout(function()&#123; console.log(2);&#125;,400);var start=new Date();for (var i = 0;i&lt;5000;i++) &#123; console.log('这里只是模拟一个耗时操作');&#125;;var end=new Date();console.log('阻塞耗时：'+Number(end-start)+'毫秒');//Time1setTimeout(function()&#123; console.log(3)&#125;,300); Time1比Time2设定的执行时间早100ms，但是Time2先加入任务队列，在Time2和Time1时间有一个阻塞的for循环，执行结果如下： Time2先执行； 代码2：我们把for循环里面的时间设置短一点： 123456789101112131415setTimeout(function()&#123; console.log(2);&#125;,400);var start=new Date();for (var i = 0;i&lt;500;i++) &#123; console.log('这里只是模拟一个耗时操作');&#125;;var end=new Date();console.log('阻塞耗时：'+Number(end-start)+'毫秒');//Time1setTimeout(function()&#123; console.log(3)&#125;,300); 此时，Time1先执行，因为阻塞的耗时小于Time1和Time2的执行间隔时间100毫秒； 代码3：我们再来验证一下，把Time2的执行时间设为350毫秒；12345678910111213141516//Time2setTimeout(function()&#123; console.log(2);&#125;,350);var start=new Date();for (var i = 0;i&lt;500;i++) &#123; console.log('这里只是模拟一个耗时操作');&#125;;var end=new Date();console.log('阻塞耗时：'+Number(end-start)+'毫秒');//Time1setTimeout(function()&#123; console.log(3)&#125;,300); 直接结果为：Time2先执行，因为阻塞的时间大于两个setTimeout之间的间隔时间。 通过上面的假设，我们可以得出这样一个结论：如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大 总结 理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，知道事件的走向，才能更好的驾驭Javascript。本文是对事件循环的一个小小总结，更多的干货，可以看看下面的参考文档。本文有误之处，欢迎指出 参考文档： 【转向Javascript系列】从setTimeout说事件循环模型JavaScript 运行机制详解：再谈Event LoopJavaScript：彻底理解同步、异步和事件循环(Event Loop)","tags":[{"name":"博客园迁移","slug":"博客园迁移","permalink":"https://xianyulaodi.github.io/tags/博客园迁移/"},{"name":"setTimeout","slug":"setTimeout","permalink":"https://xianyulaodi.github.io/tags/setTimeout/"},{"name":"Eventloop","slug":"Eventloop","permalink":"https://xianyulaodi.github.io/tags/Eventloop/"}]}]